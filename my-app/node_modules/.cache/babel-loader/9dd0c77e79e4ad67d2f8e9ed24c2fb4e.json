{"ast":null,"code":"(function (root, factory) {\n  // Node.\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    exports = module.exports = factory();\n  } // Browser Global.\n\n\n  if (typeof window === \"object\") {\n    root.Terraformer = factory();\n  }\n})(this, function () {\n  \"use strict\";\n\n  var exports = {},\n      EarthRadius = 6378137,\n      DegreesPerRadian = 57.295779513082320,\n      RadiansPerDegree = 0.017453292519943,\n      MercatorCRS = {\n    \"type\": \"link\",\n    \"properties\": {\n      \"href\": \"http://spatialreference.org/ref/sr-org/6928/ogcwkt/\",\n      \"type\": \"ogcwkt\"\n    }\n  },\n      GeographicCRS = {\n    \"type\": \"link\",\n    \"properties\": {\n      \"href\": \"http://spatialreference.org/ref/epsg/4326/ogcwkt/\",\n      \"type\": \"ogcwkt\"\n    }\n  };\n  /*\n  Internal: isArray function\n  */\n\n  function isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  }\n  /*\n  Internal: safe warning\n  */\n\n\n  function warn() {\n    var args = Array.prototype.slice.apply(arguments);\n\n    if (typeof console !== undefined && console.warn) {\n      console.warn.apply(console, args);\n    }\n  }\n  /*\n  Internal: Extend one object with another.\n  */\n\n\n  function extend(destination, source) {\n    for (var k in source) {\n      if (source.hasOwnProperty(k)) {\n        destination[k] = source[k];\n      }\n    }\n\n    return destination;\n  }\n  /*\n  Public: Calculate an bounding box for a geojson object\n  */\n\n\n  function calculateBounds(geojson) {\n    if (geojson.type) {\n      switch (geojson.type) {\n        case 'Point':\n          return [geojson.coordinates[0], geojson.coordinates[1], geojson.coordinates[0], geojson.coordinates[1]];\n\n        case 'MultiPoint':\n          return calculateBoundsFromArray(geojson.coordinates);\n\n        case 'LineString':\n          return calculateBoundsFromArray(geojson.coordinates);\n\n        case 'MultiLineString':\n          return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n        case 'Polygon':\n          return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n        case 'MultiPolygon':\n          return calculateBoundsFromNestedArrayOfArrays(geojson.coordinates);\n\n        case 'Feature':\n          return geojson.geometry ? calculateBounds(geojson.geometry) : null;\n\n        case 'FeatureCollection':\n          return calculateBoundsForFeatureCollection(geojson);\n\n        case 'GeometryCollection':\n          return calculateBoundsForGeometryCollection(geojson);\n\n        default:\n          throw new Error(\"Unknown type: \" + geojson.type);\n      }\n    }\n\n    return null;\n  }\n  /*\n  Internal: Calculate an bounding box from an nested array of positions\n  [\n    [\n      [ [lng, lat],[lng, lat],[lng, lat] ]\n    ]\n    [\n      [lng, lat],[lng, lat],[lng, lat]\n    ]\n    [\n      [lng, lat],[lng, lat],[lng, lat]\n    ]\n  ]\n  */\n\n\n  function calculateBoundsFromNestedArrays(array) {\n    var x1 = null,\n        x2 = null,\n        y1 = null,\n        y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var inner = array[i];\n\n      for (var j = 0; j < inner.length; j++) {\n        var lonlat = inner[j];\n        var lon = lonlat[0];\n        var lat = lonlat[1];\n\n        if (x1 === null) {\n          x1 = lon;\n        } else if (lon < x1) {\n          x1 = lon;\n        }\n\n        if (x2 === null) {\n          x2 = lon;\n        } else if (lon > x2) {\n          x2 = lon;\n        }\n\n        if (y1 === null) {\n          y1 = lat;\n        } else if (lat < y1) {\n          y1 = lat;\n        }\n\n        if (y2 === null) {\n          y2 = lat;\n        } else if (lat > y2) {\n          y2 = lat;\n        }\n      }\n    }\n\n    return [x1, y1, x2, y2];\n  }\n  /*\n  Internal: Calculate a bounding box from an array of arrays of arrays\n  [\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n  ]\n  */\n\n\n  function calculateBoundsFromNestedArrayOfArrays(array) {\n    var x1 = null,\n        x2 = null,\n        y1 = null,\n        y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var inner = array[i];\n\n      for (var j = 0; j < inner.length; j++) {\n        var innerinner = inner[j];\n\n        for (var k = 0; k < innerinner.length; k++) {\n          var lonlat = innerinner[k];\n          var lon = lonlat[0];\n          var lat = lonlat[1];\n\n          if (x1 === null) {\n            x1 = lon;\n          } else if (lon < x1) {\n            x1 = lon;\n          }\n\n          if (x2 === null) {\n            x2 = lon;\n          } else if (lon > x2) {\n            x2 = lon;\n          }\n\n          if (y1 === null) {\n            y1 = lat;\n          } else if (lat < y1) {\n            y1 = lat;\n          }\n\n          if (y2 === null) {\n            y2 = lat;\n          } else if (lat > y2) {\n            y2 = lat;\n          }\n        }\n      }\n    }\n\n    return [x1, y1, x2, y2];\n  }\n  /*\n  Internal: Calculate a bounding box from an array of positions\n  [\n    [lng, lat],[lng, lat],[lng, lat]\n  ]\n  */\n\n\n  function calculateBoundsFromArray(array) {\n    var x1 = null,\n        x2 = null,\n        y1 = null,\n        y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var lonlat = array[i];\n      var lon = lonlat[0];\n      var lat = lonlat[1];\n\n      if (x1 === null) {\n        x1 = lon;\n      } else if (lon < x1) {\n        x1 = lon;\n      }\n\n      if (x2 === null) {\n        x2 = lon;\n      } else if (lon > x2) {\n        x2 = lon;\n      }\n\n      if (y1 === null) {\n        y1 = lat;\n      } else if (lat < y1) {\n        y1 = lat;\n      }\n\n      if (y2 === null) {\n        y2 = lat;\n      } else if (lat > y2) {\n        y2 = lat;\n      }\n    }\n\n    return [x1, y1, x2, y2];\n  }\n  /*\n  Internal: Calculate an bounding box for a feature collection\n  */\n\n\n  function calculateBoundsForFeatureCollection(featureCollection) {\n    var extents = [],\n        extent;\n\n    for (var i = featureCollection.features.length - 1; i >= 0; i--) {\n      extent = calculateBounds(featureCollection.features[i].geometry);\n      extents.push([extent[0], extent[1]]);\n      extents.push([extent[2], extent[3]]);\n    }\n\n    return calculateBoundsFromArray(extents);\n  }\n  /*\n  Internal: Calculate an bounding box for a geometry collection\n  */\n\n\n  function calculateBoundsForGeometryCollection(geometryCollection) {\n    var extents = [],\n        extent;\n\n    for (var i = geometryCollection.geometries.length - 1; i >= 0; i--) {\n      extent = calculateBounds(geometryCollection.geometries[i]);\n      extents.push([extent[0], extent[1]]);\n      extents.push([extent[2], extent[3]]);\n    }\n\n    return calculateBoundsFromArray(extents);\n  }\n\n  function calculateEnvelope(geojson) {\n    var bounds = calculateBounds(geojson);\n    return {\n      x: bounds[0],\n      y: bounds[1],\n      w: Math.abs(bounds[0] - bounds[2]),\n      h: Math.abs(bounds[1] - bounds[3])\n    };\n  }\n  /*\n  Internal: Convert radians to degrees. Used by spatial reference converters.\n  */\n\n\n  function radToDeg(rad) {\n    return rad * DegreesPerRadian;\n  }\n  /*\n  Internal: Convert degrees to radians. Used by spatial reference converters.\n  */\n\n\n  function degToRad(deg) {\n    return deg * RadiansPerDegree;\n  }\n  /*\n  Internal: Loop over each array in a geojson object and apply a function to it. Used by spatial reference converters.\n  */\n\n\n  function eachPosition(coordinates, func) {\n    for (var i = 0; i < coordinates.length; i++) {\n      // we found a number so lets convert this pair\n      if (typeof coordinates[i][0] === \"number\") {\n        coordinates[i] = func(coordinates[i]);\n      } // we found an coordinates array it again and run THIS function against it\n\n\n      if (typeof coordinates[i] === \"object\") {\n        coordinates[i] = eachPosition(coordinates[i], func);\n      }\n    }\n\n    return coordinates;\n  }\n  /*\n  Public: Convert a GeoJSON Position object to Geographic (4326)\n  */\n\n\n  function positionToGeographic(position) {\n    var x = position[0];\n    var y = position[1];\n    return [radToDeg(x / EarthRadius) - Math.floor((radToDeg(x / EarthRadius) + 180) / 360) * 360, radToDeg(Math.PI / 2 - 2 * Math.atan(Math.exp(-1.0 * y / EarthRadius)))];\n  }\n  /*\n  Public: Convert a GeoJSON Position object to Web Mercator (102100)\n  */\n\n\n  function positionToMercator(position) {\n    var lng = position[0];\n    var lat = Math.max(Math.min(position[1], 89.99999), -89.99999);\n    return [degToRad(lng) * EarthRadius, EarthRadius / 2.0 * Math.log((1.0 + Math.sin(degToRad(lat))) / (1.0 - Math.sin(degToRad(lat))))];\n  }\n  /*\n  Public: Apply a function agaist all positions in a geojson object. Used by spatial reference converters.\n  */\n\n\n  function applyConverter(geojson, converter, noCrs) {\n    if (geojson.type === \"Point\") {\n      geojson.coordinates = converter(geojson.coordinates);\n    } else if (geojson.type === \"Feature\") {\n      geojson.geometry = applyConverter(geojson.geometry, converter, true);\n    } else if (geojson.type === \"FeatureCollection\") {\n      for (var f = 0; f < geojson.features.length; f++) {\n        geojson.features[f] = applyConverter(geojson.features[f], converter, true);\n      }\n    } else if (geojson.type === \"GeometryCollection\") {\n      for (var g = 0; g < geojson.geometries.length; g++) {\n        geojson.geometries[g] = applyConverter(geojson.geometries[g], converter, true);\n      }\n    } else {\n      geojson.coordinates = eachPosition(geojson.coordinates, converter);\n    }\n\n    if (!noCrs) {\n      if (converter === positionToMercator) {\n        geojson.crs = MercatorCRS;\n      }\n    }\n\n    if (converter === positionToGeographic) {\n      delete geojson.crs;\n    }\n\n    return geojson;\n  }\n  /*\n  Public: Convert a GeoJSON object to ESRI Web Mercator (102100)\n  */\n\n\n  function toMercator(geojson) {\n    return applyConverter(geojson, positionToMercator);\n  }\n  /*\n  Convert a GeoJSON object to Geographic coordinates (WSG84, 4326)\n  */\n\n\n  function toGeographic(geojson) {\n    return applyConverter(geojson, positionToGeographic);\n  }\n  /*\n  Internal: -1,0,1 comparison function\n  */\n\n\n  function cmp(a, b) {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  /*\n  Internal: used for sorting\n  */\n\n\n  function compSort(p1, p2) {\n    if (p1[0] > p2[0]) {\n      return -1;\n    } else if (p1[0] < p2[0]) {\n      return 1;\n    } else if (p1[1] > p2[1]) {\n      return -1;\n    } else if (p1[1] < p2[1]) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  /*\n  Internal: used to determine turn\n  */\n\n\n  function turn(p, q, r) {\n    // Returns -1, 0, 1 if p,q,r forms a right, straight, or left turn.\n    return cmp((q[0] - p[0]) * (r[1] - p[1]) - (r[0] - p[0]) * (q[1] - p[1]), 0);\n  }\n  /*\n  Internal: used to determine euclidean distance between two points\n  */\n\n\n  function euclideanDistance(p, q) {\n    // Returns the squared Euclidean distance between p and q.\n    var dx = q[0] - p[0];\n    var dy = q[1] - p[1];\n    return dx * dx + dy * dy;\n  }\n\n  function nextHullPoint(points, p) {\n    // Returns the next point on the convex hull in CCW from p.\n    var q = p;\n\n    for (var r in points) {\n      var t = turn(p, q, points[r]);\n\n      if (t === -1 || t === 0 && euclideanDistance(p, points[r]) > euclideanDistance(p, q)) {\n        q = points[r];\n      }\n    }\n\n    return q;\n  }\n\n  function convexHull(points) {\n    // implementation of the Jarvis March algorithm\n    // adapted from http://tixxit.wordpress.com/2009/12/09/jarvis-march/\n    if (points.length === 0) {\n      return [];\n    } else if (points.length === 1) {\n      return points;\n    } // Returns the points on the convex hull of points in CCW order.\n\n\n    var hull = [points.sort(compSort)[0]];\n\n    for (var p = 0; p < hull.length; p++) {\n      var q = nextHullPoint(points, hull[p]);\n\n      if (q !== hull[0]) {\n        hull.push(q);\n      }\n    }\n\n    return hull;\n  }\n\n  function isConvex(points) {\n    var ltz;\n\n    for (var i = 0; i < points.length - 3; i++) {\n      var p1 = points[i];\n      var p2 = points[i + 1];\n      var p3 = points[i + 2];\n      var v = [p2[0] - p1[0], p2[1] - p1[1]]; // p3.x * v.y - p3.y * v.x + v.x * p1.y - v.y * p1.x\n\n      var res = p3[0] * v[1] - p3[1] * v[0] + v[0] * p1[1] - v[1] * p1[0];\n\n      if (i === 0) {\n        if (res < 0) {\n          ltz = true;\n        } else {\n          ltz = false;\n        }\n      } else {\n        if (ltz && res > 0 || !ltz && res < 0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function coordinatesContainPoint(coordinates, point) {\n    var contains = false;\n\n    for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {\n      if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {\n        contains = !contains;\n      }\n    }\n\n    return contains;\n  }\n\n  function polygonContainsPoint(polygon, point) {\n    if (polygon && polygon.length) {\n      if (polygon.length === 1) {\n        // polygon with no holes\n        return coordinatesContainPoint(polygon[0], point);\n      } else {\n        // polygon with holes\n        if (coordinatesContainPoint(polygon[0], point)) {\n          for (var i = 1; i < polygon.length; i++) {\n            if (coordinatesContainPoint(polygon[i], point)) {\n              return false; // found in hole\n            }\n          }\n\n          return true;\n        } else {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n\n  function edgeIntersectsEdge(a1, a2, b1, b2) {\n    var ua_t = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);\n    var ub_t = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);\n    var u_b = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);\n\n    if (u_b !== 0) {\n      var ua = ua_t / u_b;\n      var ub = ub_t / u_b;\n\n      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function arraysIntersectArrays(a, b) {\n    if (isNumber(a[0][0])) {\n      if (isNumber(b[0][0])) {\n        for (var i = 0; i < a.length - 1; i++) {\n          for (var j = 0; j < b.length - 1; j++) {\n            if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {\n              return true;\n            }\n          }\n        }\n      } else {\n        for (var k = 0; k < b.length; k++) {\n          if (arraysIntersectArrays(a, b[k])) {\n            return true;\n          }\n        }\n      }\n    } else {\n      for (var l = 0; l < a.length; l++) {\n        if (arraysIntersectArrays(a[l], b)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /*\n  Internal: Returns a copy of coordinates for s closed polygon\n  */\n\n\n  function closedPolygon(coordinates) {\n    var outer = [];\n\n    for (var i = 0; i < coordinates.length; i++) {\n      var inner = coordinates[i].slice();\n\n      if (pointsEqual(inner[0], inner[inner.length - 1]) === false) {\n        inner.push(inner[0]);\n      }\n\n      outer.push(inner);\n    }\n\n    return outer;\n  }\n\n  function pointsEqual(a, b) {\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function coordinatesEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    var na = a.slice().sort(compSort);\n    var nb = b.slice().sort(compSort);\n\n    for (var i = 0; i < na.length; i++) {\n      if (na[i].length !== nb[i].length) {\n        return false;\n      }\n\n      for (var j = 0; j < na.length; j++) {\n        if (na[i][j] !== nb[i][j]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /*\n  Internal: An array of variables that will be excluded form JSON objects.\n  */\n\n\n  var excludeFromJSON = [\"length\"];\n  /*\n  Internal: Base GeoJSON Primitive\n  */\n\n  function Primitive(geojson) {\n    if (geojson) {\n      switch (geojson.type) {\n        case 'Point':\n          return new Point(geojson);\n\n        case 'MultiPoint':\n          return new MultiPoint(geojson);\n\n        case 'LineString':\n          return new LineString(geojson);\n\n        case 'MultiLineString':\n          return new MultiLineString(geojson);\n\n        case 'Polygon':\n          return new Polygon(geojson);\n\n        case 'MultiPolygon':\n          return new MultiPolygon(geojson);\n\n        case 'Feature':\n          return new Feature(geojson);\n\n        case 'FeatureCollection':\n          return new FeatureCollection(geojson);\n\n        case 'GeometryCollection':\n          return new GeometryCollection(geojson);\n\n        default:\n          throw new Error(\"Unknown type: \" + geojson.type);\n      }\n    }\n  }\n\n  Primitive.prototype.toMercator = function () {\n    return toMercator(this);\n  };\n\n  Primitive.prototype.toGeographic = function () {\n    return toGeographic(this);\n  };\n\n  Primitive.prototype.envelope = function () {\n    return calculateEnvelope(this);\n  };\n\n  Primitive.prototype.bbox = function () {\n    return calculateBounds(this);\n  };\n\n  Primitive.prototype.convexHull = function () {\n    var coordinates = [],\n        i,\n        j;\n\n    if (this.type === 'Point') {\n      return null;\n    } else if (this.type === 'LineString' || this.type === 'MultiPoint') {\n      if (this.coordinates && this.coordinates.length >= 3) {\n        coordinates = this.coordinates;\n      } else {\n        return null;\n      }\n    } else if (this.type === 'Polygon' || this.type === 'MultiLineString') {\n      if (this.coordinates && this.coordinates.length > 0) {\n        for (i = 0; i < this.coordinates.length; i++) {\n          coordinates = coordinates.concat(this.coordinates[i]);\n        }\n\n        if (coordinates.length < 3) {\n          return null;\n        }\n      } else {\n        return null;\n      }\n    } else if (this.type === 'MultiPolygon') {\n      if (this.coordinates && this.coordinates.length > 0) {\n        for (i = 0; i < this.coordinates.length; i++) {\n          for (j = 0; j < this.coordinates[i].length; j++) {\n            coordinates = coordinates.concat(this.coordinates[i][j]);\n          }\n        }\n\n        if (coordinates.length < 3) {\n          return null;\n        }\n      } else {\n        return null;\n      }\n    } else if (this.type === \"Feature\") {\n      var primitive = new Primitive(this.geometry);\n      return primitive.convexHull();\n    }\n\n    return new Polygon({\n      type: 'Polygon',\n      coordinates: closedPolygon([convexHull(coordinates)])\n    });\n  };\n\n  Primitive.prototype.toJSON = function () {\n    var obj = {};\n\n    for (var key in this) {\n      if (this.hasOwnProperty(key) && excludeFromJSON.indexOf(key) === -1) {\n        obj[key] = this[key];\n      }\n    }\n\n    obj.bbox = calculateBounds(this);\n    return obj;\n  };\n\n  Primitive.prototype.contains = function (primitive) {\n    return new Primitive(primitive).within(this);\n  };\n\n  Primitive.prototype.within = function (primitive) {\n    var coordinates, i, j, contains; // if we are passed a feature, use the polygon inside instead\n\n    if (primitive.type === 'Feature') {\n      primitive = primitive.geometry;\n    } // point.within(point) :: equality\n\n\n    if (primitive.type === \"Point\") {\n      if (this.type === \"Point\") {\n        return pointsEqual(this.coordinates, primitive.coordinates);\n      }\n    } // point.within(multilinestring)\n\n\n    if (primitive.type === \"MultiLineString\") {\n      if (this.type === \"Point\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var linestring = {\n            type: \"LineString\",\n            coordinates: primitive.coordinates[i]\n          };\n\n          if (this.within(linestring)) {\n            return true;\n          }\n        }\n      }\n    } // point.within(linestring), point.within(multipoint)\n\n\n    if (primitive.type === \"LineString\" || primitive.type === \"MultiPoint\") {\n      if (this.type === \"Point\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          if (this.coordinates.length !== primitive.coordinates[i].length) {\n            return false;\n          }\n\n          if (pointsEqual(this.coordinates, primitive.coordinates[i])) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (primitive.type === \"Polygon\") {\n      // polygon.within(polygon)\n      if (this.type === \"Polygon\") {\n        // check for equal polygons\n        if (primitive.coordinates.length === this.coordinates.length) {\n          for (i = 0; i < this.coordinates.length; i++) {\n            if (coordinatesEqual(this.coordinates[i], primitive.coordinates[i])) {\n              return true;\n            }\n          }\n        }\n\n        if (this.coordinates.length && polygonContainsPoint(primitive.coordinates, this.coordinates[0][0])) {\n          return !arraysIntersectArrays(closedPolygon(this.coordinates), closedPolygon(primitive.coordinates));\n        } else {\n          return false;\n        } // point.within(polygon)\n\n      } else if (this.type === \"Point\") {\n        return polygonContainsPoint(primitive.coordinates, this.coordinates); // linestring/multipoint withing polygon\n      } else if (this.type === \"LineString\" || this.type === \"MultiPoint\") {\n        if (!this.coordinates || this.coordinates.length === 0) {\n          return false;\n        }\n\n        for (i = 0; i < this.coordinates.length; i++) {\n          if (polygonContainsPoint(primitive.coordinates, this.coordinates[i]) === false) {\n            return false;\n          }\n        }\n\n        return true; // multilinestring.within(polygon)\n      } else if (this.type === \"MultiLineString\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var ls = new LineString(this.coordinates[i]);\n\n          if (ls.within(primitive) === false) {\n            contains++;\n            return false;\n          }\n        }\n\n        return true; // multipolygon.within(polygon)\n      } else if (this.type === \"MultiPolygon\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var p1 = new Primitive({\n            type: \"Polygon\",\n            coordinates: this.coordinates[i]\n          });\n\n          if (p1.within(primitive) === false) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    if (primitive.type === \"MultiPolygon\") {\n      // point.within(multipolygon)\n      if (this.type === \"Point\") {\n        if (primitive.coordinates.length) {\n          for (i = 0; i < primitive.coordinates.length; i++) {\n            coordinates = primitive.coordinates[i];\n\n            if (polygonContainsPoint(coordinates, this.coordinates) && arraysIntersectArrays([this.coordinates], primitive.coordinates) === false) {\n              return true;\n            }\n          }\n        }\n\n        return false; // polygon.within(multipolygon)\n      } else if (this.type === \"Polygon\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          if (primitive.coordinates[i].length === this.coordinates.length) {\n            for (j = 0; j < this.coordinates.length; j++) {\n              if (coordinatesEqual(this.coordinates[j], primitive.coordinates[i][j])) {\n                return true;\n              }\n            }\n          }\n        }\n\n        if (arraysIntersectArrays(this.coordinates, primitive.coordinates) === false) {\n          if (primitive.coordinates.length) {\n            for (i = 0; i < primitive.coordinates.length; i++) {\n              coordinates = primitive.coordinates[i];\n\n              if (polygonContainsPoint(coordinates, this.coordinates[0][0]) === false) {\n                contains = false;\n              } else {\n                contains = true;\n              }\n            }\n\n            return contains;\n          }\n        } // linestring.within(multipolygon), multipoint.within(multipolygon)\n\n      } else if (this.type === \"LineString\" || this.type === \"MultiPoint\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var p = {\n            type: \"Polygon\",\n            coordinates: primitive.coordinates[i]\n          };\n\n          if (this.within(p)) {\n            return true;\n          }\n\n          return false;\n        } // multilinestring.within(multipolygon)\n\n      } else if (this.type === \"MultiLineString\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var lines = new LineString(this.coordinates[i]);\n\n          if (lines.within(primitive) === false) {\n            return false;\n          }\n        }\n\n        return true; // multipolygon.within(multipolygon)\n      } else if (this.type === \"MultiPolygon\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var mpoly = {\n            type: \"Polygon\",\n            coordinates: primitive.coordinates[i]\n          };\n\n          if (this.within(mpoly) === false) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    } // default to false\n\n\n    return false;\n  };\n\n  Primitive.prototype.intersects = function (primitive) {\n    // if we are passed a feature, use the polygon inside instead\n    if (primitive.type === 'Feature') {\n      primitive = primitive.geometry;\n    }\n\n    var p = new Primitive(primitive);\n\n    if (this.within(primitive) || p.within(this)) {\n      return true;\n    }\n\n    if (this.type !== 'Point' && this.type !== 'MultiPoint' && primitive.type !== 'Point' && primitive.type !== 'MultiPoint') {\n      return arraysIntersectArrays(this.coordinates, primitive.coordinates);\n    } else if (this.type === 'Feature') {\n      // in the case of a Feature, use the internal primitive for intersection\n      var inner = new Primitive(this.geometry);\n      return inner.intersects(primitive);\n    }\n\n    warn(\"Type \" + this.type + \" to \" + primitive.type + \" intersection is not supported by intersects\");\n    return false;\n  };\n  /*\n  GeoJSON Point Class\n    new Point();\n    new Point(x,y,z,wtf);\n    new Point([x,y,z,wtf]);\n    new Point([x,y]);\n    new Point({\n      type: \"Point\",\n      coordinates: [x,y]\n    });\n  */\n\n\n  function Point(input) {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (input && input.type === \"Point\" && input.coordinates) {\n      extend(this, input);\n    } else if (input && isArray(input)) {\n      this.coordinates = input;\n    } else if (args.length >= 2) {\n      this.coordinates = args;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.Point\";\n    }\n\n    this.type = \"Point\";\n  }\n\n  Point.prototype = new Primitive();\n  Point.prototype.constructor = Point;\n  /*\n  GeoJSON MultiPoint Class\n      new MultiPoint();\n      new MultiPoint([[x,y], [x1,y1]]);\n      new MultiPoint({\n        type: \"MultiPoint\",\n        coordinates: [x,y]\n      });\n  */\n\n  function MultiPoint(input) {\n    if (input && input.type === \"MultiPoint\" && input.coordinates) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiPoint\";\n    }\n\n    this.type = \"MultiPoint\";\n  }\n\n  MultiPoint.prototype = new Primitive();\n  MultiPoint.prototype.constructor = MultiPoint;\n\n  MultiPoint.prototype.forEach = function (func) {\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates]);\n    }\n\n    return this;\n  };\n\n  MultiPoint.prototype.addPoint = function (point) {\n    this.coordinates.push(point);\n    return this;\n  };\n\n  MultiPoint.prototype.insertPoint = function (point, index) {\n    this.coordinates.splice(index, 0, point);\n    return this;\n  };\n\n  MultiPoint.prototype.removePoint = function (remove) {\n    if (typeof remove === \"number\") {\n      this.coordinates.splice(remove, 1);\n    } else {\n      this.coordinates.splice(this.coordinates.indexOf(remove), 1);\n    }\n\n    return this;\n  };\n\n  MultiPoint.prototype.get = function (i) {\n    return new Point(this.coordinates[i]);\n  };\n  /*\n  GeoJSON LineString Class\n      new LineString();\n      new LineString([[x,y], [x1,y1]]);\n      new LineString({\n        type: \"LineString\",\n        coordinates: [x,y]\n      });\n  */\n\n\n  function LineString(input) {\n    if (input && input.type === \"LineString\" && input.coordinates) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.LineString\";\n    }\n\n    this.type = \"LineString\";\n  }\n\n  LineString.prototype = new Primitive();\n  LineString.prototype.constructor = LineString;\n\n  LineString.prototype.addVertex = function (point) {\n    this.coordinates.push(point);\n    return this;\n  };\n\n  LineString.prototype.insertVertex = function (point, index) {\n    this.coordinates.splice(index, 0, point);\n    return this;\n  };\n\n  LineString.prototype.removeVertex = function (remove) {\n    this.coordinates.splice(remove, 1);\n    return this;\n  };\n  /*\n  GeoJSON MultiLineString Class\n      new MultiLineString();\n      new MultiLineString([ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]);\n      new MultiLineString({\n        type: \"MultiLineString\",\n        coordinates: [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]\n      });\n  */\n\n\n  function MultiLineString(input) {\n    if (input && input.type === \"MultiLineString\" && input.coordinates) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiLineString\";\n    }\n\n    this.type = \"MultiLineString\";\n  }\n\n  MultiLineString.prototype = new Primitive();\n  MultiLineString.prototype.constructor = MultiLineString;\n\n  MultiLineString.prototype.forEach = function (func) {\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates]);\n    }\n  };\n\n  MultiLineString.prototype.get = function (i) {\n    return new LineString(this.coordinates[i]);\n  };\n  /*\n  GeoJSON Polygon Class\n      new Polygon();\n      new Polygon([ [[x,y], [x1,y1], [x2,y2]] ]);\n      new Polygon({\n        type: \"Polygon\",\n        coordinates: [ [[x,y], [x1,y1], [x2,y2]] ]\n      });\n  */\n\n\n  function Polygon(input) {\n    if (input && input.type === \"Polygon\" && input.coordinates) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.Polygon\";\n    }\n\n    this.type = \"Polygon\";\n  }\n\n  Polygon.prototype = new Primitive();\n  Polygon.prototype.constructor = Polygon;\n\n  Polygon.prototype.addVertex = function (point) {\n    this.insertVertex(point, this.coordinates[0].length - 1);\n    return this;\n  };\n\n  Polygon.prototype.insertVertex = function (point, index) {\n    this.coordinates[0].splice(index, 0, point);\n    return this;\n  };\n\n  Polygon.prototype.removeVertex = function (remove) {\n    this.coordinates[0].splice(remove, 1);\n    return this;\n  };\n\n  Polygon.prototype.close = function () {\n    this.coordinates = closedPolygon(this.coordinates);\n  };\n\n  Polygon.prototype.hasHoles = function () {\n    return this.coordinates.length > 1;\n  };\n\n  Polygon.prototype.holes = function () {\n    var holes = [];\n\n    if (this.hasHoles()) {\n      for (var i = 1; i < this.coordinates.length; i++) {\n        holes.push(new Polygon([this.coordinates[i]]));\n      }\n    }\n\n    return holes;\n  };\n  /*\n  GeoJSON MultiPolygon Class\n      new MultiPolygon();\n      new MultiPolygon([ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]);\n      new MultiPolygon({\n        type: \"MultiPolygon\",\n        coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n      });\n  */\n\n\n  function MultiPolygon(input) {\n    if (input && input.type === \"MultiPolygon\" && input.coordinates) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiPolygon\";\n    }\n\n    this.type = \"MultiPolygon\";\n  }\n\n  MultiPolygon.prototype = new Primitive();\n  MultiPolygon.prototype.constructor = MultiPolygon;\n\n  MultiPolygon.prototype.forEach = function (func) {\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates]);\n    }\n  };\n\n  MultiPolygon.prototype.get = function (i) {\n    return new Polygon(this.coordinates[i]);\n  };\n\n  MultiPolygon.prototype.close = function () {\n    var outer = [];\n    this.forEach(function (polygon) {\n      outer.push(closedPolygon(polygon));\n    });\n    this.coordinates = outer;\n    return this;\n  };\n  /*\n  GeoJSON Feature Class\n      new Feature();\n      new Feature({\n        type: \"Feature\",\n        geometry: {\n          type: \"Polygon\",\n          coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n        }\n      });\n      new Feature({\n        type: \"Polygon\",\n        coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n      });\n  */\n\n\n  function Feature(input) {\n    if (input && input.type === \"Feature\") {\n      extend(this, input);\n    } else if (input && input.type && input.coordinates) {\n      this.geometry = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.Feature\";\n    }\n\n    this.type = \"Feature\";\n  }\n\n  Feature.prototype = new Primitive();\n  Feature.prototype.constructor = Feature;\n  /*\n  GeoJSON FeatureCollection Class\n      new FeatureCollection();\n      new FeatureCollection([feature, feature1]);\n      new FeatureCollection({\n        type: \"FeatureCollection\",\n        coordinates: [feature, feature1]\n      });\n  */\n\n  function FeatureCollection(input) {\n    if (input && input.type === \"FeatureCollection\" && input.features) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.features = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.FeatureCollection\";\n    }\n\n    this.type = \"FeatureCollection\";\n  }\n\n  FeatureCollection.prototype = new Primitive();\n  FeatureCollection.prototype.constructor = FeatureCollection;\n\n  FeatureCollection.prototype.forEach = function (func) {\n    for (var i = 0; i < this.features.length; i++) {\n      func.apply(this, [this.features[i], i, this.features]);\n    }\n  };\n\n  FeatureCollection.prototype.get = function (id) {\n    var found;\n    this.forEach(function (feature) {\n      if (feature.id === id) {\n        found = feature;\n      }\n    });\n    return new Feature(found);\n  };\n  /*\n  GeoJSON GeometryCollection Class\n      new GeometryCollection();\n      new GeometryCollection([geometry, geometry1]);\n      new GeometryCollection({\n        type: \"GeometryCollection\",\n        coordinates: [geometry, geometry1]\n      });\n  */\n\n\n  function GeometryCollection(input) {\n    if (input && input.type === \"GeometryCollection\" && input.geometries) {\n      extend(this, input);\n    } else if (isArray(input)) {\n      this.geometries = input;\n    } else if (input.coordinates && input.type) {\n      this.type = \"GeometryCollection\";\n      this.geometries = [input];\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.GeometryCollection\";\n    }\n\n    this.type = \"GeometryCollection\";\n  }\n\n  GeometryCollection.prototype = new Primitive();\n  GeometryCollection.prototype.constructor = GeometryCollection;\n\n  GeometryCollection.prototype.forEach = function (func) {\n    for (var i = 0; i < this.geometries.length; i++) {\n      func.apply(this, [this.geometries[i], i, this.geometries]);\n    }\n  };\n\n  GeometryCollection.prototype.get = function (i) {\n    return new Primitive(this.geometries[i]);\n  };\n\n  function createCircle(center, radius, interpolate) {\n    var mercatorPosition = positionToMercator(center);\n    var steps = interpolate || 64;\n    var polygon = {\n      type: \"Polygon\",\n      coordinates: [[]]\n    };\n\n    for (var i = 1; i <= steps; i++) {\n      var radians = i * (360 / steps) * Math.PI / 180;\n      polygon.coordinates[0].push([mercatorPosition[0] + radius * Math.cos(radians), mercatorPosition[1] + radius * Math.sin(radians)]);\n    }\n\n    polygon.coordinates = closedPolygon(polygon.coordinates);\n    return toGeographic(polygon);\n  }\n\n  function Circle(center, radius, interpolate) {\n    var steps = interpolate || 64;\n    var rad = radius || 250;\n\n    if (!center || center.length < 2 || !rad || !steps) {\n      throw new Error(\"Terraformer: missing parameter for Terraformer.Circle\");\n    }\n\n    extend(this, new Feature({\n      type: \"Feature\",\n      geometry: createCircle(center, rad, steps),\n      properties: {\n        radius: rad,\n        center: center,\n        steps: steps\n      }\n    }));\n  }\n\n  Circle.prototype = new Primitive();\n  Circle.prototype.constructor = Circle;\n\n  Circle.prototype.recalculate = function () {\n    this.geometry = createCircle(this.properties.center, this.properties.radius, this.properties.steps);\n    return this;\n  };\n\n  Circle.prototype.center = function (coordinates) {\n    if (coordinates) {\n      this.properties.center = coordinates;\n      this.recalculate();\n    }\n\n    return this.properties.center;\n  };\n\n  Circle.prototype.radius = function (radius) {\n    if (radius) {\n      this.properties.radius = radius;\n      this.recalculate();\n    }\n\n    return this.properties.radius;\n  };\n\n  Circle.prototype.steps = function (steps) {\n    if (steps) {\n      this.properties.steps = steps;\n      this.recalculate();\n    }\n\n    return this.properties.steps;\n  };\n\n  Circle.prototype.toJSON = function () {\n    var output = Primitive.prototype.toJSON.call(this);\n    return output;\n  };\n\n  exports.Primitive = Primitive;\n  exports.Point = Point;\n  exports.MultiPoint = MultiPoint;\n  exports.LineString = LineString;\n  exports.MultiLineString = MultiLineString;\n  exports.Polygon = Polygon;\n  exports.MultiPolygon = MultiPolygon;\n  exports.Feature = Feature;\n  exports.FeatureCollection = FeatureCollection;\n  exports.GeometryCollection = GeometryCollection;\n  exports.Circle = Circle;\n  exports.toMercator = toMercator;\n  exports.toGeographic = toGeographic;\n  exports.Tools = {};\n  exports.Tools.positionToMercator = positionToMercator;\n  exports.Tools.positionToGeographic = positionToGeographic;\n  exports.Tools.applyConverter = applyConverter;\n  exports.Tools.toMercator = toMercator;\n  exports.Tools.toGeographic = toGeographic;\n  exports.Tools.createCircle = createCircle;\n  exports.Tools.calculateBounds = calculateBounds;\n  exports.Tools.calculateEnvelope = calculateEnvelope;\n  exports.Tools.coordinatesContainPoint = coordinatesContainPoint;\n  exports.Tools.polygonContainsPoint = polygonContainsPoint;\n  exports.Tools.arraysIntersectArrays = arraysIntersectArrays;\n  exports.Tools.coordinatesContainPoint = coordinatesContainPoint;\n  exports.Tools.coordinatesEqual = coordinatesEqual;\n  exports.Tools.convexHull = convexHull;\n  exports.Tools.isConvex = isConvex;\n  exports.MercatorCRS = MercatorCRS;\n  exports.GeographicCRS = GeographicCRS;\n  return exports;\n});","map":{"version":3,"names":["root","factory","module","exports","window","Terraformer","EarthRadius","DegreesPerRadian","RadiansPerDegree","MercatorCRS","GeographicCRS","isArray","obj","Object","prototype","toString","call","warn","args","Array","slice","apply","arguments","console","undefined","extend","destination","source","k","hasOwnProperty","calculateBounds","geojson","type","coordinates","calculateBoundsFromArray","calculateBoundsFromNestedArrays","calculateBoundsFromNestedArrayOfArrays","geometry","calculateBoundsForFeatureCollection","calculateBoundsForGeometryCollection","Error","array","x1","x2","y1","y2","i","length","inner","j","lonlat","lon","lat","innerinner","featureCollection","extents","extent","features","push","geometryCollection","geometries","calculateEnvelope","bounds","x","y","w","Math","abs","h","radToDeg","rad","degToRad","deg","eachPosition","func","positionToGeographic","position","floor","PI","atan","exp","positionToMercator","lng","max","min","log","sin","applyConverter","converter","noCrs","f","g","crs","toMercator","toGeographic","cmp","a","b","compSort","p1","p2","turn","p","q","r","euclideanDistance","dx","dy","nextHullPoint","points","t","convexHull","hull","sort","isConvex","ltz","p3","v","res","coordinatesContainPoint","point","contains","l","polygonContainsPoint","polygon","edgeIntersectsEdge","a1","a2","b1","b2","ua_t","ub_t","u_b","ua","ub","isNumber","n","isNaN","parseFloat","isFinite","arraysIntersectArrays","closedPolygon","outer","pointsEqual","coordinatesEqual","na","nb","excludeFromJSON","Primitive","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","Feature","FeatureCollection","GeometryCollection","envelope","bbox","concat","primitive","toJSON","key","indexOf","within","linestring","ls","lines","mpoly","intersects","input","constructor","forEach","addPoint","insertPoint","index","splice","removePoint","remove","get","addVertex","insertVertex","removeVertex","close","hasHoles","holes","id","found","feature","createCircle","center","radius","interpolate","mercatorPosition","steps","radians","cos","Circle","properties","recalculate","output","Tools"],"sources":["/Users/romanradionov/PycharmProjects/reactleafletgeodjango/my-app/node_modules/terraformer/terraformer.js"],"sourcesContent":["(function (root, factory) {\n\n  // Node.\n  if(typeof module === 'object' && typeof module.exports === 'object') {\n    exports = module.exports = factory();\n  }\n\n  // Browser Global.\n  if(typeof window === \"object\") {\n    root.Terraformer = factory();\n  }\n\n}(this, function(){\n  \"use strict\";\n\n  var exports = {},\n      EarthRadius = 6378137,\n      DegreesPerRadian = 57.295779513082320,\n      RadiansPerDegree =  0.017453292519943,\n      MercatorCRS = {\n        \"type\": \"link\",\n        \"properties\": {\n          \"href\": \"http://spatialreference.org/ref/sr-org/6928/ogcwkt/\",\n          \"type\": \"ogcwkt\"\n        }\n      },\n      GeographicCRS = {\n        \"type\": \"link\",\n        \"properties\": {\n          \"href\": \"http://spatialreference.org/ref/epsg/4326/ogcwkt/\",\n          \"type\": \"ogcwkt\"\n        }\n      };\n\n  /*\n  Internal: isArray function\n  */\n  function isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  }\n\n  /*\n  Internal: safe warning\n  */\n  function warn() {\n    var args = Array.prototype.slice.apply(arguments);\n\n    if (typeof console !== undefined && console.warn) {\n      console.warn.apply(console, args);\n    }\n  }\n\n  /*\n  Internal: Extend one object with another.\n  */\n  function extend(destination, source) {\n    for (var k in source) {\n      if (source.hasOwnProperty(k)) {\n        destination[k] = source[k];\n      }\n    }\n    return destination;\n  }\n\n  /*\n  Public: Calculate an bounding box for a geojson object\n  */\n  function calculateBounds (geojson) {\n    if(geojson.type){\n      switch (geojson.type) {\n        case 'Point':\n          return [ geojson.coordinates[0], geojson.coordinates[1], geojson.coordinates[0], geojson.coordinates[1]];\n\n        case 'MultiPoint':\n          return calculateBoundsFromArray(geojson.coordinates);\n\n        case 'LineString':\n          return calculateBoundsFromArray(geojson.coordinates);\n\n        case 'MultiLineString':\n          return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n        case 'Polygon':\n          return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n        case 'MultiPolygon':\n          return calculateBoundsFromNestedArrayOfArrays(geojson.coordinates);\n\n        case 'Feature':\n          return geojson.geometry? calculateBounds(geojson.geometry) : null;\n\n        case 'FeatureCollection':\n          return calculateBoundsForFeatureCollection(geojson);\n\n        case 'GeometryCollection':\n          return calculateBoundsForGeometryCollection(geojson);\n\n        default:\n          throw new Error(\"Unknown type: \" + geojson.type);\n      }\n    }\n    return null;\n  }\n\n  /*\n  Internal: Calculate an bounding box from an nested array of positions\n  [\n    [\n      [ [lng, lat],[lng, lat],[lng, lat] ]\n    ]\n    [\n      [lng, lat],[lng, lat],[lng, lat]\n    ]\n    [\n      [lng, lat],[lng, lat],[lng, lat]\n    ]\n  ]\n  */\n  function calculateBoundsFromNestedArrays (array) {\n    var x1 = null, x2 = null, y1 = null, y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var inner = array[i];\n\n      for (var j = 0; j < inner.length; j++) {\n        var lonlat = inner[j];\n\n        var lon = lonlat[0];\n        var lat = lonlat[1];\n\n        if (x1 === null) {\n          x1 = lon;\n        } else if (lon < x1) {\n          x1 = lon;\n        }\n\n        if (x2 === null) {\n          x2 = lon;\n        } else if (lon > x2) {\n          x2 = lon;\n        }\n\n        if (y1 === null) {\n          y1 = lat;\n        } else if (lat < y1) {\n          y1 = lat;\n        }\n\n        if (y2 === null) {\n          y2 = lat;\n        } else if (lat > y2) {\n          y2 = lat;\n        }\n      }\n    }\n\n    return [x1, y1, x2, y2 ];\n  }\n\n  /*\n  Internal: Calculate a bounding box from an array of arrays of arrays\n  [\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n  ]\n  */\n  function calculateBoundsFromNestedArrayOfArrays (array) {\n    var x1 = null, x2 = null, y1 = null, y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var inner = array[i];\n\n      for (var j = 0; j < inner.length; j++) {\n        var innerinner = inner[j];\n        for (var k = 0; k < innerinner.length; k++) {\n          var lonlat = innerinner[k];\n\n          var lon = lonlat[0];\n          var lat = lonlat[1];\n\n          if (x1 === null) {\n            x1 = lon;\n          } else if (lon < x1) {\n            x1 = lon;\n          }\n\n          if (x2 === null) {\n            x2 = lon;\n          } else if (lon > x2) {\n            x2 = lon;\n          }\n\n          if (y1 === null) {\n            y1 = lat;\n          } else if (lat < y1) {\n            y1 = lat;\n          }\n\n          if (y2 === null) {\n            y2 = lat;\n          } else if (lat > y2) {\n            y2 = lat;\n          }\n        }\n      }\n    }\n\n    return [x1, y1, x2, y2];\n  }\n\n  /*\n  Internal: Calculate a bounding box from an array of positions\n  [\n    [lng, lat],[lng, lat],[lng, lat]\n  ]\n  */\n  function calculateBoundsFromArray (array) {\n    var x1 = null, x2 = null, y1 = null, y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var lonlat = array[i];\n      var lon = lonlat[0];\n      var lat = lonlat[1];\n\n      if (x1 === null) {\n        x1 = lon;\n      } else if (lon < x1) {\n        x1 = lon;\n      }\n\n      if (x2 === null) {\n        x2 = lon;\n      } else if (lon > x2) {\n        x2 = lon;\n      }\n\n      if (y1 === null) {\n        y1 = lat;\n      } else if (lat < y1) {\n        y1 = lat;\n      }\n\n      if (y2 === null) {\n        y2 = lat;\n      } else if (lat > y2) {\n        y2 = lat;\n      }\n    }\n\n    return [x1, y1, x2, y2 ];\n  }\n\n  /*\n  Internal: Calculate an bounding box for a feature collection\n  */\n  function calculateBoundsForFeatureCollection(featureCollection){\n    var extents = [], extent;\n    for (var i = featureCollection.features.length - 1; i >= 0; i--) {\n      extent = calculateBounds(featureCollection.features[i].geometry);\n      extents.push([extent[0],extent[1]]);\n      extents.push([extent[2],extent[3]]);\n    }\n\n    return calculateBoundsFromArray(extents);\n  }\n\n  /*\n  Internal: Calculate an bounding box for a geometry collection\n  */\n  function calculateBoundsForGeometryCollection(geometryCollection){\n    var extents = [], extent;\n\n    for (var i = geometryCollection.geometries.length - 1; i >= 0; i--) {\n      extent = calculateBounds(geometryCollection.geometries[i]);\n      extents.push([extent[0],extent[1]]);\n      extents.push([extent[2],extent[3]]);\n    }\n\n    return calculateBoundsFromArray(extents);\n  }\n\n  function calculateEnvelope(geojson){\n    var bounds = calculateBounds(geojson);\n    return {\n      x: bounds[0],\n      y: bounds[1],\n      w: Math.abs(bounds[0] - bounds[2]),\n      h: Math.abs(bounds[1] - bounds[3])\n    };\n  }\n\n  /*\n  Internal: Convert radians to degrees. Used by spatial reference converters.\n  */\n  function radToDeg(rad) {\n    return rad * DegreesPerRadian;\n  }\n\n  /*\n  Internal: Convert degrees to radians. Used by spatial reference converters.\n  */\n  function degToRad(deg) {\n    return deg * RadiansPerDegree;\n  }\n\n  /*\n  Internal: Loop over each array in a geojson object and apply a function to it. Used by spatial reference converters.\n  */\n  function eachPosition(coordinates, func) {\n    for (var i = 0; i < coordinates.length; i++) {\n      // we found a number so lets convert this pair\n      if(typeof coordinates[i][0] === \"number\"){\n        coordinates[i] = func(coordinates[i]);\n      }\n      // we found an coordinates array it again and run THIS function against it\n      if(typeof coordinates[i] === \"object\"){\n        coordinates[i] = eachPosition(coordinates[i], func);\n      }\n    }\n    return coordinates;\n  }\n\n  /*\n  Public: Convert a GeoJSON Position object to Geographic (4326)\n  */\n  function positionToGeographic(position) {\n    var x = position[0];\n    var y = position[1];\n    return [radToDeg(x / EarthRadius) - (Math.floor((radToDeg(x / EarthRadius) + 180) / 360) * 360), radToDeg((Math.PI / 2) - (2 * Math.atan(Math.exp(-1.0 * y / EarthRadius))))];\n  }\n\n  /*\n  Public: Convert a GeoJSON Position object to Web Mercator (102100)\n  */\n  function positionToMercator(position) {\n    var lng = position[0];\n    var lat = Math.max(Math.min(position[1], 89.99999), -89.99999);\n    return [degToRad(lng) * EarthRadius, EarthRadius/2.0 * Math.log( (1.0 + Math.sin(degToRad(lat))) / (1.0 - Math.sin(degToRad(lat))) )];\n  }\n\n  /*\n  Public: Apply a function agaist all positions in a geojson object. Used by spatial reference converters.\n  */\n  function applyConverter(geojson, converter, noCrs){\n    if(geojson.type === \"Point\") {\n      geojson.coordinates = converter(geojson.coordinates);\n    } else if(geojson.type === \"Feature\") {\n      geojson.geometry = applyConverter(geojson.geometry, converter, true);\n    } else if(geojson.type === \"FeatureCollection\") {\n      for (var f = 0; f < geojson.features.length; f++) {\n        geojson.features[f] = applyConverter(geojson.features[f], converter, true);\n      }\n    } else if(geojson.type === \"GeometryCollection\") {\n      for (var g = 0; g < geojson.geometries.length; g++) {\n        geojson.geometries[g] = applyConverter(geojson.geometries[g], converter, true);\n      }\n    } else {\n      geojson.coordinates = eachPosition(geojson.coordinates, converter);\n    }\n\n    if(!noCrs){\n      if(converter === positionToMercator){\n        geojson.crs = MercatorCRS;\n      }\n    }\n\n    if(converter === positionToGeographic){\n      delete geojson.crs;\n    }\n\n    return geojson;\n  }\n\n  /*\n  Public: Convert a GeoJSON object to ESRI Web Mercator (102100)\n  */\n  function toMercator(geojson) {\n    return applyConverter(geojson, positionToMercator);\n  }\n\n  /*\n  Convert a GeoJSON object to Geographic coordinates (WSG84, 4326)\n  */\n  function toGeographic(geojson) {\n    return applyConverter(geojson, positionToGeographic);\n  }\n\n\n  /*\n  Internal: -1,0,1 comparison function\n  */\n  function cmp(a, b) {\n    if(a < b) {\n      return -1;\n    } else if(a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n  /*\n  Internal: used for sorting\n  */\n  function compSort(p1, p2) {\n    if (p1[0] > p2[0]) {\n      return -1;\n    } else if (p1[0] < p2[0]) {\n      return 1;\n    } else if (p1[1] > p2[1]) {\n      return -1;\n    } else if (p1[1] < p2[1]) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n\n  /*\n  Internal: used to determine turn\n  */\n  function turn(p, q, r) {\n    // Returns -1, 0, 1 if p,q,r forms a right, straight, or left turn.\n    return cmp((q[0] - p[0]) * (r[1] - p[1]) - (r[0] - p[0]) * (q[1] - p[1]), 0);\n  }\n\n  /*\n  Internal: used to determine euclidean distance between two points\n  */\n  function euclideanDistance(p, q) {\n    // Returns the squared Euclidean distance between p and q.\n    var dx = q[0] - p[0];\n    var dy = q[1] - p[1];\n\n    return dx * dx + dy * dy;\n  }\n\n  function nextHullPoint(points, p) {\n    // Returns the next point on the convex hull in CCW from p.\n    var q = p;\n    for(var r in points) {\n      var t = turn(p, q, points[r]);\n      if(t === -1 || t === 0 && euclideanDistance(p, points[r]) > euclideanDistance(p, q)) {\n        q = points[r];\n      }\n    }\n    return q;\n  }\n\n  function convexHull(points) {\n    // implementation of the Jarvis March algorithm\n    // adapted from http://tixxit.wordpress.com/2009/12/09/jarvis-march/\n\n    if(points.length === 0) {\n      return [];\n    } else if(points.length === 1) {\n      return points;\n    }\n\n    // Returns the points on the convex hull of points in CCW order.\n    var hull = [points.sort(compSort)[0]];\n\n    for(var p = 0; p < hull.length; p++) {\n      var q = nextHullPoint(points, hull[p]);\n\n      if(q !== hull[0]) {\n        hull.push(q);\n      }\n    }\n\n    return hull;\n  }\n\n  function isConvex(points) {\n    var ltz;\n\n    for (var i = 0; i < points.length - 3; i++) {\n      var p1 = points[i];\n      var p2 = points[i + 1];\n      var p3 = points[i + 2];\n      var v = [p2[0] - p1[0], p2[1] - p1[1]];\n\n      // p3.x * v.y - p3.y * v.x + v.x * p1.y - v.y * p1.x\n      var res = p3[0] * v[1] - p3[1] * v[0] + v[0] * p1[1] - v[1] * p1[0];\n\n      if (i === 0) {\n        if (res < 0) {\n          ltz = true;\n        } else {\n          ltz = false;\n        }\n      } else {\n        if (ltz && (res > 0) || !ltz && (res < 0)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function coordinatesContainPoint(coordinates, point) {\n    var contains = false;\n    for(var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {\n      if (((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1]) ||\n           (coordinates[j][1] <= point[1] && point[1] < coordinates[i][1])) &&\n          (point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0])) {\n        contains = !contains;\n      }\n    }\n    return contains;\n  }\n\n  function polygonContainsPoint(polygon, point) {\n    if (polygon && polygon.length) {\n      if (polygon.length === 1) { // polygon with no holes\n        return coordinatesContainPoint(polygon[0], point);\n      } else { // polygon with holes\n        if (coordinatesContainPoint(polygon[0], point)) {\n          for (var i = 1; i < polygon.length; i++) {\n            if (coordinatesContainPoint(polygon[i], point)) {\n              return false; // found in hole\n            }\n          }\n\n          return true;\n        } else {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n\n  function edgeIntersectsEdge(a1, a2, b1, b2) {\n    var ua_t = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);\n    var ub_t = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);\n    var u_b  = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);\n\n    if ( u_b !== 0 ) {\n      var ua = ua_t / u_b;\n      var ub = ub_t / u_b;\n\n      if ( 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1 ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function arraysIntersectArrays(a, b) {\n    if (isNumber(a[0][0])) {\n      if (isNumber(b[0][0])) {\n        for (var i = 0; i < a.length - 1; i++) {\n          for (var j = 0; j < b.length - 1; j++) {\n            if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {\n              return true;\n            }\n          }\n        }\n      } else {\n        for (var k = 0; k < b.length; k++) {\n          if (arraysIntersectArrays(a, b[k])) {\n            return true;\n          }\n        }\n      }\n    } else {\n      for (var l = 0; l < a.length; l++) {\n        if (arraysIntersectArrays(a[l], b)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /*\n  Internal: Returns a copy of coordinates for s closed polygon\n  */\n  function closedPolygon(coordinates) {\n    var outer = [ ];\n\n    for (var i = 0; i < coordinates.length; i++) {\n      var inner = coordinates[i].slice();\n      if (pointsEqual(inner[0], inner[inner.length - 1]) === false) {\n        inner.push(inner[0]);\n      }\n\n      outer.push(inner);\n    }\n\n    return outer;\n  }\n\n  function pointsEqual(a, b) {\n    for (var i = 0; i < a.length; i++) {\n\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function coordinatesEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    var na = a.slice().sort(compSort);\n    var nb = b.slice().sort(compSort);\n\n    for (var i = 0; i < na.length; i++) {\n      if (na[i].length !== nb[i].length) {\n        return false;\n      }\n      for (var j = 0; j < na.length; j++) {\n        if (na[i][j] !== nb[i][j]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /*\n  Internal: An array of variables that will be excluded form JSON objects.\n  */\n  var excludeFromJSON = [\"length\"];\n\n  /*\n  Internal: Base GeoJSON Primitive\n  */\n  function Primitive(geojson){\n    if(geojson){\n      switch (geojson.type) {\n      case 'Point':\n        return new Point(geojson);\n\n      case 'MultiPoint':\n        return new MultiPoint(geojson);\n\n      case 'LineString':\n        return new LineString(geojson);\n\n      case 'MultiLineString':\n        return new MultiLineString(geojson);\n\n      case 'Polygon':\n        return new Polygon(geojson);\n\n      case 'MultiPolygon':\n        return new MultiPolygon(geojson);\n\n      case 'Feature':\n        return new Feature(geojson);\n\n      case 'FeatureCollection':\n        return new FeatureCollection(geojson);\n\n      case 'GeometryCollection':\n        return new GeometryCollection(geojson);\n\n      default:\n        throw new Error(\"Unknown type: \" + geojson.type);\n      }\n    }\n  }\n\n  Primitive.prototype.toMercator = function(){\n    return toMercator(this);\n  };\n\n  Primitive.prototype.toGeographic = function(){\n    return toGeographic(this);\n  };\n\n  Primitive.prototype.envelope = function(){\n    return calculateEnvelope(this);\n  };\n\n  Primitive.prototype.bbox = function(){\n    return calculateBounds(this);\n  };\n\n  Primitive.prototype.convexHull = function(){\n    var coordinates = [ ], i, j;\n    if (this.type === 'Point') {\n      return null;\n    } else if (this.type === 'LineString' || this.type === 'MultiPoint') {\n      if (this.coordinates && this.coordinates.length >= 3) {\n        coordinates = this.coordinates;\n      } else {\n        return null;\n      }\n    } else if (this.type === 'Polygon' || this.type === 'MultiLineString') {\n      if (this.coordinates && this.coordinates.length > 0) {\n        for (i = 0; i < this.coordinates.length; i++) {\n          coordinates = coordinates.concat(this.coordinates[i]);\n        }\n        if(coordinates.length < 3){\n          return null;\n        }\n      } else {\n        return null;\n      }\n    } else if (this.type === 'MultiPolygon') {\n      if (this.coordinates && this.coordinates.length > 0) {\n        for (i = 0; i < this.coordinates.length; i++) {\n          for (j = 0; j < this.coordinates[i].length; j++) {\n            coordinates = coordinates.concat(this.coordinates[i][j]);\n          }\n        }\n        if(coordinates.length < 3){\n          return null;\n        }\n      } else {\n        return null;\n      }\n    } else if(this.type === \"Feature\"){\n      var primitive = new Primitive(this.geometry);\n      return primitive.convexHull();\n    }\n\n    return new Polygon({\n      type: 'Polygon',\n      coordinates: closedPolygon([convexHull(coordinates)])\n    });\n  };\n\n  Primitive.prototype.toJSON = function(){\n    var obj = {};\n    for (var key in this) {\n      if (this.hasOwnProperty(key) && excludeFromJSON.indexOf(key) === -1) {\n        obj[key] = this[key];\n      }\n    }\n    obj.bbox = calculateBounds(this);\n    return obj;\n  };\n\n  Primitive.prototype.contains = function(primitive){\n    return new Primitive(primitive).within(this);\n  };\n\n  Primitive.prototype.within = function(primitive) {\n    var coordinates, i, j, contains;\n\n    // if we are passed a feature, use the polygon inside instead\n    if (primitive.type === 'Feature') {\n      primitive = primitive.geometry;\n    }\n\n    // point.within(point) :: equality\n    if (primitive.type === \"Point\") {\n      if (this.type === \"Point\") {\n        return pointsEqual(this.coordinates, primitive.coordinates);\n\n      }\n    }\n\n    // point.within(multilinestring)\n    if (primitive.type === \"MultiLineString\") {\n      if (this.type === \"Point\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var linestring = { type: \"LineString\", coordinates: primitive.coordinates[i] };\n\n          if (this.within(linestring)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    // point.within(linestring), point.within(multipoint)\n    if (primitive.type === \"LineString\" || primitive.type === \"MultiPoint\") {\n      if (this.type === \"Point\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          if (this.coordinates.length !== primitive.coordinates[i].length) {\n            return false;\n          }\n\n          if (pointsEqual(this.coordinates, primitive.coordinates[i])) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (primitive.type === \"Polygon\") {\n      // polygon.within(polygon)\n      if (this.type === \"Polygon\") {\n        // check for equal polygons\n        if (primitive.coordinates.length === this.coordinates.length) {\n          for (i = 0; i < this.coordinates.length; i++) {\n            if (coordinatesEqual(this.coordinates[i], primitive.coordinates[i])) {\n              return true;\n            }\n          }\n        }\n\n        if (this.coordinates.length && polygonContainsPoint(primitive.coordinates, this.coordinates[0][0])) {\n          return !arraysIntersectArrays(closedPolygon(this.coordinates), closedPolygon(primitive.coordinates));\n        } else {\n          return false;\n        }\n\n      // point.within(polygon)\n      } else if (this.type === \"Point\") {\n        return polygonContainsPoint(primitive.coordinates, this.coordinates);\n\n      // linestring/multipoint withing polygon\n      } else if (this.type === \"LineString\" || this.type === \"MultiPoint\") {\n        if (!this.coordinates || this.coordinates.length === 0) {\n          return false;\n        }\n\n        for (i = 0; i < this.coordinates.length; i++) {\n          if (polygonContainsPoint(primitive.coordinates, this.coordinates[i]) === false) {\n            return false;\n          }\n        }\n\n        return true;\n\n      // multilinestring.within(polygon)\n      } else if (this.type === \"MultiLineString\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var ls = new LineString(this.coordinates[i]);\n\n          if (ls.within(primitive) === false) {\n            contains++;\n            return false;\n          }\n        }\n\n        return true;\n\n      // multipolygon.within(polygon)\n      } else if (this.type === \"MultiPolygon\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var p1 = new Primitive({ type: \"Polygon\", coordinates: this.coordinates[i] });\n\n          if (p1.within(primitive) === false) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n    }\n\n    if (primitive.type === \"MultiPolygon\") {\n      // point.within(multipolygon)\n      if (this.type === \"Point\") {\n        if (primitive.coordinates.length) {\n          for (i = 0; i < primitive.coordinates.length; i++) {\n            coordinates = primitive.coordinates[i];\n            if (polygonContainsPoint(coordinates, this.coordinates) && arraysIntersectArrays([this.coordinates], primitive.coordinates) === false) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      // polygon.within(multipolygon)\n      } else if (this.type === \"Polygon\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          if (primitive.coordinates[i].length === this.coordinates.length) {\n            for (j = 0; j < this.coordinates.length; j++) {\n              if (coordinatesEqual(this.coordinates[j], primitive.coordinates[i][j])) {\n                return true;\n              }\n            }\n          }\n        }\n\n        if (arraysIntersectArrays(this.coordinates, primitive.coordinates) === false) {\n          if (primitive.coordinates.length) {\n            for (i = 0; i < primitive.coordinates.length; i++) {\n              coordinates = primitive.coordinates[i];\n              if (polygonContainsPoint(coordinates, this.coordinates[0][0]) === false) {\n                contains = false;\n              } else {\n                contains = true;\n              }\n            }\n\n            return contains;\n          }\n        }\n\n      // linestring.within(multipolygon), multipoint.within(multipolygon)\n      } else if (this.type === \"LineString\" || this.type === \"MultiPoint\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var p = { type: \"Polygon\", coordinates: primitive.coordinates[i] };\n\n          if (this.within(p)) {\n            return true;\n          }\n\n          return false;\n        }\n\n      // multilinestring.within(multipolygon)\n      } else if (this.type === \"MultiLineString\") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var lines = new LineString(this.coordinates[i]);\n\n          if (lines.within(primitive) === false) {\n            return false;\n          }\n        }\n\n        return true;\n\n      // multipolygon.within(multipolygon)\n      } else if (this.type === \"MultiPolygon\") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var mpoly = { type: \"Polygon\", coordinates: primitive.coordinates[i] };\n\n          if (this.within(mpoly) === false) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    // default to false\n    return false;\n  };\n\n  Primitive.prototype.intersects = function(primitive) {\n    // if we are passed a feature, use the polygon inside instead\n    if (primitive.type === 'Feature') {\n      primitive = primitive.geometry;\n    }\n\n    var p = new Primitive(primitive);\n    if (this.within(primitive) || p.within(this)) {\n      return true;\n    }\n\n\n    if (this.type !== 'Point' && this.type !== 'MultiPoint' &&\n        primitive.type !== 'Point' && primitive.type !== 'MultiPoint') {\n      return arraysIntersectArrays(this.coordinates, primitive.coordinates);\n    } else if (this.type === 'Feature') {\n      // in the case of a Feature, use the internal primitive for intersection\n      var inner = new Primitive(this.geometry);\n      return inner.intersects(primitive);\n    }\n\n    warn(\"Type \" + this.type + \" to \" + primitive.type + \" intersection is not supported by intersects\");\n    return false;\n  };\n\n\n  /*\n  GeoJSON Point Class\n    new Point();\n    new Point(x,y,z,wtf);\n    new Point([x,y,z,wtf]);\n    new Point([x,y]);\n    new Point({\n      type: \"Point\",\n      coordinates: [x,y]\n    });\n  */\n  function Point(input){\n    var args = Array.prototype.slice.call(arguments);\n\n    if(input && input.type === \"Point\" && input.coordinates){\n      extend(this, input);\n    } else if(input && isArray(input)) {\n      this.coordinates = input;\n    } else if(args.length >= 2) {\n      this.coordinates = args;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.Point\";\n    }\n\n    this.type = \"Point\";\n  }\n\n  Point.prototype = new Primitive();\n  Point.prototype.constructor = Point;\n\n  /*\n  GeoJSON MultiPoint Class\n      new MultiPoint();\n      new MultiPoint([[x,y], [x1,y1]]);\n      new MultiPoint({\n        type: \"MultiPoint\",\n        coordinates: [x,y]\n      });\n  */\n  function MultiPoint(input){\n    if(input && input.type === \"MultiPoint\" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiPoint\";\n    }\n\n    this.type = \"MultiPoint\";\n  }\n\n  MultiPoint.prototype = new Primitive();\n  MultiPoint.prototype.constructor = MultiPoint;\n  MultiPoint.prototype.forEach = function(func){\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates]);\n    }\n    return this;\n  };\n  MultiPoint.prototype.addPoint = function(point){\n    this.coordinates.push(point);\n    return this;\n  };\n  MultiPoint.prototype.insertPoint = function(point, index){\n    this.coordinates.splice(index, 0, point);\n    return this;\n  };\n  MultiPoint.prototype.removePoint = function(remove){\n    if(typeof remove === \"number\"){\n      this.coordinates.splice(remove, 1);\n    } else {\n      this.coordinates.splice(this.coordinates.indexOf(remove), 1);\n    }\n    return this;\n  };\n  MultiPoint.prototype.get = function(i){\n    return new Point(this.coordinates[i]);\n  };\n\n  /*\n  GeoJSON LineString Class\n      new LineString();\n      new LineString([[x,y], [x1,y1]]);\n      new LineString({\n        type: \"LineString\",\n        coordinates: [x,y]\n      });\n  */\n  function LineString(input){\n    if(input && input.type === \"LineString\" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.LineString\";\n    }\n\n    this.type = \"LineString\";\n  }\n\n  LineString.prototype = new Primitive();\n  LineString.prototype.constructor = LineString;\n  LineString.prototype.addVertex = function(point){\n    this.coordinates.push(point);\n    return this;\n  };\n  LineString.prototype.insertVertex = function(point, index){\n    this.coordinates.splice(index, 0, point);\n    return this;\n  };\n  LineString.prototype.removeVertex = function(remove){\n    this.coordinates.splice(remove, 1);\n    return this;\n  };\n\n  /*\n  GeoJSON MultiLineString Class\n      new MultiLineString();\n      new MultiLineString([ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]);\n      new MultiLineString({\n        type: \"MultiLineString\",\n        coordinates: [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]\n      });\n  */\n  function MultiLineString(input){\n    if(input && input.type === \"MultiLineString\" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiLineString\";\n    }\n\n    this.type = \"MultiLineString\";\n  }\n\n  MultiLineString.prototype = new Primitive();\n  MultiLineString.prototype.constructor = MultiLineString;\n  MultiLineString.prototype.forEach = function(func){\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates ]);\n    }\n  };\n  MultiLineString.prototype.get = function(i){\n    return new LineString(this.coordinates[i]);\n  };\n\n  /*\n  GeoJSON Polygon Class\n      new Polygon();\n      new Polygon([ [[x,y], [x1,y1], [x2,y2]] ]);\n      new Polygon({\n        type: \"Polygon\",\n        coordinates: [ [[x,y], [x1,y1], [x2,y2]] ]\n      });\n  */\n  function Polygon(input){\n    if(input && input.type === \"Polygon\" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.Polygon\";\n    }\n\n    this.type = \"Polygon\";\n  }\n\n  Polygon.prototype = new Primitive();\n  Polygon.prototype.constructor = Polygon;\n  Polygon.prototype.addVertex = function(point){\n    this.insertVertex(point, this.coordinates[0].length - 1);\n    return this;\n  };\n  Polygon.prototype.insertVertex = function(point, index){\n    this.coordinates[0].splice(index, 0, point);\n    return this;\n  };\n  Polygon.prototype.removeVertex = function(remove){\n    this.coordinates[0].splice(remove, 1);\n    return this;\n  };\n  Polygon.prototype.close = function() {\n    this.coordinates = closedPolygon(this.coordinates);\n  };\n  Polygon.prototype.hasHoles = function() {\n    return this.coordinates.length > 1;\n  };\n  Polygon.prototype.holes = function() {\n    var holes = [];\n    if (this.hasHoles()) {\n      for (var i = 1; i < this.coordinates.length; i++) {\n        holes.push(new Polygon([this.coordinates[i]]));\n      }\n    }\n    return holes;\n  };\n\n  /*\n  GeoJSON MultiPolygon Class\n      new MultiPolygon();\n      new MultiPolygon([ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]);\n      new MultiPolygon({\n        type: \"MultiPolygon\",\n        coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n      });\n  */\n  function MultiPolygon(input){\n    if(input && input.type === \"MultiPolygon\" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.MultiPolygon\";\n    }\n\n    this.type = \"MultiPolygon\";\n  }\n\n  MultiPolygon.prototype = new Primitive();\n  MultiPolygon.prototype.constructor = MultiPolygon;\n  MultiPolygon.prototype.forEach = function(func){\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates ]);\n    }\n  };\n  MultiPolygon.prototype.get = function(i){\n    return new Polygon(this.coordinates[i]);\n  };\n  MultiPolygon.prototype.close = function(){\n    var outer = [];\n    this.forEach(function(polygon){\n      outer.push(closedPolygon(polygon));\n    });\n    this.coordinates = outer;\n    return this;\n  };\n\n  /*\n  GeoJSON Feature Class\n      new Feature();\n      new Feature({\n        type: \"Feature\",\n        geometry: {\n          type: \"Polygon\",\n          coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n        }\n      });\n      new Feature({\n        type: \"Polygon\",\n        coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n      });\n  */\n  function Feature(input){\n    if(input && input.type === \"Feature\"){\n      extend(this, input);\n    } else if(input && input.type && input.coordinates) {\n      this.geometry = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.Feature\";\n    }\n\n    this.type = \"Feature\";\n  }\n\n  Feature.prototype = new Primitive();\n  Feature.prototype.constructor = Feature;\n\n  /*\n  GeoJSON FeatureCollection Class\n      new FeatureCollection();\n      new FeatureCollection([feature, feature1]);\n      new FeatureCollection({\n        type: \"FeatureCollection\",\n        coordinates: [feature, feature1]\n      });\n  */\n  function FeatureCollection(input){\n    if(input && input.type === \"FeatureCollection\" && input.features){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.features = input;\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.FeatureCollection\";\n    }\n\n    this.type = \"FeatureCollection\";\n  }\n\n  FeatureCollection.prototype = new Primitive();\n  FeatureCollection.prototype.constructor = FeatureCollection;\n  FeatureCollection.prototype.forEach = function(func){\n    for (var i = 0; i < this.features.length; i++) {\n      func.apply(this, [this.features[i], i, this.features]);\n    }\n  };\n  FeatureCollection.prototype.get = function(id){\n    var found;\n    this.forEach(function(feature){\n      if(feature.id === id){\n        found = feature;\n      }\n    });\n    return new Feature(found);\n  };\n\n  /*\n  GeoJSON GeometryCollection Class\n      new GeometryCollection();\n      new GeometryCollection([geometry, geometry1]);\n      new GeometryCollection({\n        type: \"GeometryCollection\",\n        coordinates: [geometry, geometry1]\n      });\n  */\n  function GeometryCollection(input){\n    if(input && input.type === \"GeometryCollection\" && input.geometries){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.geometries = input;\n    } else if(input.coordinates && input.type){\n      this.type = \"GeometryCollection\";\n      this.geometries = [input];\n    } else {\n      throw \"Terraformer: invalid input for Terraformer.GeometryCollection\";\n    }\n\n    this.type = \"GeometryCollection\";\n  }\n\n  GeometryCollection.prototype = new Primitive();\n  GeometryCollection.prototype.constructor = GeometryCollection;\n  GeometryCollection.prototype.forEach = function(func){\n    for (var i = 0; i < this.geometries.length; i++) {\n      func.apply(this, [this.geometries[i], i, this.geometries]);\n    }\n  };\n  GeometryCollection.prototype.get = function(i){\n    return new Primitive(this.geometries[i]);\n  };\n\n  function createCircle(center, radius, interpolate){\n    var mercatorPosition = positionToMercator(center);\n    var steps = interpolate || 64;\n    var polygon = {\n      type: \"Polygon\",\n      coordinates: [[]]\n    };\n    for(var i=1; i<=steps; i++) {\n      var radians = i * (360/steps) * Math.PI / 180;\n      polygon.coordinates[0].push([mercatorPosition[0] + radius * Math.cos(radians), mercatorPosition[1] + radius * Math.sin(radians)]);\n    }\n    polygon.coordinates = closedPolygon(polygon.coordinates);\n\n    return toGeographic(polygon);\n  }\n\n  function Circle (center, radius, interpolate) {\n    var steps = interpolate || 64;\n    var rad = radius || 250;\n\n    if(!center || center.length < 2 || !rad || !steps) {\n      throw new Error(\"Terraformer: missing parameter for Terraformer.Circle\");\n    }\n\n    extend(this, new Feature({\n      type: \"Feature\",\n      geometry: createCircle(center, rad, steps),\n      properties: {\n        radius: rad,\n        center: center,\n        steps: steps\n      }\n    }));\n  }\n\n  Circle.prototype = new Primitive();\n  Circle.prototype.constructor = Circle;\n  Circle.prototype.recalculate = function(){\n    this.geometry = createCircle(this.properties.center, this.properties.radius, this.properties.steps);\n    return this;\n  };\n  Circle.prototype.center = function(coordinates){\n    if(coordinates){\n      this.properties.center = coordinates;\n      this.recalculate();\n    }\n    return this.properties.center;\n  };\n  Circle.prototype.radius = function(radius){\n    if(radius){\n      this.properties.radius = radius;\n      this.recalculate();\n    }\n    return this.properties.radius;\n  };\n  Circle.prototype.steps = function(steps){\n    if(steps){\n      this.properties.steps = steps;\n      this.recalculate();\n    }\n    return this.properties.steps;\n  };\n\n  Circle.prototype.toJSON = function() {\n    var output = Primitive.prototype.toJSON.call(this);\n    return output;\n  };\n\n  exports.Primitive = Primitive;\n  exports.Point = Point;\n  exports.MultiPoint = MultiPoint;\n  exports.LineString = LineString;\n  exports.MultiLineString = MultiLineString;\n  exports.Polygon = Polygon;\n  exports.MultiPolygon = MultiPolygon;\n  exports.Feature = Feature;\n  exports.FeatureCollection = FeatureCollection;\n  exports.GeometryCollection = GeometryCollection;\n  exports.Circle = Circle;\n\n  exports.toMercator = toMercator;\n  exports.toGeographic = toGeographic;\n\n  exports.Tools = {};\n  exports.Tools.positionToMercator = positionToMercator;\n  exports.Tools.positionToGeographic = positionToGeographic;\n  exports.Tools.applyConverter = applyConverter;\n  exports.Tools.toMercator = toMercator;\n  exports.Tools.toGeographic = toGeographic;\n  exports.Tools.createCircle = createCircle;\n\n  exports.Tools.calculateBounds = calculateBounds;\n  exports.Tools.calculateEnvelope = calculateEnvelope;\n\n  exports.Tools.coordinatesContainPoint = coordinatesContainPoint;\n  exports.Tools.polygonContainsPoint = polygonContainsPoint;\n  exports.Tools.arraysIntersectArrays = arraysIntersectArrays;\n  exports.Tools.coordinatesContainPoint = coordinatesContainPoint;\n  exports.Tools.coordinatesEqual = coordinatesEqual;\n  exports.Tools.convexHull = convexHull;\n  exports.Tools.isConvex = isConvex;\n\n  exports.MercatorCRS = MercatorCRS;\n  exports.GeographicCRS = GeographicCRS;\n\n  return exports;\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}