{"ast":null,"code":"import { isArray, formatNum } from '../core/Util';\n/*\r\n * @class Point\r\n * @aka L.Point\r\n *\r\n * Represents a point with `x` and `y` coordinates in pixels.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * var point = L.point(200, 300);\r\n * ```\r\n *\r\n * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n *\r\n * ```js\r\n * map.panBy([200, 300]);\r\n * map.panBy(L.point(200, 300));\r\n * ```\r\n *\r\n * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n * which means new classes can't inherit from it, and new methods\r\n * can't be added to it with the `include` function.\r\n */\n\nexport function Point(x, y, round) {\n  // @property x: Number; The `x` coordinate of the point\n  this.x = round ? Math.round(x) : x; // @property y: Number; The `y` coordinate of the point\n\n  this.y = round ? Math.round(y) : y;\n}\n\nvar trunc = Math.trunc || function (v) {\n  return v > 0 ? Math.floor(v) : Math.ceil(v);\n};\n\nPoint.prototype = {\n  // @method clone(): Point\n  // Returns a copy of the current point.\n  clone: function () {\n    return new Point(this.x, this.y);\n  },\n  // @method add(otherPoint: Point): Point\n  // Returns the result of addition of the current and the given points.\n  add: function (point) {\n    // non-destructive, returns a new point\n    return this.clone()._add(toPoint(point));\n  },\n  _add: function (point) {\n    // destructive, used directly for performance in situations where it's safe to modify existing point\n    this.x += point.x;\n    this.y += point.y;\n    return this;\n  },\n  // @method subtract(otherPoint: Point): Point\n  // Returns the result of subtraction of the given point from the current.\n  subtract: function (point) {\n    return this.clone()._subtract(toPoint(point));\n  },\n  _subtract: function (point) {\n    this.x -= point.x;\n    this.y -= point.y;\n    return this;\n  },\n  // @method divideBy(num: Number): Point\n  // Returns the result of division of the current point by the given number.\n  divideBy: function (num) {\n    return this.clone()._divideBy(num);\n  },\n  _divideBy: function (num) {\n    this.x /= num;\n    this.y /= num;\n    return this;\n  },\n  // @method multiplyBy(num: Number): Point\n  // Returns the result of multiplication of the current point by the given number.\n  multiplyBy: function (num) {\n    return this.clone()._multiplyBy(num);\n  },\n  _multiplyBy: function (num) {\n    this.x *= num;\n    this.y *= num;\n    return this;\n  },\n  // @method scaleBy(scale: Point): Point\n  // Multiply each coordinate of the current point by each coordinate of\n  // `scale`. In linear algebra terms, multiply the point by the\n  // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\n  // defined by `scale`.\n  scaleBy: function (point) {\n    return new Point(this.x * point.x, this.y * point.y);\n  },\n  // @method unscaleBy(scale: Point): Point\n  // Inverse of `scaleBy`. Divide each coordinate of the current point by\n  // each coordinate of `scale`.\n  unscaleBy: function (point) {\n    return new Point(this.x / point.x, this.y / point.y);\n  },\n  // @method round(): Point\n  // Returns a copy of the current point with rounded coordinates.\n  round: function () {\n    return this.clone()._round();\n  },\n  _round: function () {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  },\n  // @method floor(): Point\n  // Returns a copy of the current point with floored coordinates (rounded down).\n  floor: function () {\n    return this.clone()._floor();\n  },\n  _floor: function () {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    return this;\n  },\n  // @method ceil(): Point\n  // Returns a copy of the current point with ceiled coordinates (rounded up).\n  ceil: function () {\n    return this.clone()._ceil();\n  },\n  _ceil: function () {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    return this;\n  },\n  // @method trunc(): Point\n  // Returns a copy of the current point with truncated coordinates (rounded towards zero).\n  trunc: function () {\n    return this.clone()._trunc();\n  },\n  _trunc: function () {\n    this.x = trunc(this.x);\n    this.y = trunc(this.y);\n    return this;\n  },\n  // @method distanceTo(otherPoint: Point): Number\n  // Returns the cartesian distance between the current and the given points.\n  distanceTo: function (point) {\n    point = toPoint(point);\n    var x = point.x - this.x,\n        y = point.y - this.y;\n    return Math.sqrt(x * x + y * y);\n  },\n  // @method equals(otherPoint: Point): Boolean\n  // Returns `true` if the given point has the same coordinates.\n  equals: function (point) {\n    point = toPoint(point);\n    return point.x === this.x && point.y === this.y;\n  },\n  // @method contains(otherPoint: Point): Boolean\n  // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\n  contains: function (point) {\n    point = toPoint(point);\n    return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n  },\n  // @method toString(): String\n  // Returns a string representation of the point for debugging purposes.\n  toString: function () {\n    return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';\n  }\n}; // @factory L.point(x: Number, y: Number, round?: Boolean)\n// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\n// @alternative\n// @factory L.point(coords: Number[])\n// Expects an array of the form `[x, y]` instead.\n// @alternative\n// @factory L.point(coords: Object)\n// Expects a plain object of the form `{x: Number, y: Number}` instead.\n\nexport function toPoint(x, y, round) {\n  if (x instanceof Point) {\n    return x;\n  }\n\n  if (isArray(x)) {\n    return new Point(x[0], x[1]);\n  }\n\n  if (x === undefined || x === null) {\n    return x;\n  }\n\n  if (typeof x === 'object' && 'x' in x && 'y' in x) {\n    return new Point(x.x, x.y);\n  }\n\n  return new Point(x, y, round);\n}","map":{"version":3,"names":["isArray","formatNum","Point","x","y","round","Math","trunc","v","floor","ceil","prototype","clone","add","point","_add","toPoint","subtract","_subtract","divideBy","num","_divideBy","multiplyBy","_multiplyBy","scaleBy","unscaleBy","_round","_floor","_ceil","_trunc","distanceTo","sqrt","equals","contains","abs","toString","undefined"],"sources":["/Users/romanradionov/PycharmProjects/reactleafletgeodjango/my-app/node_modules/leaflet/src/geometry/Point.js"],"sourcesContent":["import {isArray, formatNum} from '../core/Util';\r\n\r\n/*\r\n * @class Point\r\n * @aka L.Point\r\n *\r\n * Represents a point with `x` and `y` coordinates in pixels.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * var point = L.point(200, 300);\r\n * ```\r\n *\r\n * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n *\r\n * ```js\r\n * map.panBy([200, 300]);\r\n * map.panBy(L.point(200, 300));\r\n * ```\r\n *\r\n * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n * which means new classes can't inherit from it, and new methods\r\n * can't be added to it with the `include` function.\r\n */\r\n\r\nexport function Point(x, y, round) {\r\n\t// @property x: Number; The `x` coordinate of the point\r\n\tthis.x = (round ? Math.round(x) : x);\r\n\t// @property y: Number; The `y` coordinate of the point\r\n\tthis.y = (round ? Math.round(y) : y);\r\n}\r\n\r\nvar trunc = Math.trunc || function (v) {\r\n\treturn v > 0 ? Math.floor(v) : Math.ceil(v);\r\n};\r\n\r\nPoint.prototype = {\r\n\r\n\t// @method clone(): Point\r\n\t// Returns a copy of the current point.\r\n\tclone: function () {\r\n\t\treturn new Point(this.x, this.y);\r\n\t},\r\n\r\n\t// @method add(otherPoint: Point): Point\r\n\t// Returns the result of addition of the current and the given points.\r\n\tadd: function (point) {\r\n\t\t// non-destructive, returns a new point\r\n\t\treturn this.clone()._add(toPoint(point));\r\n\t},\r\n\r\n\t_add: function (point) {\r\n\t\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n\t\tthis.x += point.x;\r\n\t\tthis.y += point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method subtract(otherPoint: Point): Point\r\n\t// Returns the result of subtraction of the given point from the current.\r\n\tsubtract: function (point) {\r\n\t\treturn this.clone()._subtract(toPoint(point));\r\n\t},\r\n\r\n\t_subtract: function (point) {\r\n\t\tthis.x -= point.x;\r\n\t\tthis.y -= point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method divideBy(num: Number): Point\r\n\t// Returns the result of division of the current point by the given number.\r\n\tdivideBy: function (num) {\r\n\t\treturn this.clone()._divideBy(num);\r\n\t},\r\n\r\n\t_divideBy: function (num) {\r\n\t\tthis.x /= num;\r\n\t\tthis.y /= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method multiplyBy(num: Number): Point\r\n\t// Returns the result of multiplication of the current point by the given number.\r\n\tmultiplyBy: function (num) {\r\n\t\treturn this.clone()._multiplyBy(num);\r\n\t},\r\n\r\n\t_multiplyBy: function (num) {\r\n\t\tthis.x *= num;\r\n\t\tthis.y *= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method scaleBy(scale: Point): Point\r\n\t// Multiply each coordinate of the current point by each coordinate of\r\n\t// `scale`. In linear algebra terms, multiply the point by the\r\n\t// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\r\n\t// defined by `scale`.\r\n\tscaleBy: function (point) {\r\n\t\treturn new Point(this.x * point.x, this.y * point.y);\r\n\t},\r\n\r\n\t// @method unscaleBy(scale: Point): Point\r\n\t// Inverse of `scaleBy`. Divide each coordinate of the current point by\r\n\t// each coordinate of `scale`.\r\n\tunscaleBy: function (point) {\r\n\t\treturn new Point(this.x / point.x, this.y / point.y);\r\n\t},\r\n\r\n\t// @method round(): Point\r\n\t// Returns a copy of the current point with rounded coordinates.\r\n\tround: function () {\r\n\t\treturn this.clone()._round();\r\n\t},\r\n\r\n\t_round: function () {\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method floor(): Point\r\n\t// Returns a copy of the current point with floored coordinates (rounded down).\r\n\tfloor: function () {\r\n\t\treturn this.clone()._floor();\r\n\t},\r\n\r\n\t_floor: function () {\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method ceil(): Point\r\n\t// Returns a copy of the current point with ceiled coordinates (rounded up).\r\n\tceil: function () {\r\n\t\treturn this.clone()._ceil();\r\n\t},\r\n\r\n\t_ceil: function () {\r\n\t\tthis.x = Math.ceil(this.x);\r\n\t\tthis.y = Math.ceil(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method trunc(): Point\r\n\t// Returns a copy of the current point with truncated coordinates (rounded towards zero).\r\n\ttrunc: function () {\r\n\t\treturn this.clone()._trunc();\r\n\t},\r\n\r\n\t_trunc: function () {\r\n\t\tthis.x = trunc(this.x);\r\n\t\tthis.y = trunc(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method distanceTo(otherPoint: Point): Number\r\n\t// Returns the cartesian distance between the current and the given points.\r\n\tdistanceTo: function (point) {\r\n\t\tpoint = toPoint(point);\r\n\r\n\t\tvar x = point.x - this.x,\r\n\t\t    y = point.y - this.y;\r\n\r\n\t\treturn Math.sqrt(x * x + y * y);\r\n\t},\r\n\r\n\t// @method equals(otherPoint: Point): Boolean\r\n\t// Returns `true` if the given point has the same coordinates.\r\n\tequals: function (point) {\r\n\t\tpoint = toPoint(point);\r\n\r\n\t\treturn point.x === this.x &&\r\n\t\t       point.y === this.y;\r\n\t},\r\n\r\n\t// @method contains(otherPoint: Point): Boolean\r\n\t// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\r\n\tcontains: function (point) {\r\n\t\tpoint = toPoint(point);\r\n\r\n\t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n\t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n\t},\r\n\r\n\t// @method toString(): String\r\n\t// Returns a string representation of the point for debugging purposes.\r\n\ttoString: function () {\r\n\t\treturn 'Point(' +\r\n\t\t        formatNum(this.x) + ', ' +\r\n\t\t        formatNum(this.y) + ')';\r\n\t}\r\n};\r\n\r\n// @factory L.point(x: Number, y: Number, round?: Boolean)\r\n// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\r\n\r\n// @alternative\r\n// @factory L.point(coords: Number[])\r\n// Expects an array of the form `[x, y]` instead.\r\n\r\n// @alternative\r\n// @factory L.point(coords: Object)\r\n// Expects a plain object of the form `{x: Number, y: Number}` instead.\r\nexport function toPoint(x, y, round) {\r\n\tif (x instanceof Point) {\r\n\t\treturn x;\r\n\t}\r\n\tif (isArray(x)) {\r\n\t\treturn new Point(x[0], x[1]);\r\n\t}\r\n\tif (x === undefined || x === null) {\r\n\t\treturn x;\r\n\t}\r\n\tif (typeof x === 'object' && 'x' in x && 'y' in x) {\r\n\t\treturn new Point(x.x, x.y);\r\n\t}\r\n\treturn new Point(x, y, round);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}