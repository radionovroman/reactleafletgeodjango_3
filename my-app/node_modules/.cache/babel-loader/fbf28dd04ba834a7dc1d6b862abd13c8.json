{"ast":null,"code":"import adjust_lon from '../common/adjust_lon';\nexport function init() {}\nimport { EPSLN } from '../constants/values';\n/* Mollweide forward equations--mapping lat,long to x,y\n    ----------------------------------------------------*/\n\nexport function forward(p) {\n  /* Forward equations\n      -----------------*/\n  var lon = p.x;\n  var lat = p.y;\n  var delta_lon = adjust_lon(lon - this.long0);\n  var theta = lat;\n  var con = Math.PI * Math.sin(lat);\n  /* Iterate using the Newton-Raphson method to find theta\n      -----------------------------------------------------*/\n\n  while (true) {\n    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n    theta += delta_theta;\n\n    if (Math.abs(delta_theta) < EPSLN) {\n      break;\n    }\n  }\n\n  theta /= 2;\n  /* If the latitude is 90 deg, force the x coordinate to be \"0 + false easting\"\n       this is done here because of precision problems with \"cos(theta)\"\n       --------------------------------------------------------------------------*/\n\n  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {\n    delta_lon = 0;\n  }\n\n  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n  p.x = x;\n  p.y = y;\n  return p;\n}\nexport function inverse(p) {\n  var theta;\n  var arg;\n  /* Inverse equations\n      -----------------*/\n\n  p.x -= this.x0;\n  p.y -= this.y0;\n  arg = p.y / (1.4142135623731 * this.a);\n  /* Because of division by zero problems, 'arg' can not be 1.  Therefore\n       a number very close to one is used instead.\n       -------------------------------------------------------------------*/\n\n  if (Math.abs(arg) > 0.999999999999) {\n    arg = 0.999999999999;\n  }\n\n  theta = Math.asin(arg);\n  var lon = adjust_lon(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));\n\n  if (lon < -Math.PI) {\n    lon = -Math.PI;\n  }\n\n  if (lon > Math.PI) {\n    lon = Math.PI;\n  }\n\n  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n\n  if (Math.abs(arg) > 1) {\n    arg = 1;\n  }\n\n  var lat = Math.asin(arg);\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\nexport var names = [\"Mollweide\", \"moll\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};","map":{"version":3,"names":["adjust_lon","init","EPSLN","forward","p","lon","x","lat","y","delta_lon","long0","theta","con","Math","PI","sin","delta_theta","cos","abs","a","x0","y0","inverse","arg","asin","names"],"sources":["/Users/romanradionov/PycharmProjects/reactleafletgeodjango/my-app/node_modules/proj4/lib/projections/moll.js"],"sourcesContent":["import adjust_lon from '../common/adjust_lon';\nexport function init() {}\nimport {EPSLN} from '../constants/values';\n/* Mollweide forward equations--mapping lat,long to x,y\n    ----------------------------------------------------*/\nexport function forward(p) {\n\n  /* Forward equations\n      -----------------*/\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lon = adjust_lon(lon - this.long0);\n  var theta = lat;\n  var con = Math.PI * Math.sin(lat);\n\n  /* Iterate using the Newton-Raphson method to find theta\n      -----------------------------------------------------*/\n  while (true) {\n    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n    theta += delta_theta;\n    if (Math.abs(delta_theta) < EPSLN) {\n      break;\n    }\n  }\n  theta /= 2;\n\n  /* If the latitude is 90 deg, force the x coordinate to be \"0 + false easting\"\n       this is done here because of precision problems with \"cos(theta)\"\n       --------------------------------------------------------------------------*/\n  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {\n    delta_lon = 0;\n  }\n  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n\n  p.x = x;\n  p.y = y;\n  return p;\n}\n\nexport function inverse(p) {\n  var theta;\n  var arg;\n\n  /* Inverse equations\n      -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  arg = p.y / (1.4142135623731 * this.a);\n\n  /* Because of division by zero problems, 'arg' can not be 1.  Therefore\n       a number very close to one is used instead.\n       -------------------------------------------------------------------*/\n  if (Math.abs(arg) > 0.999999999999) {\n    arg = 0.999999999999;\n  }\n  theta = Math.asin(arg);\n  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));\n  if (lon < (-Math.PI)) {\n    lon = -Math.PI;\n  }\n  if (lon > Math.PI) {\n    lon = Math.PI;\n  }\n  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n  if (Math.abs(arg) > 1) {\n    arg = 1;\n  }\n  var lat = Math.asin(arg);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n}\n\nexport var names = [\"Mollweide\", \"moll\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}