{"ast":null,"code":"import { PJD_3PARAM, PJD_7PARAM, PJD_GRIDSHIFT, PJD_NODATUM, R2D, SRS_WGS84_ESQUARED, SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR } from './constants/values';\nimport { geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums } from './datumUtils';\nimport adjust_lon from \"./common/adjust_lon\";\n\nfunction checkParams(type) {\n  return type === PJD_3PARAM || type === PJD_7PARAM;\n}\n\nexport default function (source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  } // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n\n\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  } // If this datum requires grid shifts, then apply it to geodetic coordinates.\n\n\n  var source_a = source.a;\n  var source_es = source.es;\n\n  if (source.datum_type === PJD_GRIDSHIFT) {\n    var gridShiftCode = applyGridShift(source, false, point);\n\n    if (gridShiftCode !== 0) {\n      return undefined;\n    }\n\n    source_a = SRS_WGS84_SEMIMAJOR;\n    source_es = SRS_WGS84_ESQUARED;\n  }\n\n  var dest_a = dest.a;\n  var dest_b = dest.b;\n  var dest_es = dest.es;\n\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    dest_a = SRS_WGS84_SEMIMAJOR;\n    dest_b = SRS_WGS84_SEMIMINOR;\n    dest_es = SRS_WGS84_ESQUARED;\n  } // Do we need to go through geocentric coordinates?\n\n\n  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {\n    return point;\n  } // Convert to geocentric coordinates.\n\n\n  point = geodeticToGeocentric(point, source_es, source_a); // Convert between datums\n\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n\n  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);\n\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    var destGridShiftResult = applyGridShift(dest, true, point);\n\n    if (destGridShiftResult !== 0) {\n      return undefined;\n    }\n  }\n\n  return point;\n}\nexport function applyGridShift(source, inverse, point) {\n  if (source.grids === null || source.grids.length === 0) {\n    console.log('Grid shift grids not found');\n    return -1;\n  }\n\n  var input = {\n    x: -point.x,\n    y: point.y\n  };\n  var output = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n  var onlyMandatoryGrids = false;\n  var attemptedGrids = [];\n\n  for (var i = 0; i < source.grids.length; i++) {\n    var grid = source.grids[i];\n    attemptedGrids.push(grid.name);\n\n    if (grid.isNull) {\n      output = input;\n      break;\n    }\n\n    onlyMandatoryGrids = grid.mandatory;\n\n    if (grid.grid === null) {\n      if (grid.mandatory) {\n        console.log(\"Unable to find mandatory grid '\" + grid.name + \"'\");\n        return -1;\n      }\n\n      continue;\n    }\n\n    var subgrid = grid.grid.subgrids[0]; // skip tables that don't match our point at all\n\n    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;\n    var minX = subgrid.ll[0] - epsilon;\n    var minY = subgrid.ll[1] - epsilon;\n    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;\n    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;\n\n    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {\n      continue;\n    }\n\n    output = applySubgridShift(input, inverse, subgrid);\n\n    if (!isNaN(output.x)) {\n      break;\n    }\n  }\n\n  if (isNaN(output.x)) {\n    console.log(\"Failed to find a grid shift table for location '\" + -input.x * R2D + \" \" + input.y * R2D + \" tried: '\" + attemptedGrids + \"'\");\n    return -1;\n  }\n\n  point.x = -output.x;\n  point.y = output.y;\n  return 0;\n}\n\nfunction applySubgridShift(pin, inverse, ct) {\n  var val = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n\n  if (isNaN(pin.x)) {\n    return val;\n  }\n\n  var tb = {\n    x: pin.x,\n    y: pin.y\n  };\n  tb.x -= ct.ll[0];\n  tb.y -= ct.ll[1];\n  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;\n  var t = nadInterpolate(tb, ct);\n\n  if (inverse) {\n    if (isNaN(t.x)) {\n      return val;\n    }\n\n    t.x = tb.x - t.x;\n    t.y = tb.y - t.y;\n    var i = 9,\n        tol = 1e-12;\n    var dif, del;\n\n    do {\n      del = nadInterpolate(t, ct);\n\n      if (isNaN(del.x)) {\n        console.log(\"Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.\");\n        break;\n      }\n\n      dif = {\n        x: tb.x - (del.x + t.x),\n        y: tb.y - (del.y + t.y)\n      };\n      t.x += dif.x;\n      t.y += dif.y;\n    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);\n\n    if (i < 0) {\n      console.log(\"Inverse grid shift iterator failed to converge.\");\n      return val;\n    }\n\n    val.x = adjust_lon(t.x + ct.ll[0]);\n    val.y = t.y + ct.ll[1];\n  } else {\n    if (!isNaN(t.x)) {\n      val.x = pin.x + t.x;\n      val.y = pin.y + t.y;\n    }\n  }\n\n  return val;\n}\n\nfunction nadInterpolate(pin, ct) {\n  var t = {\n    x: pin.x / ct.del[0],\n    y: pin.y / ct.del[1]\n  };\n  var indx = {\n    x: Math.floor(t.x),\n    y: Math.floor(t.y)\n  };\n  var frct = {\n    x: t.x - 1.0 * indx.x,\n    y: t.y - 1.0 * indx.y\n  };\n  var val = {\n    x: Number.NaN,\n    y: Number.NaN\n  };\n  var inx;\n\n  if (indx.x < 0 || indx.x >= ct.lim[0]) {\n    return val;\n  }\n\n  if (indx.y < 0 || indx.y >= ct.lim[1]) {\n    return val;\n  }\n\n  inx = indx.y * ct.lim[0] + indx.x;\n  var f00 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx++;\n  var f10 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx += ct.lim[0];\n  var f11 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  inx--;\n  var f01 = {\n    x: ct.cvs[inx][0],\n    y: ct.cvs[inx][1]\n  };\n  var m11 = frct.x * frct.y,\n      m10 = frct.x * (1.0 - frct.y),\n      m00 = (1.0 - frct.x) * (1.0 - frct.y),\n      m01 = (1.0 - frct.x) * frct.y;\n  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;\n  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;\n  return val;\n}","map":{"version":3,"names":["PJD_3PARAM","PJD_7PARAM","PJD_GRIDSHIFT","PJD_NODATUM","R2D","SRS_WGS84_ESQUARED","SRS_WGS84_SEMIMAJOR","SRS_WGS84_SEMIMINOR","geodeticToGeocentric","geocentricToGeodetic","geocentricToWgs84","geocentricFromWgs84","compareDatums","adjust_lon","checkParams","type","source","dest","point","datum_type","source_a","a","source_es","es","gridShiftCode","applyGridShift","undefined","dest_a","dest_b","b","dest_es","datum_params","destGridShiftResult","inverse","grids","length","console","log","input","x","y","output","Number","NaN","onlyMandatoryGrids","attemptedGrids","i","grid","push","name","isNull","mandatory","subgrid","subgrids","epsilon","Math","abs","del","minX","ll","minY","maxX","lim","maxY","applySubgridShift","isNaN","pin","ct","val","tb","PI","t","nadInterpolate","tol","dif","indx","floor","frct","inx","f00","cvs","f10","f11","f01","m11","m10","m00","m01"],"sources":["/Users/romanradionov/PycharmProjects/reactleafletgeodjango/my-app/node_modules/proj4/lib/datum_transform.js"],"sourcesContent":["import {\n  PJD_3PARAM,\n  PJD_7PARAM,\n  PJD_GRIDSHIFT,\n  PJD_NODATUM,\n  R2D,\n  SRS_WGS84_ESQUARED,\n  SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR\n} from './constants/values';\n\nimport {geodeticToGeocentric, geocentricToGeodetic, geocentricToWgs84, geocentricFromWgs84, compareDatums} from './datumUtils';\nimport adjust_lon from \"./common/adjust_lon\";\nfunction checkParams(type) {\n  return (type === PJD_3PARAM || type === PJD_7PARAM);\n}\n\nexport default function(source, dest, point) {\n  // Short cut if the datums are identical.\n  if (compareDatums(source, dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n  var source_a = source.a;\n  var source_es = source.es;\n  if (source.datum_type === PJD_GRIDSHIFT) {\n    var gridShiftCode = applyGridShift(source, false, point);\n    if (gridShiftCode !== 0) {\n      return undefined;\n    }\n    source_a = SRS_WGS84_SEMIMAJOR;\n    source_es = SRS_WGS84_ESQUARED;\n  }\n\n  var dest_a = dest.a;\n  var dest_b = dest.b;\n  var dest_es = dest.es;\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    dest_a = SRS_WGS84_SEMIMAJOR;\n    dest_b = SRS_WGS84_SEMIMINOR;\n    dest_es = SRS_WGS84_ESQUARED;\n  }\n\n  // Do we need to go through geocentric coordinates?\n  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {\n    return point;\n  }\n\n  // Convert to geocentric coordinates.\n  point = geodeticToGeocentric(point, source_es, source_a);\n  // Convert between datums\n  if (checkParams(source.datum_type)) {\n    point = geocentricToWgs84(point, source.datum_type, source.datum_params);\n  }\n  if (checkParams(dest.datum_type)) {\n    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);\n  }\n  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);\n\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    var destGridShiftResult = applyGridShift(dest, true, point);\n    if (destGridShiftResult !== 0) {\n      return undefined;\n    }\n  }\n\n  return point;\n}\n\nexport function applyGridShift(source, inverse, point) {\n  if (source.grids === null || source.grids.length === 0) {\n    console.log('Grid shift grids not found');\n    return -1;\n  }\n  var input = {x: -point.x, y: point.y};\n  var output = {x: Number.NaN, y: Number.NaN};\n  var onlyMandatoryGrids = false;\n  var attemptedGrids = [];\n  for (var i = 0; i < source.grids.length; i++) {\n    var grid = source.grids[i];\n    attemptedGrids.push(grid.name);\n    if (grid.isNull) {\n      output = input;\n      break;\n    }\n    onlyMandatoryGrids = grid.mandatory;\n    if (grid.grid === null) {\n      if (grid.mandatory) {\n        console.log(\"Unable to find mandatory grid '\" + grid.name + \"'\");\n        return -1;\n      }\n      continue;\n    }\n    var subgrid = grid.grid.subgrids[0];\n    // skip tables that don't match our point at all\n    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;\n    var minX = subgrid.ll[0] - epsilon;\n    var minY = subgrid.ll[1] - epsilon;\n    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;\n    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;\n    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {\n      continue;\n    }\n    output = applySubgridShift(input, inverse, subgrid);\n    if (!isNaN(output.x)) {\n      break;\n    }\n  }\n  if (isNaN(output.x)) {\n    console.log(\"Failed to find a grid shift table for location '\"+\n      -input.x * R2D + \" \" + input.y * R2D + \" tried: '\" + attemptedGrids + \"'\");\n    return -1;\n  }\n  point.x = -output.x;\n  point.y = output.y;\n  return 0;\n}\n\nfunction applySubgridShift(pin, inverse, ct) {\n  var val = {x: Number.NaN, y: Number.NaN};\n  if (isNaN(pin.x)) { return val; }\n  var tb = {x: pin.x, y: pin.y};\n  tb.x -= ct.ll[0];\n  tb.y -= ct.ll[1];\n  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;\n  var t = nadInterpolate(tb, ct);\n  if (inverse) {\n    if (isNaN(t.x)) {\n      return val;\n    }\n    t.x = tb.x - t.x;\n    t.y = tb.y - t.y;\n    var i = 9, tol = 1e-12;\n    var dif, del;\n    do {\n      del = nadInterpolate(t, ct);\n      if (isNaN(del.x)) {\n        console.log(\"Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.\");\n        break;\n      }\n      dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};\n      t.x += dif.x;\n      t.y += dif.y;\n    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);\n    if (i < 0) {\n      console.log(\"Inverse grid shift iterator failed to converge.\");\n      return val;\n    }\n    val.x = adjust_lon(t.x + ct.ll[0]);\n    val.y = t.y + ct.ll[1];\n  } else {\n    if (!isNaN(t.x)) {\n      val.x = pin.x + t.x;\n      val.y = pin.y + t.y;\n    }\n  }\n  return val;\n}\n\nfunction nadInterpolate(pin, ct) {\n  var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};\n  var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};\n  var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};\n  var val= {x: Number.NaN, y: Number.NaN};\n  var inx;\n  if (indx.x < 0 || indx.x >= ct.lim[0]) {\n    return val;\n  }\n  if (indx.y < 0 || indx.y >= ct.lim[1]) {\n    return val;\n  }\n  inx = (indx.y * ct.lim[0]) + indx.x;\n  var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx++;\n  var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx += ct.lim[0];\n  var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  inx--;\n  var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};\n  var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),\n    m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;\n  val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);\n  val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);\n  return val;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}