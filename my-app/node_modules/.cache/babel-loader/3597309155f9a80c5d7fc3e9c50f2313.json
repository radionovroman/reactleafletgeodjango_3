{"ast":null,"code":"// QSC projection rewritten from the original PROJ4\n// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c\nimport { EPSLN, TWO_PI, SPI, HALF_PI, FORTPI } from '../constants/values';\n/* constants */\n\nvar FACE_ENUM = {\n  FRONT: 1,\n  RIGHT: 2,\n  BACK: 3,\n  LEFT: 4,\n  TOP: 5,\n  BOTTOM: 6\n};\nvar AREA_ENUM = {\n  AREA_0: 1,\n  AREA_1: 2,\n  AREA_2: 3,\n  AREA_3: 4\n};\nexport function init() {\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Quadrilateralized Spherical Cube\";\n  /* Determine the cube face from the center of projection. */\n\n  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {\n    this.face = FACE_ENUM.TOP;\n  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {\n    this.face = FACE_ENUM.BOTTOM;\n  } else if (Math.abs(this.long0) <= FORTPI) {\n    this.face = FACE_ENUM.FRONT;\n  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {\n    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;\n  } else {\n    this.face = FACE_ENUM.BACK;\n  }\n  /* Fill in useful values for the ellipsoid <-> sphere shift\n   * described in [LK12]. */\n\n\n  if (this.es !== 0) {\n    this.one_minus_f = 1 - (this.a - this.b) / this.a;\n    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;\n  }\n} // QSC forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\n\nexport function forward(p) {\n  var xy = {\n    x: 0,\n    y: 0\n  };\n  var lat, lon;\n  var theta, phi;\n  var t, mu;\n  /* nu; */\n\n  var area = {\n    value: 0\n  }; // move lon according to projection's lon\n\n  p.x -= this.long0;\n  /* Convert the geodetic latitude to a geocentric latitude.\n   * This corresponds to the shift from the ellipsoid to the sphere\n   * described in [LK12]. */\n\n  if (this.es !== 0) {\n    //if (P->es != 0) {\n    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));\n  } else {\n    lat = p.y;\n  }\n  /* Convert the input lat, lon into theta, phi as used by QSC.\n   * This depends on the cube face and the area on it.\n   * For the top and bottom face, we can compute theta and phi\n   * directly from phi, lam. For the other faces, we must use\n   * unit sphere cartesian coordinates as an intermediate step. */\n\n\n  lon = p.x; //lon = lp.lam;\n\n  if (this.face === FACE_ENUM.TOP) {\n    phi = HALF_PI - lat;\n\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = lon - HALF_PI;\n    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = lon > 0.0 ? lon - SPI : lon + SPI;\n    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = lon + HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = HALF_PI + lat;\n\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = -lon + HALF_PI;\n    } else if (lon < FORTPI && lon >= -FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = -lon;\n    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = -lon - HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon > 0.0 ? -lon + SPI : -lon - SPI;\n    }\n  } else {\n    var q, r, s;\n    var sinlat, coslat;\n    var sinlon, coslon;\n\n    if (this.face === FACE_ENUM.RIGHT) {\n      lon = qsc_shift_lon_origin(lon, +HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lon = qsc_shift_lon_origin(lon, +SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lon = qsc_shift_lon_origin(lon, -HALF_PI);\n    }\n\n    sinlat = Math.sin(lat);\n    coslat = Math.cos(lat);\n    sinlon = Math.sin(lon);\n    coslon = Math.cos(lon);\n    q = coslat * coslon;\n    r = coslat * sinlon;\n    s = sinlat;\n\n    if (this.face === FACE_ENUM.FRONT) {\n      phi = Math.acos(q);\n      theta = qsc_fwd_equat_face_theta(phi, s, r, area);\n    } else if (this.face === FACE_ENUM.RIGHT) {\n      phi = Math.acos(r);\n      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);\n    } else if (this.face === FACE_ENUM.BACK) {\n      phi = Math.acos(-q);\n      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      phi = Math.acos(-r);\n      theta = qsc_fwd_equat_face_theta(phi, s, q, area);\n    } else {\n      /* Impossible */\n      phi = theta = 0;\n      area.value = AREA_ENUM.AREA_0;\n    }\n  }\n  /* Compute mu and nu for the area of definition.\n   * For mu, see Eq. (3-21) in [OL76], but note the typos:\n   * compare with Eq. (3-14). For nu, see Eq. (3-38). */\n\n\n  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));\n  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));\n  /* Apply the result to the real area. */\n\n  if (area.value === AREA_ENUM.AREA_1) {\n    mu += HALF_PI;\n  } else if (area.value === AREA_ENUM.AREA_2) {\n    mu += SPI;\n  } else if (area.value === AREA_ENUM.AREA_3) {\n    mu += 1.5 * SPI;\n  }\n  /* Now compute x, y from mu and nu */\n\n\n  xy.x = t * Math.cos(mu);\n  xy.y = t * Math.sin(mu);\n  xy.x = xy.x * this.a + this.x0;\n  xy.y = xy.y * this.a + this.y0;\n  p.x = xy.x;\n  p.y = xy.y;\n  return p;\n} // QSC inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\n\nexport function inverse(p) {\n  var lp = {\n    lam: 0,\n    phi: 0\n  };\n  var mu, nu, cosmu, tannu;\n  var tantheta, theta, cosphi, phi;\n  var t;\n  var area = {\n    value: 0\n  };\n  /* de-offset */\n\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n  /* Convert the input x, y to the mu and nu angles as used by QSC.\n   * This depends on the area of the cube face. */\n\n  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));\n  mu = Math.atan2(p.y, p.x);\n\n  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_0;\n  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {\n    area.value = AREA_ENUM.AREA_1;\n    mu -= HALF_PI;\n  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_2;\n    mu = mu < 0.0 ? mu + SPI : mu - SPI;\n  } else {\n    area.value = AREA_ENUM.AREA_3;\n    mu += HALF_PI;\n  }\n  /* Compute phi and theta for the area of definition.\n   * The inverse projection is not described in the original paper, but some\n   * good hints can be found here (as of 2011-12-14):\n   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302\n   * (search for \"Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>\") */\n\n\n  t = SPI / 12 * Math.tan(mu);\n  tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));\n  theta = Math.atan(tantheta);\n  cosmu = Math.cos(mu);\n  tannu = Math.tan(nu);\n  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));\n\n  if (cosphi < -1) {\n    cosphi = -1;\n  } else if (cosphi > +1) {\n    cosphi = +1;\n  }\n  /* Apply the result to the real area on the cube face.\n   * For the top and bottom face, we can compute phi and lam directly.\n   * For the other faces, we must use unit sphere cartesian coordinates\n   * as an intermediate step. */\n\n\n  if (this.face === FACE_ENUM.TOP) {\n    phi = Math.acos(cosphi);\n    lp.phi = HALF_PI - phi;\n\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = theta < 0.0 ? theta + SPI : theta - SPI;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = theta - HALF_PI;\n    } else\n      /* area.value == AREA_ENUM.AREA_3 */\n      {\n        lp.lam = theta;\n      }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = Math.acos(cosphi);\n    lp.phi = phi - HALF_PI;\n\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = -theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = -theta;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = -theta - HALF_PI;\n    } else\n      /* area.value == AREA_ENUM.AREA_3 */\n      {\n        lp.lam = theta < 0.0 ? -theta - SPI : -theta + SPI;\n      }\n  } else {\n    /* Compute phi and lam via cartesian unit sphere coordinates. */\n    var q, r, s;\n    q = cosphi;\n    t = q * q;\n\n    if (t >= 1) {\n      s = 0;\n    } else {\n      s = Math.sqrt(1 - t) * Math.sin(theta);\n    }\n\n    t += s * s;\n\n    if (t >= 1) {\n      r = 0;\n    } else {\n      r = Math.sqrt(1 - t);\n    }\n    /* Rotate q,r,s into the correct area. */\n\n\n    if (area.value === AREA_ENUM.AREA_1) {\n      t = r;\n      r = -s;\n      s = t;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      r = -r;\n      s = -s;\n    } else if (area.value === AREA_ENUM.AREA_3) {\n      t = r;\n      r = s;\n      s = -t;\n    }\n    /* Rotate q,r,s into the correct cube face. */\n\n\n    if (this.face === FACE_ENUM.RIGHT) {\n      t = q;\n      q = -r;\n      r = t;\n    } else if (this.face === FACE_ENUM.BACK) {\n      q = -q;\n      r = -r;\n    } else if (this.face === FACE_ENUM.LEFT) {\n      t = q;\n      q = r;\n      r = -t;\n    }\n    /* Now compute phi and lam from the unit sphere coordinates. */\n\n\n    lp.phi = Math.acos(-s) - HALF_PI;\n    lp.lam = Math.atan2(r, q);\n\n    if (this.face === FACE_ENUM.RIGHT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);\n    }\n  }\n  /* Apply the shift from the sphere to the ellipsoid as described\n   * in [LK12]. */\n\n\n  if (this.es !== 0) {\n    var invert_sign;\n    var tanphi, xa;\n    invert_sign = lp.phi < 0 ? 1 : 0;\n    tanphi = Math.tan(lp.phi);\n    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);\n    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));\n\n    if (invert_sign) {\n      lp.phi = -lp.phi;\n    }\n  }\n\n  lp.lam += this.long0;\n  p.x = lp.lam;\n  p.y = lp.phi;\n  return p;\n}\n/* Helper function for forward projection: compute the theta angle\n * and determine the area number. */\n\nfunction qsc_fwd_equat_face_theta(phi, y, x, area) {\n  var theta;\n\n  if (phi < EPSLN) {\n    area.value = AREA_ENUM.AREA_0;\n    theta = 0.0;\n  } else {\n    theta = Math.atan2(y, x);\n\n    if (Math.abs(theta) <= FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta -= HALF_PI;\n    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = theta >= 0.0 ? theta - SPI : theta + SPI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta += HALF_PI;\n    }\n  }\n\n  return theta;\n}\n/* Helper function: shift the longitude. */\n\n\nfunction qsc_shift_lon_origin(lon, offset) {\n  var slon = lon + offset;\n\n  if (slon < -SPI) {\n    slon += TWO_PI;\n  } else if (slon > +SPI) {\n    slon -= TWO_PI;\n  }\n\n  return slon;\n}\n\nexport var names = [\"Quadrilateralized Spherical Cube\", \"Quadrilateralized_Spherical_Cube\", \"qsc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};","map":{"version":3,"names":["EPSLN","TWO_PI","SPI","HALF_PI","FORTPI","FACE_ENUM","FRONT","RIGHT","BACK","LEFT","TOP","BOTTOM","AREA_ENUM","AREA_0","AREA_1","AREA_2","AREA_3","init","x0","y0","lat0","long0","lat_ts","title","face","Math","abs","es","one_minus_f","a","b","one_minus_f_squared","forward","p","xy","x","y","lat","lon","theta","phi","t","mu","area","value","atan","tan","q","r","s","sinlat","coslat","sinlon","coslon","qsc_shift_lon_origin","sin","cos","acos","qsc_fwd_equat_face_theta","sqrt","inverse","lp","lam","nu","cosmu","tannu","tantheta","cosphi","atan2","invert_sign","tanphi","xa","offset","slon","names"],"sources":["/Users/romanradionov/PycharmProjects/reactleafletgeodjango/my-app/node_modules/proj4/lib/projections/qsc.js"],"sourcesContent":["// QSC projection rewritten from the original PROJ4\n// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c\n\nimport {EPSLN, TWO_PI, SPI, HALF_PI, FORTPI} from '../constants/values';\n\n/* constants */\nvar FACE_ENUM = {\n    FRONT: 1,\n    RIGHT: 2,\n    BACK: 3,\n    LEFT: 4,\n    TOP: 5,\n    BOTTOM: 6\n};\n\nvar AREA_ENUM = {\n    AREA_0: 1,\n    AREA_1: 2,\n    AREA_2: 3,\n    AREA_3: 4\n};\n\nexport function init() {\n\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || \"Quadrilateralized Spherical Cube\";\n\n  /* Determine the cube face from the center of projection. */\n  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {\n    this.face = FACE_ENUM.TOP;\n  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {\n    this.face = FACE_ENUM.BOTTOM;\n  } else if (Math.abs(this.long0) <= FORTPI) {\n    this.face = FACE_ENUM.FRONT;\n  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {\n    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;\n  } else {\n    this.face = FACE_ENUM.BACK;\n  }\n\n  /* Fill in useful values for the ellipsoid <-> sphere shift\n   * described in [LK12]. */\n  if (this.es !== 0) {\n    this.one_minus_f = 1 - (this.a - this.b) / this.a;\n    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;\n  }\n}\n\n// QSC forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexport function forward(p) {\n  var xy = {x: 0, y: 0};\n  var lat, lon;\n  var theta, phi;\n  var t, mu;\n  /* nu; */\n  var area = {value: 0};\n\n  // move lon according to projection's lon\n  p.x -= this.long0;\n\n  /* Convert the geodetic latitude to a geocentric latitude.\n   * This corresponds to the shift from the ellipsoid to the sphere\n   * described in [LK12]. */\n  if (this.es !== 0) {//if (P->es != 0) {\n    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));\n  } else {\n    lat = p.y;\n  }\n\n  /* Convert the input lat, lon into theta, phi as used by QSC.\n   * This depends on the cube face and the area on it.\n   * For the top and bottom face, we can compute theta and phi\n   * directly from phi, lam. For the other faces, we must use\n   * unit sphere cartesian coordinates as an intermediate step. */\n  lon = p.x; //lon = lp.lam;\n  if (this.face === FACE_ENUM.TOP) {\n    phi = HALF_PI - lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = lon - HALF_PI;\n    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = (lon > 0.0 ? lon - SPI : lon + SPI);\n    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = lon + HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = lon;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = HALF_PI + lat;\n    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n      theta = -lon + HALF_PI;\n    } else if (lon < FORTPI && lon >= -FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta = -lon;\n    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = -lon - HALF_PI;\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);\n    }\n  } else {\n    var q, r, s;\n    var sinlat, coslat;\n    var sinlon, coslon;\n\n    if (this.face === FACE_ENUM.RIGHT) {\n      lon = qsc_shift_lon_origin(lon, +HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lon = qsc_shift_lon_origin(lon, +SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lon = qsc_shift_lon_origin(lon, -HALF_PI);\n    }\n    sinlat = Math.sin(lat);\n    coslat = Math.cos(lat);\n    sinlon = Math.sin(lon);\n    coslon = Math.cos(lon);\n    q = coslat * coslon;\n    r = coslat * sinlon;\n    s = sinlat;\n\n    if (this.face === FACE_ENUM.FRONT) {\n      phi = Math.acos(q);\n      theta = qsc_fwd_equat_face_theta(phi, s, r, area);\n    } else if (this.face === FACE_ENUM.RIGHT) {\n      phi = Math.acos(r);\n      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);\n    } else if (this.face === FACE_ENUM.BACK) {\n      phi = Math.acos(-q);\n      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      phi = Math.acos(-r);\n      theta = qsc_fwd_equat_face_theta(phi, s, q, area);\n    } else {\n      /* Impossible */\n      phi = theta = 0;\n      area.value = AREA_ENUM.AREA_0;\n    }\n  }\n\n  /* Compute mu and nu for the area of definition.\n   * For mu, see Eq. (3-21) in [OL76], but note the typos:\n   * compare with Eq. (3-14). For nu, see Eq. (3-38). */\n  mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));\n  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));\n\n  /* Apply the result to the real area. */\n  if (area.value === AREA_ENUM.AREA_1) {\n    mu += HALF_PI;\n  } else if (area.value === AREA_ENUM.AREA_2) {\n    mu += SPI;\n  } else if (area.value === AREA_ENUM.AREA_3) {\n    mu += 1.5 * SPI;\n  }\n\n  /* Now compute x, y from mu and nu */\n  xy.x = t * Math.cos(mu);\n  xy.y = t * Math.sin(mu);\n  xy.x = xy.x * this.a + this.x0;\n  xy.y = xy.y * this.a + this.y0;\n\n  p.x = xy.x;\n  p.y = xy.y;\n  return p;\n}\n\n// QSC inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexport function inverse(p) {\n  var lp = {lam: 0, phi: 0};\n  var mu, nu, cosmu, tannu;\n  var tantheta, theta, cosphi, phi;\n  var t;\n  var area = {value: 0};\n\n  /* de-offset */\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  /* Convert the input x, y to the mu and nu angles as used by QSC.\n   * This depends on the area of the cube face. */\n  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));\n  mu = Math.atan2(p.y, p.x);\n  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_0;\n  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {\n    area.value = AREA_ENUM.AREA_1;\n    mu -= HALF_PI;\n  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {\n    area.value = AREA_ENUM.AREA_2;\n    mu = (mu < 0.0 ? mu + SPI : mu - SPI);\n  } else {\n    area.value = AREA_ENUM.AREA_3;\n    mu += HALF_PI;\n  }\n\n  /* Compute phi and theta for the area of definition.\n   * The inverse projection is not described in the original paper, but some\n   * good hints can be found here (as of 2011-12-14):\n   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302\n   * (search for \"Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>\") */\n  t = (SPI / 12) * Math.tan(mu);\n  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));\n  theta = Math.atan(tantheta);\n  cosmu = Math.cos(mu);\n  tannu = Math.tan(nu);\n  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));\n  if (cosphi < -1) {\n    cosphi = -1;\n  } else if (cosphi > +1) {\n    cosphi = +1;\n  }\n\n  /* Apply the result to the real area on the cube face.\n   * For the top and bottom face, we can compute phi and lam directly.\n   * For the other faces, we must use unit sphere cartesian coordinates\n   * as an intermediate step. */\n  if (this.face === FACE_ENUM.TOP) {\n    phi = Math.acos(cosphi);\n    lp.phi = HALF_PI - phi;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = theta;\n    }\n  } else if (this.face === FACE_ENUM.BOTTOM) {\n    phi = Math.acos(cosphi);\n    lp.phi = phi - HALF_PI;\n    if (area.value === AREA_ENUM.AREA_0) {\n      lp.lam = -theta + HALF_PI;\n    } else if (area.value === AREA_ENUM.AREA_1) {\n      lp.lam = -theta;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      lp.lam = -theta - HALF_PI;\n    } else /* area.value == AREA_ENUM.AREA_3 */ {\n      lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);\n    }\n  } else {\n    /* Compute phi and lam via cartesian unit sphere coordinates. */\n    var q, r, s;\n    q = cosphi;\n    t = q * q;\n    if (t >= 1) {\n      s = 0;\n    } else {\n      s = Math.sqrt(1 - t) * Math.sin(theta);\n    }\n    t += s * s;\n    if (t >= 1) {\n      r = 0;\n    } else {\n      r = Math.sqrt(1 - t);\n    }\n    /* Rotate q,r,s into the correct area. */\n    if (area.value === AREA_ENUM.AREA_1) {\n      t = r;\n      r = -s;\n      s = t;\n    } else if (area.value === AREA_ENUM.AREA_2) {\n      r = -r;\n      s = -s;\n    } else if (area.value === AREA_ENUM.AREA_3) {\n      t = r;\n      r = s;\n      s = -t;\n    }\n    /* Rotate q,r,s into the correct cube face. */\n    if (this.face === FACE_ENUM.RIGHT) {\n      t = q;\n      q = -r;\n      r = t;\n    } else if (this.face === FACE_ENUM.BACK) {\n      q = -q;\n      r = -r;\n    } else if (this.face === FACE_ENUM.LEFT) {\n      t = q;\n      q = r;\n      r = -t;\n    }\n    /* Now compute phi and lam from the unit sphere coordinates. */\n    lp.phi = Math.acos(-s) - HALF_PI;\n    lp.lam = Math.atan2(r, q);\n    if (this.face === FACE_ENUM.RIGHT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);\n    } else if (this.face === FACE_ENUM.BACK) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);\n    } else if (this.face === FACE_ENUM.LEFT) {\n      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);\n    }\n  }\n\n  /* Apply the shift from the sphere to the ellipsoid as described\n   * in [LK12]. */\n  if (this.es !== 0) {\n    var invert_sign;\n    var tanphi, xa;\n    invert_sign = (lp.phi < 0 ? 1 : 0);\n    tanphi = Math.tan(lp.phi);\n    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);\n    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));\n    if (invert_sign) {\n      lp.phi = -lp.phi;\n    }\n  }\n\n  lp.lam += this.long0;\n  p.x = lp.lam;\n  p.y = lp.phi;\n  return p;\n}\n\n/* Helper function for forward projection: compute the theta angle\n * and determine the area number. */\nfunction qsc_fwd_equat_face_theta(phi, y, x, area) {\n  var theta;\n  if (phi < EPSLN) {\n    area.value = AREA_ENUM.AREA_0;\n    theta = 0.0;\n  } else {\n    theta = Math.atan2(y, x);\n    if (Math.abs(theta) <= FORTPI) {\n      area.value = AREA_ENUM.AREA_0;\n    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {\n      area.value = AREA_ENUM.AREA_1;\n      theta -= HALF_PI;\n    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {\n      area.value = AREA_ENUM.AREA_2;\n      theta = (theta >= 0.0 ? theta - SPI : theta + SPI);\n    } else {\n      area.value = AREA_ENUM.AREA_3;\n      theta += HALF_PI;\n    }\n  }\n  return theta;\n}\n\n/* Helper function: shift the longitude. */\nfunction qsc_shift_lon_origin(lon, offset) {\n  var slon = lon + offset;\n  if (slon < -SPI) {\n    slon += TWO_PI;\n  } else if (slon > +SPI) {\n    slon -= TWO_PI;\n  }\n  return slon;\n}\n\nexport var names = [\"Quadrilateralized Spherical Cube\", \"Quadrilateralized_Spherical_Cube\", \"qsc\"];\nexport default {\n  init: init,\n  forward: forward,\n  inverse: inverse,\n  names: names\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}