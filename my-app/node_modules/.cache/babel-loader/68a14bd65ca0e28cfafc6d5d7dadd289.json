{"ast":null,"code":"import { LineUtil, Point, Polygon, DomEvent } from 'leaflet';\nimport { defaultOptions, edgesKey, modesKey, polygons } from '../FreeDraw';\nimport { updateFor } from './Layer';\nimport createEdges from './Edges';\nimport { DELETE, APPEND } from './Flags';\nimport handlePolygonClick from './Polygon';\nimport concavePolygon from './Concave';\nimport mergePolygons from './Merge';\n/**\n * @method appendEdgeFor\n * @param {Object} map\n * @param {Object} polygon\n * @param {Object} options\n * @param {Array} parts\n * @param {Object} newPoint\n * @param {Object} startPoint\n * @param {Object} endPoint\n * @return {void}\n */\n\nconst appendEdgeFor = (map, polygon, options, _ref) => {\n  let {\n    parts,\n    newPoint,\n    startPoint,\n    endPoint\n  } = _ref;\n  const latLngs = parts.reduce((accumulator, point, index) => {\n    const nextPoint = parts[index + 1] || parts[0];\n\n    if (point === startPoint && nextPoint === endPoint) {\n      return [// We've found the location to add the new polygon.\n      ...accumulator, map.containerPointToLatLng(point), map.containerPointToLatLng(newPoint)];\n    }\n\n    return [...accumulator, map.containerPointToLatLng(point)];\n  }, []); // Update the lat/lngs with the newly inserted edge.\n\n  polygon.setLatLngs(latLngs); // Remove the current set of edges for the polygon, and then recreate them, assigning the\n  // new set of edges back into the polygon.\n\n  polygon[edgesKey].map(edge => map.removeLayer(edge));\n  polygon[edgesKey] = createEdges(map, polygon, options);\n};\n/**\n * @method createFor\n * @param {Object} map\n * @param {Array} latLngs\n * @param {Object} [options = defaultOptions]\n * @param {Boolean} [preventMutations = false]\n * @return {Array|Boolean}\n */\n\n\nexport const createFor = function (map, latLngs) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n  let preventMutations = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // Determine whether we've reached the maximum polygons.\n  const limitReached = polygons.get(map).size === options.maximumPolygons; // Apply the concave hull algorithm to the created polygon if the options allow.\n\n  const concavedLatLngs = !preventMutations && options.concavePolygon ? concavePolygon(map, latLngs) : latLngs; // Simplify the polygon before adding it to the map.\n\n  const addedPolygons = limitReached ? [] : map.simplifyPolygon(map, concavedLatLngs, options).map(latLngs => {\n    const polygon = new Polygon(latLngs, { ...defaultOptions,\n      ...options,\n      className: 'leaflet-polygon'\n    }).addTo(map); // Attach the edges to the polygon.\n\n    polygon[edgesKey] = createEdges(map, polygon, options); // Disable the propagation when you click on the marker.\n\n    DomEvent.disableClickPropagation(polygon); // Yield the click handler to the `handlePolygonClick` function.\n\n    polygon.off('click');\n    polygon.on('click', handlePolygonClick(map, polygon, options));\n    return polygon;\n  }); // Append the current polygon to the master set.\n\n  addedPolygons.forEach(polygon => polygons.get(map).add(polygon));\n\n  if (!limitReached && !preventMutations && polygons.get(map).size > 1 && options.mergePolygons) {\n    // Attempt a merge of all the polygons if the options allow, and the polygon count is above one.\n    const addedMergedPolygons = mergePolygons(map, Array.from(polygons.get(map)), options); // Clear the set, and added all of the merged polygons into the master set.\n\n    addedMergedPolygons.forEach(polygon => polygons.get(map).add(polygon));\n    return addedMergedPolygons;\n  }\n\n  return addedPolygons;\n};\n/**\n * @method removeFor\n * @param {Object} map\n * @param {Object} polygon\n * @return {void}\n */\n\nexport const removeFor = (map, polygon) => {\n  // Remove polygon and all of its associated edges.\n  map.removeLayer(polygon);\n  edgesKey in polygon && polygon[edgesKey].map(edge => map.removeLayer(edge)); // Remove polygon from the master set.\n\n  polygons.get(map).delete(polygon);\n};\n/**\n * @method clearFor\n * @param {Object} map\n * @return {void}\n */\n\nexport const clearFor = map => {\n  Array.from(polygons.get(map).values()).forEach(polygon => removeFor(map, polygon));\n};\n/**\n * @param {Object} map\n * @param {Object} polygon\n * @param {Object} options\n * @return {Function}\n */\n\nexport default ((map, polygon, options) => {\n  return event => {\n    // Gather all of the points from the lat/lngs of the current polygon.\n    const newPoint = map.mouseEventToContainerPoint('originalEvent' in event ? event.originalEvent : event);\n    const parts = polygon.getLatLngs()[0].map(latLng => map.latLngToContainerPoint(latLng));\n    const {\n      startPoint,\n      endPoint,\n      lowestDistance\n    } = parts.reduce((accumulator, point, index) => {\n      const startPoint = point;\n      const endPoint = parts[index + 1] || parts[0];\n      const distance = LineUtil.pointToSegmentDistance(newPoint, startPoint, endPoint);\n\n      if (distance < accumulator.lowestDistance) {\n        // If the distance is less than the previous then we'll update the accumulator.\n        return {\n          lowestDistance: distance,\n          startPoint,\n          endPoint\n        };\n      } // Otherwise we'll simply yield the previous accumulator.\n\n\n      return accumulator;\n    }, {\n      lowestDistance: Infinity,\n      startPoint: new Point(),\n      endPoint: new Point()\n    }); // Setup the conditions for the switch statement to make the cases clearer.\n\n    const mode = map[modesKey];\n    const isDelete = Boolean(mode & DELETE);\n    const isAppend = Boolean(mode & APPEND);\n    const isDeleteAndAppend = Boolean(mode & DELETE && mode & APPEND); // Partially apply the remove and append functions.\n\n    const removePolygon = () => removeFor(map, polygon);\n\n    const appendEdge = () => appendEdgeFor(map, polygon, options, {\n      parts,\n      newPoint,\n      startPoint,\n      endPoint\n    });\n\n    switch (true) {\n      // If both modes DELETE and APPEND are active then we need to do a little work to determine\n      // which action to take based on where the user clicked on the polygon.\n      case isDeleteAndAppend:\n        lowestDistance > options.elbowDistance ? removePolygon() : appendEdge();\n        break;\n\n      case isDelete:\n        removePolygon();\n        break;\n\n      case isAppend:\n        appendEdge();\n        break;\n    } // Trigger the event for having deleted a polygon or appended an edge.\n\n\n    (isDelete || isAppend) && updateFor(map, isDelete ? 'remove' : 'append');\n  };\n});","map":{"version":3,"names":["LineUtil","Point","Polygon","DomEvent","defaultOptions","edgesKey","modesKey","polygons","updateFor","createEdges","DELETE","APPEND","handlePolygonClick","concavePolygon","mergePolygons","appendEdgeFor","map","polygon","options","parts","newPoint","startPoint","endPoint","latLngs","reduce","accumulator","point","index","nextPoint","containerPointToLatLng","setLatLngs","edge","removeLayer","createFor","preventMutations","limitReached","get","size","maximumPolygons","concavedLatLngs","addedPolygons","simplifyPolygon","className","addTo","disableClickPropagation","off","on","forEach","add","addedMergedPolygons","Array","from","removeFor","delete","clearFor","values","event","mouseEventToContainerPoint","originalEvent","getLatLngs","latLng","latLngToContainerPoint","lowestDistance","distance","pointToSegmentDistance","Infinity","mode","isDelete","Boolean","isAppend","isDeleteAndAppend","removePolygon","appendEdge","elbowDistance"],"sources":["/Users/romanradionov/PycharmProjects/reactleafletgeodjango/my-app/node_modules/leaflet-freedraw/src/helpers/Polygon.js"],"sourcesContent":["import { LineUtil, Point, Polygon, DomEvent } from 'leaflet';\nimport { defaultOptions, edgesKey, modesKey, polygons } from '../FreeDraw';\nimport { updateFor } from './Layer';\nimport createEdges from './Edges';\nimport { DELETE, APPEND } from './Flags';\nimport handlePolygonClick from './Polygon';\nimport concavePolygon from './Concave';\nimport mergePolygons from './Merge';\n\n/**\n * @method appendEdgeFor\n * @param {Object} map\n * @param {Object} polygon\n * @param {Object} options\n * @param {Array} parts\n * @param {Object} newPoint\n * @param {Object} startPoint\n * @param {Object} endPoint\n * @return {void}\n */\nconst appendEdgeFor = (map, polygon, options, { parts, newPoint, startPoint, endPoint }) => {\n\n    const latLngs = parts.reduce((accumulator, point, index) => {\n\n        const nextPoint = parts[index + 1] || parts[0];\n\n        if (point === startPoint && nextPoint === endPoint) {\n\n            return [\n\n                // We've found the location to add the new polygon.\n                ...accumulator,\n                map.containerPointToLatLng(point),\n                map.containerPointToLatLng(newPoint)\n\n            ];\n\n        }\n\n        return [ ...accumulator, map.containerPointToLatLng(point) ];\n\n    }, []);\n\n    // Update the lat/lngs with the newly inserted edge.\n    polygon.setLatLngs(latLngs);\n\n    // Remove the current set of edges for the polygon, and then recreate them, assigning the\n    // new set of edges back into the polygon.\n    polygon[edgesKey].map(edge => map.removeLayer(edge));\n    polygon[edgesKey] = createEdges(map, polygon, options);\n\n};\n\n/**\n * @method createFor\n * @param {Object} map\n * @param {Array} latLngs\n * @param {Object} [options = defaultOptions]\n * @param {Boolean} [preventMutations = false]\n * @return {Array|Boolean}\n */\nexport const createFor = (map, latLngs, options = defaultOptions, preventMutations = false) => {\n\n    // Determine whether we've reached the maximum polygons.\n    const limitReached = polygons.get(map).size === options.maximumPolygons;\n\n    // Apply the concave hull algorithm to the created polygon if the options allow.\n    const concavedLatLngs = !preventMutations && options.concavePolygon ? concavePolygon(map, latLngs) : latLngs;\n\n    // Simplify the polygon before adding it to the map.\n    const addedPolygons = limitReached ? [] : map.simplifyPolygon(map, concavedLatLngs, options).map(latLngs => {\n\n        const polygon = new Polygon(latLngs, {\n            ...defaultOptions, ...options, className: 'leaflet-polygon'\n        }).addTo(map);\n\n        // Attach the edges to the polygon.\n        polygon[edgesKey] = createEdges(map, polygon, options);\n\n        // Disable the propagation when you click on the marker.\n        DomEvent.disableClickPropagation(polygon);\n\n        // Yield the click handler to the `handlePolygonClick` function.\n        polygon.off('click');\n        polygon.on('click', handlePolygonClick(map, polygon, options));\n\n        return polygon;\n\n    });\n\n    // Append the current polygon to the master set.\n    addedPolygons.forEach(polygon => polygons.get(map).add(polygon));\n\n    if (!limitReached && !preventMutations && polygons.get(map).size > 1 && options.mergePolygons) {\n\n        // Attempt a merge of all the polygons if the options allow, and the polygon count is above one.\n        const addedMergedPolygons = mergePolygons(map, Array.from(polygons.get(map)), options);\n\n        // Clear the set, and added all of the merged polygons into the master set.\n        addedMergedPolygons.forEach(polygon => polygons.get(map).add(polygon));\n\n        return addedMergedPolygons;\n\n    }\n\n    return addedPolygons;\n\n};\n\n/**\n * @method removeFor\n * @param {Object} map\n * @param {Object} polygon\n * @return {void}\n */\nexport const removeFor = (map, polygon) => {\n\n    // Remove polygon and all of its associated edges.\n    map.removeLayer(polygon);\n    edgesKey in polygon && polygon[edgesKey].map(edge => map.removeLayer(edge));\n\n    // Remove polygon from the master set.\n    polygons.get(map).delete(polygon);\n\n};\n\n/**\n * @method clearFor\n * @param {Object} map\n * @return {void}\n */\nexport const clearFor = map => {\n    Array.from(polygons.get(map).values()).forEach(polygon => removeFor(map, polygon));\n};\n\n/**\n * @param {Object} map\n * @param {Object} polygon\n * @param {Object} options\n * @return {Function}\n */\nexport default (map, polygon, options) => {\n\n    return event => {\n\n        // Gather all of the points from the lat/lngs of the current polygon.\n        const newPoint = map.mouseEventToContainerPoint('originalEvent' in event ? event.originalEvent : event);\n        const parts = polygon.getLatLngs()[0].map(latLng => map.latLngToContainerPoint(latLng));\n\n        const { startPoint, endPoint, lowestDistance } = parts.reduce((accumulator, point, index) => {\n\n            const startPoint = point;\n            const endPoint = parts[index + 1] || parts[0];\n            const distance = LineUtil.pointToSegmentDistance(newPoint, startPoint, endPoint);\n\n            if (distance < accumulator.lowestDistance) {\n\n                // If the distance is less than the previous then we'll update the accumulator.\n                return { lowestDistance: distance, startPoint, endPoint };\n\n            }\n\n            // Otherwise we'll simply yield the previous accumulator.\n            return accumulator;\n\n        }, { lowestDistance: Infinity, startPoint: new Point(), endPoint: new Point() });\n\n        // Setup the conditions for the switch statement to make the cases clearer.\n        const mode = map[modesKey];\n        const isDelete = Boolean(mode & DELETE);\n        const isAppend = Boolean(mode & APPEND);\n        const isDeleteAndAppend = Boolean(mode & DELETE && mode & APPEND);\n\n        // Partially apply the remove and append functions.\n        const removePolygon = () => removeFor(map, polygon);\n        const appendEdge = () => appendEdgeFor(map, polygon, options, { parts, newPoint, startPoint, endPoint });\n\n        switch (true) {\n\n            // If both modes DELETE and APPEND are active then we need to do a little work to determine\n            // which action to take based on where the user clicked on the polygon.\n            case isDeleteAndAppend:\n                lowestDistance > options.elbowDistance ? removePolygon() : appendEdge();\n                break;\n\n            case isDelete:\n                removePolygon();\n                break;\n\n            case isAppend:\n                appendEdge();\n                break;\n\n        }\n\n        // Trigger the event for having deleted a polygon or appended an edge.\n        (isDelete || isAppend) && updateFor(map, isDelete ? 'remove' : 'append');\n\n    };\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}