{"ast":null,"code":"import { Point } from 'leaflet';\nimport { flatten, identical, complement, compose, head } from 'ramda';\nimport { Clipper, PolyFillType } from 'clipper-lib';\nimport createPolygon from 'turf-polygon';\nimport isIntersecting from 'turf-intersect';\nimport { createFor, removeFor } from './Polygon';\nimport { latLngsToClipperPoints } from './Simplify';\n/**\n * @method fillPolygon\n * @param {Object} map\n * @param {Array} polygons\n * @param {Object} options\n * @return {Array}\n */\n\nexport function fillPolygon(map, polygon, options) {\n  // Simplify the polygon which prevents voids in its shape.\n  const points = latLngsToClipperPoints(map, polygon.getLatLngs()[0]);\n  Clipper.SimplifyPolygon(points, PolyFillType.pftNonZero);\n  removeFor(map, polygon); // Convert the Clipper points back into lat/lng pairs.\n\n  const latLngs = points.map(model => map.layerPointToLatLng(new Point(model.X, model.Y)));\n  createFor(map, latLngs, options, true);\n}\n/**\n * @method latLngsToTuple\n * @param {Array} latLngs\n * @return {Array}\n */\n\nfunction latLngsToTuple(latLngs) {\n  return latLngs.map(model => [model.lat, model.lng]);\n}\n/**\n * @param {Object} map\n * @param {Array} polygons\n * @param {Object} options\n * @return {Array}\n */\n\n\nexport default ((map, polygons, options) => {\n  // Transform a L.LatLng object into a GeoJSON polygon that TurfJS expects to receive.\n  const toTurfPolygon = compose(createPolygon, x => [x], x => [...x, head(x)], latLngsToTuple);\n  const analysis = polygons.reduce((accum, polygon) => {\n    const latLngs = polygon.getLatLngs()[0];\n    const points = latLngsToClipperPoints(map, polygon.getLatLngs()[0]);\n    const turfPolygon = toTurfPolygon(latLngs); // Determine if the current polygon intersects any of the other polygons currently on the map.\n\n    const intersects = polygons.filter(complement(identical(polygon))).some(polygon => {\n      return Boolean(isIntersecting(turfPolygon, toTurfPolygon(polygon.getLatLngs()[0])));\n    });\n    const key = intersects ? 'intersecting' : 'rest';\n    return { ...accum,\n      [key]: [...accum[key], intersects ? points : latLngs],\n      intersectingPolygons: intersects ? [...accum.intersectingPolygons, polygon] : accum.intersectingPolygons\n    };\n  }, {\n    intersecting: [],\n    rest: [],\n    intersectingPolygons: []\n  }); // Merge all of the polygons.\n\n  const mergePolygons = Clipper.SimplifyPolygons(analysis.intersecting, PolyFillType.pftNonZero); // Remove all of the existing polygons that are intersecting another polygon.\n\n  analysis.intersectingPolygons.forEach(polygon => removeFor(map, polygon));\n  return flatten(mergePolygons.map(polygon => {\n    // Determine if it's an intersecting polygon or not.\n    const latLngs = polygon.map(model => {\n      return map.layerPointToLatLng(new Point(model.X, model.Y));\n    }); // Create the polygon, but this time prevent any merging, otherwise we'll find ourselves\n    // in an infinite loop.\n\n    return createFor(map, latLngs, options, true);\n  }));\n});","map":{"version":3,"names":["Point","flatten","identical","complement","compose","head","Clipper","PolyFillType","createPolygon","isIntersecting","createFor","removeFor","latLngsToClipperPoints","fillPolygon","map","polygon","options","points","getLatLngs","SimplifyPolygon","pftNonZero","latLngs","model","layerPointToLatLng","X","Y","latLngsToTuple","lat","lng","polygons","toTurfPolygon","x","analysis","reduce","accum","turfPolygon","intersects","filter","some","Boolean","key","intersectingPolygons","intersecting","rest","mergePolygons","SimplifyPolygons","forEach"],"sources":["/Users/romanradionov/PycharmProjects/reactleafletgeodjango/my-app/node_modules/leaflet-freedraw/src/helpers/Merge.js"],"sourcesContent":["import { Point } from 'leaflet';\nimport { flatten, identical, complement, compose, head } from 'ramda';\nimport { Clipper, PolyFillType } from 'clipper-lib';\nimport createPolygon from 'turf-polygon';\nimport isIntersecting from 'turf-intersect';\nimport { createFor, removeFor } from './Polygon';\nimport { latLngsToClipperPoints } from './Simplify';\n\n/**\n * @method fillPolygon\n * @param {Object} map\n * @param {Array} polygons\n * @param {Object} options\n * @return {Array}\n */\nexport function fillPolygon(map, polygon, options) {\n\n    // Simplify the polygon which prevents voids in its shape.\n    const points = latLngsToClipperPoints(map, polygon.getLatLngs()[0]);\n    Clipper.SimplifyPolygon(points, PolyFillType.pftNonZero);\n    removeFor(map, polygon);\n\n    // Convert the Clipper points back into lat/lng pairs.\n    const latLngs = points.map(model => map.layerPointToLatLng(new Point(model.X, model.Y)));\n\n    createFor(map, latLngs, options, true);\n\n}\n\n/**\n * @method latLngsToTuple\n * @param {Array} latLngs\n * @return {Array}\n */\nfunction latLngsToTuple(latLngs) {\n    return latLngs.map(model => [model.lat, model.lng]);\n}\n\n/**\n * @param {Object} map\n * @param {Array} polygons\n * @param {Object} options\n * @return {Array}\n */\nexport default (map, polygons, options) => {\n\n    // Transform a L.LatLng object into a GeoJSON polygon that TurfJS expects to receive.\n    const toTurfPolygon = compose(createPolygon, x => [x], x => [...x, head(x)], latLngsToTuple);\n\n    const analysis = polygons.reduce((accum, polygon) => {\n\n        const latLngs = polygon.getLatLngs()[0];\n        const points = latLngsToClipperPoints(map, polygon.getLatLngs()[0]);\n        const turfPolygon = toTurfPolygon(latLngs);\n\n        // Determine if the current polygon intersects any of the other polygons currently on the map.\n        const intersects = polygons.filter(complement(identical(polygon))).some(polygon => {\n            return Boolean(isIntersecting(turfPolygon, toTurfPolygon(polygon.getLatLngs()[0])));\n        });\n\n        const key = intersects ? 'intersecting' : 'rest';\n\n        return {\n            ...accum,\n            [key]: [...accum[key], intersects ? points : latLngs],\n            intersectingPolygons: intersects ? [...accum.intersectingPolygons, polygon] : accum.intersectingPolygons\n        };\n\n    }, { intersecting: [], rest: [], intersectingPolygons: [] });\n\n    // Merge all of the polygons.\n    const mergePolygons = Clipper.SimplifyPolygons(analysis.intersecting, PolyFillType.pftNonZero);\n\n    // Remove all of the existing polygons that are intersecting another polygon.\n    analysis.intersectingPolygons.forEach(polygon => removeFor(map, polygon));\n\n    return flatten(mergePolygons.map(polygon => {\n\n        // Determine if it's an intersecting polygon or not.\n        const latLngs = polygon.map(model => {\n            return map.layerPointToLatLng(new Point(model.X, model.Y));\n        });\n\n        // Create the polygon, but this time prevent any merging, otherwise we'll find ourselves\n        // in an infinite loop.\n        return createFor(map, latLngs, options, true);\n\n    }));\n\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}