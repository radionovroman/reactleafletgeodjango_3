{"ast":null,"code":"// rev 482\n\n/********************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.2.1                                                          *\n * Date      :  31 October 2014                                                 *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2014                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.2.1.0                                                         *\n * Date      :  17 June 2016                                                 *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n * Because Javascript lacks support for 64-bit integers, the space              *\n * is a little more restricted than in C# version.                              *\n *                                                                              *\n * C# version has support for coordinate space:                                 *\n * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n * while Javascript version has support for space:                              *\n * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n *                                                                              *\n * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n * http://jsperf.com/big-integer-library-test                                   *\n *                                                                              *\n * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n *                                                                              *\n *******************************************************************************/\n\n/*******************************************************************************\n *                                                                              *\n * Basic JavaScript BN library - subset useful for RSA encryption.              *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n * Copyright (c) 2005  Tom Wu                                                   *\n * All Rights Reserved.                                                         *\n * See \"LICENSE\" for details:                                                   *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n *                                                                              *\n *******************************************************************************/\n(function () {\n  \"use strict\"; //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n  //improve performance but coordinate values are limited to the range +/- 46340\n\n  var use_int32 = false; //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n\n  var use_xyz = false; //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n\n  var use_lines = true;\n  var ClipperLib = {};\n  var isNode = false;\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = ClipperLib;\n    isNode = true;\n  } else {\n    if (typeof define === 'function' && define.amd) {\n      define(ClipperLib);\n    }\n\n    if (typeof document !== \"undefined\") window.ClipperLib = ClipperLib;else self['ClipperLib'] = ClipperLib;\n  }\n\n  var navigator_appName;\n\n  if (!isNode) {\n    var nav = navigator.userAgent.toString().toLowerCase();\n    navigator_appName = navigator.appName;\n  } else {\n    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n\n    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n  } // Browser test to speedup performance critical functions\n\n\n  var browser = {};\n  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;else browser.chrome = 0;\n  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;else browser.chromium = 0;\n  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;else browser.safari = 0;\n  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;else browser.firefox = 0;\n  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;else browser.firefox17 = 0;\n  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;else browser.firefox15 = 0;\n  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;else browser.firefox3 = 0;\n  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;else browser.opera = 0;\n  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;else browser.msie10 = 0;\n  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;else browser.msie9 = 0;\n  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;else browser.msie8 = 0;\n  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;else browser.msie7 = 0;\n  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;else browser.msie = 0;\n  ClipperLib.biginteger_used = null; // Copyright (c) 2005  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Basic JavaScript BN library - subset useful for RSA encryption.\n  // Bits per digit\n\n  var dbits; // JavaScript engine analysis\n\n  var canary = 0xdeadbeefcafe;\n  var j_lm = (canary & 0xffffff) == 0xefcafe; // (public) Constructor\n\n  function BigInteger(a, b, c) {\n    // This test variable can be removed,\n    // but at least for performance tests it is useful piece of knowledge\n    // This is the only ClipperLib related variable in BigInteger library\n    ClipperLib.biginteger_used = 1;\n    if (a != null) if (\"number\" == typeof a && \"undefined\" == typeof b) this.fromInt(a); // faster conversion\n    else if (\"number\" == typeof a) this.fromNumber(a, b, c);else if (b == null && \"string\" != typeof a) this.fromString(a, 256);else this.fromString(a, b);\n  } // return new, unset BigInteger\n\n\n  function nbi() {\n    return new BigInteger(null, undefined, undefined);\n  } // am: Compute w_j += (x*this_i), propagate carries,\n  // c is initial carry, returns final carry.\n  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n  // We need to select the fastest one that works in this environment.\n  // am1: use a single mult and divide to get the high bits,\n  // max digit bits should be 26 because\n  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n\n\n  function am1(i, x, w, j, c, n) {\n    while (--n >= 0) {\n      var v = x * this[i++] + w[j] + c;\n      c = Math.floor(v / 0x4000000);\n      w[j++] = v & 0x3ffffff;\n    }\n\n    return c;\n  } // am2 avoids a big mult-and-extract completely.\n  // Max digit bits should be <= 30 because we do bitwise ops\n  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n\n\n  function am2(i, x, w, j, c, n) {\n    var xl = x & 0x7fff,\n        xh = x >> 15;\n\n    while (--n >= 0) {\n      var l = this[i] & 0x7fff;\n      var h = this[i++] >> 15;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n      w[j++] = l & 0x3fffffff;\n    }\n\n    return c;\n  } // Alternately, set max digit bits to 28 since some\n  // browsers slow down when dealing with 32-bit numbers.\n\n\n  function am3(i, x, w, j, c, n) {\n    var xl = x & 0x3fff,\n        xh = x >> 14;\n\n    while (--n >= 0) {\n      var l = this[i] & 0x3fff;\n      var h = this[i++] >> 14;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n      c = (l >> 28) + (m >> 14) + xh * h;\n      w[j++] = l & 0xfffffff;\n    }\n\n    return c;\n  }\n\n  if (j_lm && navigator_appName == \"Microsoft Internet Explorer\") {\n    BigInteger.prototype.am = am2;\n    dbits = 30;\n  } else if (j_lm && navigator_appName != \"Netscape\") {\n    BigInteger.prototype.am = am1;\n    dbits = 26;\n  } else {\n    // Mozilla/Netscape seems to prefer am3\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n  }\n\n  BigInteger.prototype.DB = dbits;\n  BigInteger.prototype.DM = (1 << dbits) - 1;\n  BigInteger.prototype.DV = 1 << dbits;\n  var BI_FP = 52;\n  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n  BigInteger.prototype.F1 = BI_FP - dbits;\n  BigInteger.prototype.F2 = 2 * dbits - BI_FP; // Digit conversions\n\n  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n  var BI_RC = new Array();\n  var rr, vv;\n  rr = \"0\".charCodeAt(0);\n\n  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n\n  rr = \"a\".charCodeAt(0);\n\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n  rr = \"A\".charCodeAt(0);\n\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n  function int2char(n) {\n    return BI_RM.charAt(n);\n  }\n\n  function intAt(s, i) {\n    var c = BI_RC[s.charCodeAt(i)];\n    return c == null ? -1 : c;\n  } // (protected) copy this to r\n\n\n  function bnpCopyTo(r) {\n    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n\n    r.t = this.t;\n    r.s = this.s;\n  } // (protected) set from integer value x, -DV <= x < DV\n\n\n  function bnpFromInt(x) {\n    this.t = 1;\n    this.s = x < 0 ? -1 : 0;\n    if (x > 0) this[0] = x;else if (x < -1) this[0] = x + this.DV;else this.t = 0;\n  } // return bigint initialized to value\n\n\n  function nbv(i) {\n    var r = nbi();\n    r.fromInt(i);\n    return r;\n  } // (protected) set from string and radix\n\n\n  function bnpFromString(s, b) {\n    var k;\n    if (b == 16) k = 4;else if (b == 8) k = 3;else if (b == 256) k = 8; // byte array\n    else if (b == 2) k = 1;else if (b == 32) k = 5;else if (b == 4) k = 2;else {\n      this.fromRadix(s, b);\n      return;\n    }\n    this.t = 0;\n    this.s = 0;\n    var i = s.length,\n        mi = false,\n        sh = 0;\n\n    while (--i >= 0) {\n      var x = k == 8 ? s[i] & 0xff : intAt(s, i);\n\n      if (x < 0) {\n        if (s.charAt(i) == \"-\") mi = true;\n        continue;\n      }\n\n      mi = false;\n      if (sh == 0) this[this.t++] = x;else if (sh + k > this.DB) {\n        this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;\n        this[this.t++] = x >> this.DB - sh;\n      } else this[this.t - 1] |= x << sh;\n      sh += k;\n      if (sh >= this.DB) sh -= this.DB;\n    }\n\n    if (k == 8 && (s[0] & 0x80) != 0) {\n      this.s = -1;\n      if (sh > 0) this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;\n    }\n\n    this.clamp();\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  } // (protected) clamp off excess high words\n\n\n  function bnpClamp() {\n    var c = this.s & this.DM;\n\n    while (this.t > 0 && this[this.t - 1] == c) --this.t;\n  } // (public) return string representation in given radix\n\n\n  function bnToString(b) {\n    if (this.s < 0) return \"-\" + this.negate().toString(b);\n    var k;\n    if (b == 16) k = 4;else if (b == 8) k = 3;else if (b == 2) k = 1;else if (b == 32) k = 5;else if (b == 4) k = 2;else return this.toRadix(b);\n    var km = (1 << k) - 1,\n        d,\n        m = false,\n        r = \"\",\n        i = this.t;\n    var p = this.DB - i * this.DB % k;\n\n    if (i-- > 0) {\n      if (p < this.DB && (d = this[i] >> p) > 0) {\n        m = true;\n        r = int2char(d);\n      }\n\n      while (i >= 0) {\n        if (p < k) {\n          d = (this[i] & (1 << p) - 1) << k - p;\n          d |= this[--i] >> (p += this.DB - k);\n        } else {\n          d = this[i] >> (p -= k) & km;\n\n          if (p <= 0) {\n            p += this.DB;\n            --i;\n          }\n        }\n\n        if (d > 0) m = true;\n        if (m) r += int2char(d);\n      }\n    }\n\n    return m ? r : \"0\";\n  } // (public) -this\n\n\n  function bnNegate() {\n    var r = nbi();\n    BigInteger.ZERO.subTo(this, r);\n    return r;\n  } // (public) |this|\n\n\n  function bnAbs() {\n    return this.s < 0 ? this.negate() : this;\n  } // (public) return + if this > a, - if this < a, 0 if equal\n\n\n  function bnCompareTo(a) {\n    var r = this.s - a.s;\n    if (r != 0) return r;\n    var i = this.t;\n    r = i - a.t;\n    if (r != 0) return this.s < 0 ? -r : r;\n\n    while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;\n\n    return 0;\n  } // returns bit length of the integer x\n\n\n  function nbits(x) {\n    var r = 1,\n        t;\n\n    if ((t = x >>> 16) != 0) {\n      x = t;\n      r += 16;\n    }\n\n    if ((t = x >> 8) != 0) {\n      x = t;\n      r += 8;\n    }\n\n    if ((t = x >> 4) != 0) {\n      x = t;\n      r += 4;\n    }\n\n    if ((t = x >> 2) != 0) {\n      x = t;\n      r += 2;\n    }\n\n    if ((t = x >> 1) != 0) {\n      x = t;\n      r += 1;\n    }\n\n    return r;\n  } // (public) return the number of bits in \"this\"\n\n\n  function bnBitLength() {\n    if (this.t <= 0) return 0;\n    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);\n  } // (protected) r = this << n*DB\n\n\n  function bnpDLShiftTo(n, r) {\n    var i;\n\n    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n\n    for (i = n - 1; i >= 0; --i) r[i] = 0;\n\n    r.t = this.t + n;\n    r.s = this.s;\n  } // (protected) r = this >> n*DB\n\n\n  function bnpDRShiftTo(n, r) {\n    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n  } // (protected) r = this << n\n\n\n  function bnpLShiftTo(n, r) {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB),\n        c = this.s << bs & this.DM,\n        i;\n\n    for (i = this.t - 1; i >= 0; --i) {\n      r[i + ds + 1] = this[i] >> cbs | c;\n      c = (this[i] & bm) << bs;\n    }\n\n    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n\n    r[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n  } // (protected) r = this >> n\n\n\n  function bnpRShiftTo(n, r) {\n    r.s = this.s;\n    var ds = Math.floor(n / this.DB);\n\n    if (ds >= this.t) {\n      r.t = 0;\n      return;\n    }\n\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << bs) - 1;\n    r[0] = this[ds] >> bs;\n\n    for (var i = ds + 1; i < this.t; ++i) {\n      r[i - ds - 1] |= (this[i] & bm) << cbs;\n      r[i - ds] = this[i] >> bs;\n    }\n\n    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n    r.t = this.t - ds;\n    r.clamp();\n  } // (protected) r = this - a\n\n\n  function bnpSubTo(a, r) {\n    var i = 0,\n        c = 0,\n        m = Math.min(a.t, this.t);\n\n    while (i < m) {\n      c += this[i] - a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n\n    if (a.t < this.t) {\n      c -= a.s;\n\n      while (i < this.t) {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n\n      c += this.s;\n    } else {\n      c += this.s;\n\n      while (i < a.t) {\n        c -= a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n\n      c -= a.s;\n    }\n\n    r.s = c < 0 ? -1 : 0;\n    if (c < -1) r[i++] = this.DV + c;else if (c > 0) r[i++] = c;\n    r.t = i;\n    r.clamp();\n  } // (protected) r = this * a, r != this,a (HAC 14.12)\n  // \"this\" should be the larger one if appropriate.\n\n\n  function bnpMultiplyTo(a, r) {\n    var x = this.abs(),\n        y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n\n    while (--i >= 0) r[i] = 0;\n\n    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n  } // (protected) r = this^2, r != this (HAC 14.16)\n\n\n  function bnpSquareTo(r) {\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n\n    while (--i >= 0) r[i] = 0;\n\n    for (i = 0; i < x.t - 1; ++i) {\n      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n\n      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {\n        r[i + x.t] -= x.DV;\n        r[i + x.t + 1] = 1;\n      }\n    }\n\n    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n    r.s = 0;\n    r.clamp();\n  } // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n  // r != q, this != m.  q or r may be null.\n\n\n  function bnpDivRemTo(m, q, r) {\n    var pm = m.abs();\n    if (pm.t <= 0) return;\n    var pt = this.abs();\n\n    if (pt.t < pm.t) {\n      if (q != null) q.fromInt(0);\n      if (r != null) this.copyTo(r);\n      return;\n    }\n\n    if (r == null) r = nbi();\n    var y = nbi(),\n        ts = this.s,\n        ms = m.s;\n    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n\n    if (nsh > 0) {\n      pm.lShiftTo(nsh, y);\n      pt.lShiftTo(nsh, r);\n    } else {\n      pm.copyTo(y);\n      pt.copyTo(r);\n    }\n\n    var ys = y.t;\n    var y0 = y[ys - 1];\n    if (y0 == 0) return;\n    var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);\n    var d1 = this.FV / yt,\n        d2 = (1 << this.F1) / yt,\n        e = 1 << this.F2;\n    var i = r.t,\n        j = i - ys,\n        t = q == null ? nbi() : q;\n    y.dlShiftTo(j, t);\n\n    if (r.compareTo(t) >= 0) {\n      r[r.t++] = 1;\n      r.subTo(t, r);\n    }\n\n    BigInteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n\n    while (y.t < ys) y[y.t++] = 0;\n\n    while (--j >= 0) {\n      // Estimate quotient digit\n      var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n\n      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {\n        // Try it out\n        y.dlShiftTo(j, t);\n        r.subTo(t, r);\n\n        while (r[i] < --qd) r.subTo(t, r);\n      }\n    }\n\n    if (q != null) {\n      r.drShiftTo(ys, q);\n      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n    }\n\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n\n    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n  } // (public) this mod a\n\n\n  function bnMod(a) {\n    var r = nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n    return r;\n  } // Modular reduction using \"classic\" algorithm\n\n\n  function Classic(m) {\n    this.m = m;\n  }\n\n  function cConvert(x) {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);else return x;\n  }\n\n  function cRevert(x) {\n    return x;\n  }\n\n  function cReduce(x) {\n    x.divRemTo(this.m, null, x);\n  }\n\n  function cMulTo(x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n\n  function cSqrTo(x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n\n  Classic.prototype.convert = cConvert;\n  Classic.prototype.revert = cRevert;\n  Classic.prototype.reduce = cReduce;\n  Classic.prototype.mulTo = cMulTo;\n  Classic.prototype.sqrTo = cSqrTo; // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n  // justification:\n  //         xy == 1 (mod m)\n  //         xy =  1+km\n  //   xy(2-xy) = (1+km)(1-km)\n  // x[y(2-xy)] = 1-k^2m^2\n  // x[y(2-xy)] == 1 (mod m^2)\n  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n\n  function bnpInvDigit() {\n    if (this.t < 1) return 0;\n    var x = this[0];\n    if ((x & 1) == 0) return 0;\n    var y = x & 3; // y == 1/x mod 2^2\n\n    y = y * (2 - (x & 0xf) * y) & 0xf; // y == 1/x mod 2^4\n\n    y = y * (2 - (x & 0xff) * y) & 0xff; // y == 1/x mod 2^8\n\n    y = y * (2 - ((x & 0xffff) * y & 0xffff)) & 0xffff; // y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\n    y = y * (2 - x * y % this.DV) % this.DV; // y == 1/x mod 2^dbits\n    // we really want the negative inverse, and -DV < y < DV\n\n    return y > 0 ? this.DV - y : -y;\n  } // Montgomery reduction\n\n\n  function Montgomery(m) {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << m.DB - 15) - 1;\n    this.mt2 = 2 * m.t;\n  } // xR mod m\n\n\n  function montConvert(x) {\n    var r = nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n    return r;\n  } // x/R mod m\n\n\n  function montRevert(x) {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  } // x = x/R mod m (HAC 14.32)\n\n\n  function montReduce(x) {\n    while (x.t <= this.mt2) // pad x so am has enough room later\n    x[x.t++] = 0;\n\n    for (var i = 0; i < this.m.t; ++i) {\n      // faster way of calculating u0 = x[i]*mp mod DV\n      var j = x[i] & 0x7fff;\n      var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM; // use am to combine the multiply-shift-add into one call\n\n      j = i + this.m.t;\n      x[j] += this.m.am(0, u0, x, i, 0, this.m.t); // propagate carry\n\n      while (x[j] >= x.DV) {\n        x[j] -= x.DV;\n        x[++j]++;\n      }\n    }\n\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  } // r = \"x^2/R mod m\"; x != r\n\n\n  function montSqrTo(x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n  } // r = \"xy/R mod m\"; x,y != r\n\n\n  function montMulTo(x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n\n  Montgomery.prototype.convert = montConvert;\n  Montgomery.prototype.revert = montRevert;\n  Montgomery.prototype.reduce = montReduce;\n  Montgomery.prototype.mulTo = montMulTo;\n  Montgomery.prototype.sqrTo = montSqrTo; // (protected) true iff this is even\n\n  function bnpIsEven() {\n    return (this.t > 0 ? this[0] & 1 : this.s) == 0;\n  } // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n\n\n  function bnpExp(e, z) {\n    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n    var r = nbi(),\n        r2 = nbi(),\n        g = z.convert(this),\n        i = nbits(e) - 1;\n    g.copyTo(r);\n\n    while (--i >= 0) {\n      z.sqrTo(r, r2);\n      if ((e & 1 << i) > 0) z.mulTo(r2, g, r);else {\n        var t = r;\n        r = r2;\n        r2 = t;\n      }\n    }\n\n    return z.revert(r);\n  } // (public) this^e % m, 0 <= e < 2^32\n\n\n  function bnModPowInt(e, m) {\n    var z;\n    if (e < 256 || m.isEven()) z = new Classic(m);else z = new Montgomery(m);\n    return this.exp(e, z);\n  } // protected\n\n\n  BigInteger.prototype.copyTo = bnpCopyTo;\n  BigInteger.prototype.fromInt = bnpFromInt;\n  BigInteger.prototype.fromString = bnpFromString;\n  BigInteger.prototype.clamp = bnpClamp;\n  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n  BigInteger.prototype.subTo = bnpSubTo;\n  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n  BigInteger.prototype.squareTo = bnpSquareTo;\n  BigInteger.prototype.divRemTo = bnpDivRemTo;\n  BigInteger.prototype.invDigit = bnpInvDigit;\n  BigInteger.prototype.isEven = bnpIsEven;\n  BigInteger.prototype.exp = bnpExp; // public\n\n  BigInteger.prototype.toString = bnToString;\n  BigInteger.prototype.negate = bnNegate;\n  BigInteger.prototype.abs = bnAbs;\n  BigInteger.prototype.compareTo = bnCompareTo;\n  BigInteger.prototype.bitLength = bnBitLength;\n  BigInteger.prototype.mod = bnMod;\n  BigInteger.prototype.modPowInt = bnModPowInt; // \"constants\"\n\n  BigInteger.ZERO = nbv(0);\n  BigInteger.ONE = nbv(1); // Copyright (c) 2005-2009  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Extended JavaScript BN functions, required for RSA private ops.\n  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n  // Version 1.2: square() API, isProbablePrime fix\n  // (public)\n\n  function bnClone() {\n    var r = nbi();\n    this.copyTo(r);\n    return r;\n  } // (public) return value as integer\n\n\n  function bnIntValue() {\n    if (this.s < 0) {\n      if (this.t == 1) return this[0] - this.DV;else if (this.t == 0) return -1;\n    } else if (this.t == 1) return this[0];else if (this.t == 0) return 0; // assumes 16 < DB < 32\n\n\n    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];\n  } // (public) return value as byte\n\n\n  function bnByteValue() {\n    return this.t == 0 ? this.s : this[0] << 24 >> 24;\n  } // (public) return value as short (assumes DB>=16)\n\n\n  function bnShortValue() {\n    return this.t == 0 ? this.s : this[0] << 16 >> 16;\n  } // (protected) return x s.t. r^x < DV\n\n\n  function bnpChunkSize(r) {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n  } // (public) 0 if this == 0, 1 if this > 0\n\n\n  function bnSigNum() {\n    if (this.s < 0) return -1;else if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0;else return 1;\n  } // (protected) convert to radix string\n\n\n  function bnpToRadix(b) {\n    if (b == null) b = 10;\n    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n    var cs = this.chunkSize(b);\n    var a = Math.pow(b, cs);\n    var d = nbv(a),\n        y = nbi(),\n        z = nbi(),\n        r = \"\";\n    this.divRemTo(d, y, z);\n\n    while (y.signum() > 0) {\n      r = (a + z.intValue()).toString(b).substr(1) + r;\n      y.divRemTo(d, y, z);\n    }\n\n    return z.intValue().toString(b) + r;\n  } // (protected) convert from radix string\n\n\n  function bnpFromRadix(s, b) {\n    this.fromInt(0);\n    if (b == null) b = 10;\n    var cs = this.chunkSize(b);\n    var d = Math.pow(b, cs),\n        mi = false,\n        j = 0,\n        w = 0;\n\n    for (var i = 0; i < s.length; ++i) {\n      var x = intAt(s, i);\n\n      if (x < 0) {\n        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n        continue;\n      }\n\n      w = b * w + x;\n\n      if (++j >= cs) {\n        this.dMultiply(d);\n        this.dAddOffset(w, 0);\n        j = 0;\n        w = 0;\n      }\n    }\n\n    if (j > 0) {\n      this.dMultiply(Math.pow(b, j));\n      this.dAddOffset(w, 0);\n    }\n\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  } // (protected) alternate constructor\n\n\n  function bnpFromNumber(a, b, c) {\n    if (\"number\" == typeof b) {\n      // new BigInteger(int,int,RNG)\n      if (a < 2) this.fromInt(1);else {\n        this.fromNumber(a, c);\n        if (!this.testBit(a - 1)) // force MSB set\n          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n\n        while (!this.isProbablePrime(b)) {\n          this.dAddOffset(2, 0);\n          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n        }\n      }\n    } else {\n      // new BigInteger(int,RNG)\n      var x = new Array(),\n          t = a & 7;\n      x.length = (a >> 3) + 1;\n      b.nextBytes(x);\n      if (t > 0) x[0] &= (1 << t) - 1;else x[0] = 0;\n      this.fromString(x, 256);\n    }\n  } // (public) convert to bigendian byte array\n\n\n  function bnToByteArray() {\n    var i = this.t,\n        r = new Array();\n    r[0] = this.s;\n    var p = this.DB - i * this.DB % 8,\n        d,\n        k = 0;\n\n    if (i-- > 0) {\n      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | this.s << this.DB - p;\n\n      while (i >= 0) {\n        if (p < 8) {\n          d = (this[i] & (1 << p) - 1) << 8 - p;\n          d |= this[--i] >> (p += this.DB - 8);\n        } else {\n          d = this[i] >> (p -= 8) & 0xff;\n\n          if (p <= 0) {\n            p += this.DB;\n            --i;\n          }\n        }\n\n        if ((d & 0x80) != 0) d |= -256;\n        if (k == 0 && (this.s & 0x80) != (d & 0x80)) ++k;\n        if (k > 0 || d != this.s) r[k++] = d;\n      }\n    }\n\n    return r;\n  }\n\n  function bnEquals(a) {\n    return this.compareTo(a) == 0;\n  }\n\n  function bnMin(a) {\n    return this.compareTo(a) < 0 ? this : a;\n  }\n\n  function bnMax(a) {\n    return this.compareTo(a) > 0 ? this : a;\n  } // (protected) r = this op a (bitwise)\n\n\n  function bnpBitwiseTo(a, op, r) {\n    var i,\n        f,\n        m = Math.min(a.t, this.t);\n\n    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n\n    if (a.t < this.t) {\n      f = a.s & this.DM;\n\n      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n\n      r.t = this.t;\n    } else {\n      f = this.s & this.DM;\n\n      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n\n      r.t = a.t;\n    }\n\n    r.s = op(this.s, a.s);\n    r.clamp();\n  } // (public) this & a\n\n\n  function op_and(x, y) {\n    return x & y;\n  }\n\n  function bnAnd(a) {\n    var r = nbi();\n    this.bitwiseTo(a, op_and, r);\n    return r;\n  } // (public) this | a\n\n\n  function op_or(x, y) {\n    return x | y;\n  }\n\n  function bnOr(a) {\n    var r = nbi();\n    this.bitwiseTo(a, op_or, r);\n    return r;\n  } // (public) this ^ a\n\n\n  function op_xor(x, y) {\n    return x ^ y;\n  }\n\n  function bnXor(a) {\n    var r = nbi();\n    this.bitwiseTo(a, op_xor, r);\n    return r;\n  } // (public) this & ~a\n\n\n  function op_andnot(x, y) {\n    return x & ~y;\n  }\n\n  function bnAndNot(a) {\n    var r = nbi();\n    this.bitwiseTo(a, op_andnot, r);\n    return r;\n  } // (public) ~this\n\n\n  function bnNot() {\n    var r = nbi();\n\n    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n  } // (public) this << n\n\n\n  function bnShiftLeft(n) {\n    var r = nbi();\n    if (n < 0) this.rShiftTo(-n, r);else this.lShiftTo(n, r);\n    return r;\n  } // (public) this >> n\n\n\n  function bnShiftRight(n) {\n    var r = nbi();\n    if (n < 0) this.lShiftTo(-n, r);else this.rShiftTo(n, r);\n    return r;\n  } // return index of lowest 1-bit in x, x < 2^31\n\n\n  function lbit(x) {\n    if (x == 0) return -1;\n    var r = 0;\n\n    if ((x & 0xffff) == 0) {\n      x >>= 16;\n      r += 16;\n    }\n\n    if ((x & 0xff) == 0) {\n      x >>= 8;\n      r += 8;\n    }\n\n    if ((x & 0xf) == 0) {\n      x >>= 4;\n      r += 4;\n    }\n\n    if ((x & 3) == 0) {\n      x >>= 2;\n      r += 2;\n    }\n\n    if ((x & 1) == 0) ++r;\n    return r;\n  } // (public) returns index of lowest 1-bit (or -1 if none)\n\n\n  function bnGetLowestSetBit() {\n    for (var i = 0; i < this.t; ++i) if (this[i] != 0) return i * this.DB + lbit(this[i]);\n\n    if (this.s < 0) return this.t * this.DB;\n    return -1;\n  } // return number of 1 bits in x\n\n\n  function cbit(x) {\n    var r = 0;\n\n    while (x != 0) {\n      x &= x - 1;\n      ++r;\n    }\n\n    return r;\n  } // (public) return number of set bits\n\n\n  function bnBitCount() {\n    var r = 0,\n        x = this.s & this.DM;\n\n    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n\n    return r;\n  } // (public) true iff nth bit is set\n\n\n  function bnTestBit(n) {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) return this.s != 0;\n    return (this[j] & 1 << n % this.DB) != 0;\n  } // (protected) this op (1<<n)\n\n\n  function bnpChangeBit(n, op) {\n    var r = BigInteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n  } // (public) this | (1<<n)\n\n\n  function bnSetBit(n) {\n    return this.changeBit(n, op_or);\n  } // (public) this & ~(1<<n)\n\n\n  function bnClearBit(n) {\n    return this.changeBit(n, op_andnot);\n  } // (public) this ^ (1<<n)\n\n\n  function bnFlipBit(n) {\n    return this.changeBit(n, op_xor);\n  } // (protected) r = this + a\n\n\n  function bnpAddTo(a, r) {\n    var i = 0,\n        c = 0,\n        m = Math.min(a.t, this.t);\n\n    while (i < m) {\n      c += this[i] + a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n\n    if (a.t < this.t) {\n      c += a.s;\n\n      while (i < this.t) {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n\n      c += this.s;\n    } else {\n      c += this.s;\n\n      while (i < a.t) {\n        c += a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n\n      c += a.s;\n    }\n\n    r.s = c < 0 ? -1 : 0;\n    if (c > 0) r[i++] = c;else if (c < -1) r[i++] = this.DV + c;\n    r.t = i;\n    r.clamp();\n  } // (public) this + a\n\n\n  function bnAdd(a) {\n    var r = nbi();\n    this.addTo(a, r);\n    return r;\n  } // (public) this - a\n\n\n  function bnSubtract(a) {\n    var r = nbi();\n    this.subTo(a, r);\n    return r;\n  } // (public) this * a\n\n\n  function bnMultiply(a) {\n    var r = nbi();\n    this.multiplyTo(a, r);\n    return r;\n  } // (public) this^2\n\n\n  function bnSquare() {\n    var r = nbi();\n    this.squareTo(r);\n    return r;\n  } // (public) this / a\n\n\n  function bnDivide(a) {\n    var r = nbi();\n    this.divRemTo(a, r, null);\n    return r;\n  } // (public) this % a\n\n\n  function bnRemainder(a) {\n    var r = nbi();\n    this.divRemTo(a, null, r);\n    return r;\n  } // (public) [this/a,this%a]\n\n\n  function bnDivideAndRemainder(a) {\n    var q = nbi(),\n        r = nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n  } // (protected) this *= n, this >= 0, 1 < n < DV\n\n\n  function bnpDMultiply(n) {\n    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n  } // (protected) this += n << w words, this >= 0\n\n\n  function bnpDAddOffset(n, w) {\n    if (n == 0) return;\n\n    while (this.t <= w) this[this.t++] = 0;\n\n    this[w] += n;\n\n    while (this[w] >= this.DV) {\n      this[w] -= this.DV;\n      if (++w >= this.t) this[this.t++] = 0;\n      ++this[w];\n    }\n  } // A \"null\" reducer\n\n\n  function NullExp() {}\n\n  function nNop(x) {\n    return x;\n  }\n\n  function nMulTo(x, y, r) {\n    x.multiplyTo(y, r);\n  }\n\n  function nSqrTo(x, r) {\n    x.squareTo(r);\n  }\n\n  NullExp.prototype.convert = nNop;\n  NullExp.prototype.revert = nNop;\n  NullExp.prototype.mulTo = nMulTo;\n  NullExp.prototype.sqrTo = nSqrTo; // (public) this^e\n\n  function bnPow(e) {\n    return this.exp(e, new NullExp());\n  } // (protected) r = lower n words of \"this * a\", a.t <= n\n  // \"this\" should be the larger one if appropriate.\n\n\n  function bnpMultiplyLowerTo(a, n, r) {\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n\n    r.t = i;\n\n    while (i > 0) r[--i] = 0;\n\n    var j;\n\n    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n\n    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n\n    r.clamp();\n  } // (protected) r = \"this * a\" without lower n words, n > 0\n  // \"this\" should be the larger one if appropriate.\n\n\n  function bnpMultiplyUpperTo(a, n, r) {\n    --n;\n    var i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n\n    while (--i >= 0) r[i] = 0;\n\n    for (i = Math.max(n - this.t, 0); i < a.t; ++i) r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n\n    r.clamp();\n    r.drShiftTo(1, r);\n  } // Barrett modular reduction\n\n\n  function Barrett(m) {\n    // setup Barrett\n    this.r2 = nbi();\n    this.q3 = nbi();\n    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n  }\n\n  function barrettConvert(x) {\n    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);else if (x.compareTo(this.m) < 0) return x;else {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n  }\n\n  function barrettRevert(x) {\n    return x;\n  } // x = x mod m (HAC 14.42)\n\n\n  function barrettReduce(x) {\n    x.drShiftTo(this.m.t - 1, this.r2);\n\n    if (x.t > this.m.t + 1) {\n      x.t = this.m.t + 1;\n      x.clamp();\n    }\n\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n\n    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n\n    x.subTo(this.r2, x);\n\n    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  } // r = x^2 mod m; x != r\n\n\n  function barrettSqrTo(x, r) {\n    x.squareTo(r);\n    this.reduce(r);\n  } // r = x*y mod m; x,y != r\n\n\n  function barrettMulTo(x, y, r) {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n\n  Barrett.prototype.convert = barrettConvert;\n  Barrett.prototype.revert = barrettRevert;\n  Barrett.prototype.reduce = barrettReduce;\n  Barrett.prototype.mulTo = barrettMulTo;\n  Barrett.prototype.sqrTo = barrettSqrTo; // (public) this^e % m (HAC 14.85)\n\n  function bnModPow(e, m) {\n    var i = e.bitLength(),\n        k,\n        r = nbv(1),\n        z;\n    if (i <= 0) return r;else if (i < 18) k = 1;else if (i < 48) k = 3;else if (i < 144) k = 4;else if (i < 768) k = 5;else k = 6;\n    if (i < 8) z = new Classic(m);else if (m.isEven()) z = new Barrett(m);else z = new Montgomery(m); // precomputation\n\n    var g = new Array(),\n        n = 3,\n        k1 = k - 1,\n        km = (1 << k) - 1;\n    g[1] = z.convert(this);\n\n    if (k > 1) {\n      var g2 = nbi();\n      z.sqrTo(g[1], g2);\n\n      while (n <= km) {\n        g[n] = nbi();\n        z.mulTo(g2, g[n - 2], g[n]);\n        n += 2;\n      }\n    }\n\n    var j = e.t - 1,\n        w,\n        is1 = true,\n        r2 = nbi(),\n        t;\n    i = nbits(e[j]) - 1;\n\n    while (j >= 0) {\n      if (i >= k1) w = e[j] >> i - k1 & km;else {\n        w = (e[j] & (1 << i + 1) - 1) << k1 - i;\n        if (j > 0) w |= e[j - 1] >> this.DB + i - k1;\n      }\n      n = k;\n\n      while ((w & 1) == 0) {\n        w >>= 1;\n        --n;\n      }\n\n      if ((i -= n) < 0) {\n        i += this.DB;\n        --j;\n      }\n\n      if (is1) {\n        // ret == 1, don't bother squaring or multiplying it\n        g[w].copyTo(r);\n        is1 = false;\n      } else {\n        while (n > 1) {\n          z.sqrTo(r, r2);\n          z.sqrTo(r2, r);\n          n -= 2;\n        }\n\n        if (n > 0) z.sqrTo(r, r2);else {\n          t = r;\n          r = r2;\n          r2 = t;\n        }\n        z.mulTo(r2, g[w], r);\n      }\n\n      while (j >= 0 && (e[j] & 1 << i) == 0) {\n        z.sqrTo(r, r2);\n        t = r;\n        r = r2;\n        r2 = t;\n\n        if (--i < 0) {\n          i = this.DB - 1;\n          --j;\n        }\n      }\n    }\n\n    return z.revert(r);\n  } // (public) gcd(this,a) (HAC 14.54)\n\n\n  function bnGCD(a) {\n    var x = this.s < 0 ? this.negate() : this.clone();\n    var y = a.s < 0 ? a.negate() : a.clone();\n\n    if (x.compareTo(y) < 0) {\n      var t = x;\n      x = y;\n      y = t;\n    }\n\n    var i = x.getLowestSetBit(),\n        g = y.getLowestSetBit();\n    if (g < 0) return x;\n    if (i < g) g = i;\n\n    if (g > 0) {\n      x.rShiftTo(g, x);\n      y.rShiftTo(g, y);\n    }\n\n    while (x.signum() > 0) {\n      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n\n      if (x.compareTo(y) >= 0) {\n        x.subTo(y, x);\n        x.rShiftTo(1, x);\n      } else {\n        y.subTo(x, y);\n        y.rShiftTo(1, y);\n      }\n    }\n\n    if (g > 0) y.lShiftTo(g, y);\n    return y;\n  } // (protected) this % n, n < 2^26\n\n\n  function bnpModInt(n) {\n    if (n <= 0) return 0;\n    var d = this.DV % n,\n        r = this.s < 0 ? n - 1 : 0;\n    if (this.t > 0) if (d == 0) r = this[0] % n;else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n    return r;\n  } // (public) 1/this % m (HAC 14.61)\n\n\n  function bnModInverse(m) {\n    var ac = m.isEven();\n    if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;\n    var u = m.clone(),\n        v = this.clone();\n    var a = nbv(1),\n        b = nbv(0),\n        c = nbv(0),\n        d = nbv(1);\n\n    while (u.signum() != 0) {\n      while (u.isEven()) {\n        u.rShiftTo(1, u);\n\n        if (ac) {\n          if (!a.isEven() || !b.isEven()) {\n            a.addTo(this, a);\n            b.subTo(m, b);\n          }\n\n          a.rShiftTo(1, a);\n        } else if (!b.isEven()) b.subTo(m, b);\n\n        b.rShiftTo(1, b);\n      }\n\n      while (v.isEven()) {\n        v.rShiftTo(1, v);\n\n        if (ac) {\n          if (!c.isEven() || !d.isEven()) {\n            c.addTo(this, c);\n            d.subTo(m, d);\n          }\n\n          c.rShiftTo(1, c);\n        } else if (!d.isEven()) d.subTo(m, d);\n\n        d.rShiftTo(1, d);\n      }\n\n      if (u.compareTo(v) >= 0) {\n        u.subTo(v, u);\n        if (ac) a.subTo(c, a);\n        b.subTo(d, b);\n      } else {\n        v.subTo(u, v);\n        if (ac) c.subTo(a, c);\n        d.subTo(b, d);\n      }\n    }\n\n    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n    if (d.compareTo(m) >= 0) return d.subtract(m);\n    if (d.signum() < 0) d.addTo(m, d);else return d;\n    if (d.signum() < 0) return d.add(m);else return d;\n  }\n\n  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1]; // (public) test primality with certainty >= 1-.5^t\n\n  function bnIsProbablePrime(t) {\n    var i,\n        x = this.abs();\n\n    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {\n      for (i = 0; i < lowprimes.length; ++i) if (x[0] == lowprimes[i]) return true;\n\n      return false;\n    }\n\n    if (x.isEven()) return false;\n    i = 1;\n\n    while (i < lowprimes.length) {\n      var m = lowprimes[i],\n          j = i + 1;\n\n      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n\n      m = x.modInt(m);\n\n      while (i < j) if (m % lowprimes[i++] == 0) return false;\n    }\n\n    return x.millerRabin(t);\n  } // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n\n\n  function bnpMillerRabin(t) {\n    var n1 = this.subtract(BigInteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) return false;\n    var r = n1.shiftRight(k);\n    t = t + 1 >> 1;\n    if (t > lowprimes.length) t = lowprimes.length;\n    var a = nbi();\n\n    for (var i = 0; i < t; ++i) {\n      //Pick bases at random, instead of starting at 2\n      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n      var y = a.modPow(r, this);\n\n      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n        var j = 1;\n\n        while (j++ < k && y.compareTo(n1) != 0) {\n          y = y.modPowInt(2, this);\n          if (y.compareTo(BigInteger.ONE) == 0) return false;\n        }\n\n        if (y.compareTo(n1) != 0) return false;\n      }\n    }\n\n    return true;\n  } // protected\n\n\n  BigInteger.prototype.chunkSize = bnpChunkSize;\n  BigInteger.prototype.toRadix = bnpToRadix;\n  BigInteger.prototype.fromRadix = bnpFromRadix;\n  BigInteger.prototype.fromNumber = bnpFromNumber;\n  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n  BigInteger.prototype.changeBit = bnpChangeBit;\n  BigInteger.prototype.addTo = bnpAddTo;\n  BigInteger.prototype.dMultiply = bnpDMultiply;\n  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n  BigInteger.prototype.modInt = bnpModInt;\n  BigInteger.prototype.millerRabin = bnpMillerRabin; // public\n\n  BigInteger.prototype.clone = bnClone;\n  BigInteger.prototype.intValue = bnIntValue;\n  BigInteger.prototype.byteValue = bnByteValue;\n  BigInteger.prototype.shortValue = bnShortValue;\n  BigInteger.prototype.signum = bnSigNum;\n  BigInteger.prototype.toByteArray = bnToByteArray;\n  BigInteger.prototype.equals = bnEquals;\n  BigInteger.prototype.min = bnMin;\n  BigInteger.prototype.max = bnMax;\n  BigInteger.prototype.and = bnAnd;\n  BigInteger.prototype.or = bnOr;\n  BigInteger.prototype.xor = bnXor;\n  BigInteger.prototype.andNot = bnAndNot;\n  BigInteger.prototype.not = bnNot;\n  BigInteger.prototype.shiftLeft = bnShiftLeft;\n  BigInteger.prototype.shiftRight = bnShiftRight;\n  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n  BigInteger.prototype.bitCount = bnBitCount;\n  BigInteger.prototype.testBit = bnTestBit;\n  BigInteger.prototype.setBit = bnSetBit;\n  BigInteger.prototype.clearBit = bnClearBit;\n  BigInteger.prototype.flipBit = bnFlipBit;\n  BigInteger.prototype.add = bnAdd;\n  BigInteger.prototype.subtract = bnSubtract;\n  BigInteger.prototype.multiply = bnMultiply;\n  BigInteger.prototype.divide = bnDivide;\n  BigInteger.prototype.remainder = bnRemainder;\n  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n  BigInteger.prototype.modPow = bnModPow;\n  BigInteger.prototype.modInverse = bnModInverse;\n  BigInteger.prototype.pow = bnPow;\n  BigInteger.prototype.gcd = bnGCD;\n  BigInteger.prototype.isProbablePrime = bnIsProbablePrime; // JSBN-specific extension\n\n  BigInteger.prototype.square = bnSquare;\n  var Int128 = BigInteger; // BigInteger interfaces not implemented in jsbn:\n  // BigInteger(int signum, byte[] magnitude)\n  // double doubleValue()\n  // float floatValue()\n  // int hashCode()\n  // long longValue()\n  // static BigInteger valueOf(long val)\n  // Helper functions to make BigInteger functions callable with two parameters\n  // as in original C# Clipper\n\n  Int128.prototype.IsNegative = function () {\n    if (this.compareTo(Int128.ZERO) == -1) return true;else return false;\n  };\n\n  Int128.op_Equality = function (val1, val2) {\n    if (val1.compareTo(val2) == 0) return true;else return false;\n  };\n\n  Int128.op_Inequality = function (val1, val2) {\n    if (val1.compareTo(val2) != 0) return true;else return false;\n  };\n\n  Int128.op_GreaterThan = function (val1, val2) {\n    if (val1.compareTo(val2) > 0) return true;else return false;\n  };\n\n  Int128.op_LessThan = function (val1, val2) {\n    if (val1.compareTo(val2) < 0) return true;else return false;\n  };\n\n  Int128.op_Addition = function (lhs, rhs) {\n    return new Int128(lhs).add(new Int128(rhs));\n  };\n\n  Int128.op_Subtraction = function (lhs, rhs) {\n    return new Int128(lhs).subtract(new Int128(rhs));\n  };\n\n  Int128.Int128Mul = function (lhs, rhs) {\n    return new Int128(lhs).multiply(new Int128(rhs));\n  };\n\n  Int128.op_Division = function (lhs, rhs) {\n    return lhs.divide(rhs);\n  };\n\n  Int128.prototype.ToDouble = function () {\n    return parseFloat(this.toString()); // This could be something faster\n  }; // end of Int128 section\n\n  /*\n  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n  else self.Int128 = Int128;\n  */\n  // ---------------------------------------------\n  // Here starts the actual Clipper library:\n  // Helper function to support Inheritance in Javascript\n\n\n  var Inherit = function (ce, ce2) {\n    var p;\n\n    if (typeof Object.getOwnPropertyNames == 'undefined') {\n      for (p in ce2.prototype) if (typeof ce.prototype[p] == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\n      for (p in ce2) if (typeof ce[p] == 'undefined') ce[p] = ce2[p];\n\n      ce.$baseCtor = ce2;\n    } else {\n      var props = Object.getOwnPropertyNames(ce2.prototype);\n\n      for (var i = 0; i < props.length; i++) if (typeof Object.getOwnPropertyDescriptor(ce.prototype, props[i]) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\n      for (p in ce2) if (typeof ce[p] == 'undefined') ce[p] = ce2[p];\n\n      ce.$baseCtor = ce2;\n    }\n  };\n\n  ClipperLib.Path = function () {\n    return [];\n  };\n\n  ClipperLib.Paths = function () {\n    return []; // Was previously [[]], but caused problems when pushed\n  }; // Preserves the calling way of original C# Clipper\n  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n\n\n  ClipperLib.DoublePoint = function () {\n    var a = arguments;\n    this.X = 0;\n    this.Y = 0; // public DoublePoint(DoublePoint dp)\n    // public DoublePoint(IntPoint ip)\n\n    if (a.length == 1) {\n      this.X = a[0].X;\n      this.Y = a[0].Y;\n    } else if (a.length == 2) {\n      this.X = a[0];\n      this.Y = a[1];\n    }\n  }; // This is internal faster function when called without arguments\n\n\n  ClipperLib.DoublePoint0 = function () {\n    this.X = 0;\n    this.Y = 0;\n  }; // This is internal faster function when called with 1 argument (dp or ip)\n\n\n  ClipperLib.DoublePoint1 = function (dp) {\n    this.X = dp.X;\n    this.Y = dp.Y;\n  }; // This is internal faster function when called with 2 arguments (x and y)\n\n\n  ClipperLib.DoublePoint2 = function (x, y) {\n    this.X = x;\n    this.Y = y;\n  }; // PolyTree & PolyNode start\n  // -------------------------------\n\n\n  ClipperLib.PolyNode = function () {\n    this.m_Parent = null;\n    this.m_polygon = new ClipperLib.Path();\n    this.m_Index = 0;\n    this.m_jointype = 0;\n    this.m_endtype = 0;\n    this.m_Childs = [];\n    this.IsOpen = false;\n  };\n\n  ClipperLib.PolyNode.prototype.IsHoleNode = function () {\n    var result = true;\n    var node = this.m_Parent;\n\n    while (node !== null) {\n      result = !result;\n      node = node.m_Parent;\n    }\n\n    return result;\n  };\n\n  ClipperLib.PolyNode.prototype.ChildCount = function () {\n    return this.m_Childs.length;\n  };\n\n  ClipperLib.PolyNode.prototype.Contour = function () {\n    return this.m_polygon;\n  };\n\n  ClipperLib.PolyNode.prototype.AddChild = function (Child) {\n    var cnt = this.m_Childs.length;\n    this.m_Childs.push(Child);\n    Child.m_Parent = this;\n    Child.m_Index = cnt;\n  };\n\n  ClipperLib.PolyNode.prototype.GetNext = function () {\n    if (this.m_Childs.length > 0) return this.m_Childs[0];else return this.GetNextSiblingUp();\n  };\n\n  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function () {\n    if (this.m_Parent === null) return null;else if (this.m_Index == this.m_Parent.m_Childs.length - 1) return this.m_Parent.GetNextSiblingUp();else return this.m_Parent.m_Childs[this.m_Index + 1];\n  };\n\n  ClipperLib.PolyNode.prototype.Childs = function () {\n    return this.m_Childs;\n  };\n\n  ClipperLib.PolyNode.prototype.Parent = function () {\n    return this.m_Parent;\n  };\n\n  ClipperLib.PolyNode.prototype.IsHole = function () {\n    return this.IsHoleNode();\n  }; // PolyTree : PolyNode\n\n\n  ClipperLib.PolyTree = function () {\n    this.m_AllPolys = [];\n    ClipperLib.PolyNode.call(this);\n  };\n\n  ClipperLib.PolyTree.prototype.Clear = function () {\n    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++) this.m_AllPolys[i] = null;\n\n    this.m_AllPolys.length = 0;\n    this.m_Childs.length = 0;\n  };\n\n  ClipperLib.PolyTree.prototype.GetFirst = function () {\n    if (this.m_Childs.length > 0) return this.m_Childs[0];else return null;\n  };\n\n  ClipperLib.PolyTree.prototype.Total = function () {\n    var result = this.m_AllPolys.length; //with negative offsets, ignore the hidden outer polygon ...\n\n    if (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n    return result;\n  };\n\n  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode); // -------------------------------\n  // PolyTree & PolyNode end\n\n  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a) {\n    return Math.abs(a);\n  };\n\n  ClipperLib.Math_Max_Int32_Int32 = function (a, b) {\n    return Math.max(a, b);\n  };\n  /*\n  -----------------------------------\n  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n  -----------------------------------\n  */\n\n\n  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a) {\n    return a | 0;\n  };else ClipperLib.Cast_Int32 = function (a) {\n    // eg. browser.chrome || browser.chromium || browser.firefox\n    return ~~a;\n  };\n  /*\n  --------------------------\n  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n  Chrome: bitwise_not_floor\n  Firefox17: toInteger (typeof test)\n  IE9: bitwise_or_floor\n  IE7 and IE8: to_parseint\n  Chromium: to_floor_or_ceil\n  Firefox3: to_floor_or_ceil\n  Firefox15: to_floor_or_ceil\n  Opera: to_floor_or_ceil\n  Safari: to_floor_or_ceil\n  --------------------------\n  */\n\n  if (browser.chrome) ClipperLib.Cast_Int64 = function (a) {\n    if (a < -2147483648 || a > 2147483647) return a < 0 ? Math.ceil(a) : Math.floor(a);else return ~~a;\n  };else if (browser.firefox && typeof Number.toInteger == \"function\") ClipperLib.Cast_Int64 = function (a) {\n    return Number.toInteger(a);\n  };else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a) {\n    return parseInt(a, 10);\n  };else if (browser.msie) ClipperLib.Cast_Int64 = function (a) {\n    if (a < -2147483648 || a > 2147483647) return a < 0 ? Math.ceil(a) : Math.floor(a);\n    return a | 0;\n  }; // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n  else ClipperLib.Cast_Int64 = function (a) {\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  };\n\n  ClipperLib.Clear = function (a) {\n    a.length = 0;\n  }; //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n\n\n  ClipperLib.PI = 3.141592653589793;\n  ClipperLib.PI2 = 2 * 3.141592653589793;\n\n  ClipperLib.IntPoint = function () {\n    var a = arguments,\n        alen = a.length;\n    this.X = 0;\n    this.Y = 0;\n\n    if (use_xyz) {\n      this.Z = 0;\n\n      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n        {\n          this.X = a[0];\n          this.Y = a[1];\n          this.Z = a[2];\n        } else if (alen == 2) // public IntPoint(cInt x, cInt y)\n        {\n          this.X = a[0];\n          this.Y = a[1];\n          this.Z = 0;\n        } else if (alen == 1) {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n          {\n            var dp = a[0];\n            this.X = ClipperLib.Clipper.Round(dp.X);\n            this.Y = ClipperLib.Clipper.Round(dp.Y);\n            this.Z = 0;\n          } else // public IntPoint(IntPoint pt)\n          {\n            var pt = a[0];\n            if (typeof pt.Z == \"undefined\") pt.Z = 0;\n            this.X = pt.X;\n            this.Y = pt.Y;\n            this.Z = pt.Z;\n          }\n      } else // public IntPoint()\n        {\n          this.X = 0;\n          this.Y = 0;\n          this.Z = 0;\n        }\n    } else // if (!use_xyz)\n      {\n        if (alen == 2) // public IntPoint(cInt X, cInt Y)\n          {\n            this.X = a[0];\n            this.Y = a[1];\n          } else if (alen == 1) {\n          if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n            {\n              var dp = a[0];\n              this.X = ClipperLib.Clipper.Round(dp.X);\n              this.Y = ClipperLib.Clipper.Round(dp.Y);\n            } else // public IntPoint(IntPoint pt)\n            {\n              var pt = a[0];\n              this.X = pt.X;\n              this.Y = pt.Y;\n            }\n        } else // public IntPoint(IntPoint pt)\n          {\n            this.X = 0;\n            this.Y = 0;\n          }\n      }\n  };\n\n  ClipperLib.IntPoint.op_Equality = function (a, b) {\n    //return a == b;\n    return a.X == b.X && a.Y == b.Y;\n  };\n\n  ClipperLib.IntPoint.op_Inequality = function (a, b) {\n    //return a != b;\n    return a.X != b.X || a.Y != b.Y;\n  };\n  /*\n  ClipperLib.IntPoint.prototype.Equals = function (obj)\n  {\n    if (obj === null)\n        return false;\n    if (obj instanceof ClipperLib.IntPoint)\n    {\n        var a = Cast(obj, ClipperLib.IntPoint);\n        return (this.X == a.X) && (this.Y == a.Y);\n    }\n    else\n        return false;\n  };\n  */\n\n\n  if (use_xyz) {\n    ClipperLib.IntPoint0 = function () {\n      this.X = 0;\n      this.Y = 0;\n      this.Z = 0;\n    };\n\n    ClipperLib.IntPoint1 = function (pt) {\n      this.X = pt.X;\n      this.Y = pt.Y;\n      this.Z = pt.Z;\n    };\n\n    ClipperLib.IntPoint1dp = function (dp) {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n      this.Z = 0;\n    };\n\n    ClipperLib.IntPoint2 = function (x, y) {\n      this.X = x;\n      this.Y = y;\n      this.Z = 0;\n    };\n\n    ClipperLib.IntPoint3 = function (x, y, z) {\n      this.X = x;\n      this.Y = y;\n      this.Z = z;\n    };\n  } else // if (!use_xyz)\n    {\n      ClipperLib.IntPoint0 = function () {\n        this.X = 0;\n        this.Y = 0;\n      };\n\n      ClipperLib.IntPoint1 = function (pt) {\n        this.X = pt.X;\n        this.Y = pt.Y;\n      };\n\n      ClipperLib.IntPoint1dp = function (dp) {\n        this.X = ClipperLib.Clipper.Round(dp.X);\n        this.Y = ClipperLib.Clipper.Round(dp.Y);\n      };\n\n      ClipperLib.IntPoint2 = function (x, y) {\n        this.X = x;\n        this.Y = y;\n      };\n    }\n\n  ClipperLib.IntRect = function () {\n    var a = arguments,\n        alen = a.length;\n\n    if (alen == 4) // function (l, t, r, b)\n      {\n        this.left = a[0];\n        this.top = a[1];\n        this.right = a[2];\n        this.bottom = a[3];\n      } else if (alen == 1) // function (ir)\n      {\n        this.left = ir.left;\n        this.top = ir.top;\n        this.right = ir.right;\n        this.bottom = ir.bottom;\n      } else // function ()\n      {\n        this.left = 0;\n        this.top = 0;\n        this.right = 0;\n        this.bottom = 0;\n      }\n  };\n\n  ClipperLib.IntRect0 = function () {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  };\n\n  ClipperLib.IntRect1 = function (ir) {\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  };\n\n  ClipperLib.IntRect4 = function (l, t, r, b) {\n    this.left = l;\n    this.top = t;\n    this.right = r;\n    this.bottom = b;\n  };\n\n  ClipperLib.ClipType = {\n    ctIntersection: 0,\n    ctUnion: 1,\n    ctDifference: 2,\n    ctXor: 3\n  };\n  ClipperLib.PolyType = {\n    ptSubject: 0,\n    ptClip: 1\n  };\n  ClipperLib.PolyFillType = {\n    pftEvenOdd: 0,\n    pftNonZero: 1,\n    pftPositive: 2,\n    pftNegative: 3\n  };\n  ClipperLib.JoinType = {\n    jtSquare: 0,\n    jtRound: 1,\n    jtMiter: 2\n  };\n  ClipperLib.EndType = {\n    etOpenSquare: 0,\n    etOpenRound: 1,\n    etOpenButt: 2,\n    etClosedLine: 3,\n    etClosedPolygon: 4\n  };\n  ClipperLib.EdgeSide = {\n    esLeft: 0,\n    esRight: 1\n  };\n  ClipperLib.Direction = {\n    dRightToLeft: 0,\n    dLeftToRight: 1\n  };\n\n  ClipperLib.TEdge = function () {\n    this.Bot = new ClipperLib.IntPoint();\n    this.Curr = new ClipperLib.IntPoint();\n    this.Top = new ClipperLib.IntPoint();\n    this.Delta = new ClipperLib.IntPoint();\n    this.Dx = 0;\n    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n    this.Side = ClipperLib.EdgeSide.esLeft;\n    this.WindDelta = 0;\n    this.WindCnt = 0;\n    this.WindCnt2 = 0;\n    this.OutIdx = 0;\n    this.Next = null;\n    this.Prev = null;\n    this.NextInLML = null;\n    this.NextInAEL = null;\n    this.PrevInAEL = null;\n    this.NextInSEL = null;\n    this.PrevInSEL = null;\n  };\n\n  ClipperLib.IntersectNode = function () {\n    this.Edge1 = null;\n    this.Edge2 = null;\n    this.Pt = new ClipperLib.IntPoint();\n  };\n\n  ClipperLib.MyIntersectNodeSort = function () {};\n\n  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2) {\n    var i = node2.Pt.Y - node1.Pt.Y;\n    if (i > 0) return 1;else if (i < 0) return -1;else return 0;\n  };\n\n  ClipperLib.LocalMinima = function () {\n    this.Y = 0;\n    this.LeftBound = null;\n    this.RightBound = null;\n    this.Next = null;\n  };\n\n  ClipperLib.Scanbeam = function () {\n    this.Y = 0;\n    this.Next = null;\n  };\n\n  ClipperLib.OutRec = function () {\n    this.Idx = 0;\n    this.IsHole = false;\n    this.IsOpen = false;\n    this.FirstLeft = null;\n    this.Pts = null;\n    this.BottomPt = null;\n    this.PolyNode = null;\n  };\n\n  ClipperLib.OutPt = function () {\n    this.Idx = 0;\n    this.Pt = new ClipperLib.IntPoint();\n    this.Next = null;\n    this.Prev = null;\n  };\n\n  ClipperLib.Join = function () {\n    this.OutPt1 = null;\n    this.OutPt2 = null;\n    this.OffPt = new ClipperLib.IntPoint();\n  };\n\n  ClipperLib.ClipperBase = function () {\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_edges = new Array();\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n    this.PreserveCollinear = false;\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  }; // Ranges are in original C# too high for Javascript (in current state 2013 september):\n  // protected const double horizontal = -3.4E+38;\n  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n  // So had to adjust them to more suitable for Javascript.\n  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n\n\n  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n\n  ClipperLib.ClipperBase.Skip = -2;\n  ClipperLib.ClipperBase.Unassigned = -1;\n  ClipperLib.ClipperBase.tolerance = 1E-20;\n\n  if (use_int32) {\n    ClipperLib.ClipperBase.loRange = 0x7FFF;\n    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n  } else {\n    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n\n    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n  }\n\n  ClipperLib.ClipperBase.near_zero = function (val) {\n    return val > -ClipperLib.ClipperBase.tolerance && val < ClipperLib.ClipperBase.tolerance;\n  };\n\n  ClipperLib.ClipperBase.IsHorizontal = function (e) {\n    return e.Delta.Y === 0;\n  };\n\n  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp) {\n    var pp2 = pp;\n\n    do {\n      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt)) return true;\n      pp2 = pp2.Next;\n    } while (pp2 != pp);\n\n    return false;\n  };\n\n  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange) {\n    if (UseFullRange) return pt.X == linePt1.X && pt.Y == linePt1.Y || pt.X == linePt2.X && pt.Y == linePt2.Y || pt.X > linePt1.X == pt.X < linePt2.X && pt.Y > linePt1.Y == pt.Y < linePt2.Y && Int128.op_Equality(Int128.Int128Mul(pt.X - linePt1.X, linePt2.Y - linePt1.Y), Int128.Int128Mul(linePt2.X - linePt1.X, pt.Y - linePt1.Y));else return pt.X == linePt1.X && pt.Y == linePt1.Y || pt.X == linePt2.X && pt.Y == linePt2.Y || pt.X > linePt1.X == pt.X < linePt2.X && pt.Y > linePt1.Y == pt.Y < linePt2.Y && (pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y);\n  };\n\n  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange) {\n    var pp2 = pp;\n\n    while (true) {\n      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange)) return true;\n      pp2 = pp2.Next;\n      if (pp2 == pp) break;\n    }\n\n    return false;\n  };\n\n  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function () {\n    var a = arguments,\n        alen = a.length;\n    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n\n    if (alen == 3) // function (e1, e2, UseFullRange)\n      {\n        e1 = a[0];\n        e2 = a[1];\n        UseFullRange = a[2];\n        if (UseFullRange) return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));else return ClipperLib.Cast_Int64(e1.Delta.Y * e2.Delta.X) == ClipperLib.Cast_Int64(e1.Delta.X * e2.Delta.Y);\n      } else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n      {\n        pt1 = a[0];\n        pt2 = a[1];\n        pt3 = a[2];\n        UseFullRange = a[3];\n        if (UseFullRange) return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));else return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n      } else // function (pt1, pt2, pt3, pt4, UseFullRange)\n      {\n        pt1 = a[0];\n        pt2 = a[1];\n        pt3 = a[2];\n        pt4 = a[3];\n        UseFullRange = a[4];\n        if (UseFullRange) return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));else return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n      }\n  };\n\n  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange) {\n    if (UseFullRange) return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));else return ClipperLib.Cast_Int64(e1.Delta.Y * e2.Delta.X) == ClipperLib.Cast_Int64(e1.Delta.X * e2.Delta.Y);\n  };\n\n  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange) {\n    if (UseFullRange) return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));else return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n  };\n\n  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange) {\n    if (UseFullRange) return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));else return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n  };\n\n  ClipperLib.ClipperBase.prototype.Clear = function () {\n    this.DisposeLocalMinimaList();\n\n    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i) {\n      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j) this.m_edges[i][j] = null;\n\n      ClipperLib.Clear(this.m_edges[i]);\n    }\n\n    ClipperLib.Clear(this.m_edges);\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n\n  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function () {\n    while (this.m_MinimaList !== null) {\n      var tmpLm = this.m_MinimaList.Next;\n      this.m_MinimaList = null;\n      this.m_MinimaList = tmpLm;\n    }\n\n    this.m_CurrentLM = null;\n  };\n\n  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange) {\n    if (useFullRange.Value) {\n      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange) ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n    } else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange) {\n      useFullRange.Value = true;\n      this.RangeTest(Pt, useFullRange);\n    }\n  };\n\n  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt) {\n    e.Next = eNext;\n    e.Prev = ePrev; //e.Curr = pt;\n\n    e.Curr.X = pt.X;\n    e.Curr.Y = pt.Y;\n    e.OutIdx = -1;\n  };\n\n  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType) {\n    if (e.Curr.Y >= e.Next.Curr.Y) {\n      //e.Bot = e.Curr;\n      e.Bot.X = e.Curr.X;\n      e.Bot.Y = e.Curr.Y; //e.Top = e.Next.Curr;\n\n      e.Top.X = e.Next.Curr.X;\n      e.Top.Y = e.Next.Curr.Y;\n    } else {\n      //e.Top = e.Curr;\n      e.Top.X = e.Curr.X;\n      e.Top.Y = e.Curr.Y; //e.Bot = e.Next.Curr;\n\n      e.Bot.X = e.Next.Curr.X;\n      e.Bot.Y = e.Next.Curr.Y;\n    }\n\n    this.SetDx(e);\n    e.PolyTyp = polyType;\n  };\n\n  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E) {\n    var E2;\n\n    for (;;) {\n      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top)) E = E.Next;\n\n      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal) break;\n\n      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n\n      E2 = E;\n\n      while (E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n\n      if (E.Top.Y == E.Prev.Bot.Y) continue; //ie just an intermediate horz.\n\n      if (E2.Prev.Bot.X < E.Bot.X) E = E2;\n      break;\n    }\n\n    return E;\n  };\n\n  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward) {\n    var EStart;\n    var Result = E;\n    var Horz;\n\n    if (Result.OutIdx == ClipperLib.ClipperBase.Skip) {\n      //check if there are edges beyond the skip edge in the bound and if so\n      //create another LocMin and calling ProcessBound once more ...\n      E = Result;\n\n      if (LeftBoundIsForward) {\n        while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n\n        while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n      } else {\n        while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n\n        while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n      }\n\n      if (E == Result) {\n        if (LeftBoundIsForward) Result = E.Next;else Result = E.Prev;\n      } else {\n        //there are more edges in the bound beyond result starting with E\n        if (LeftBoundIsForward) E = Result.Next;else E = Result.Prev;\n        var locMin = new ClipperLib.LocalMinima();\n        locMin.Next = null;\n        locMin.Y = E.Bot.Y;\n        locMin.LeftBound = null;\n        locMin.RightBound = E;\n        E.WindDelta = 0;\n        Result = this.ProcessBound(E, LeftBoundIsForward);\n        this.InsertLocalMinima(locMin);\n      }\n\n      return Result;\n    }\n\n    if (E.Dx == ClipperLib.ClipperBase.horizontal) {\n      //We need to be careful with open paths because this may not be a\n      //true local minima (ie E may be following a skip edge).\n      //Also, consecutive horz. edges may start heading left before going right.\n      if (LeftBoundIsForward) EStart = E.Prev;else EStart = E.Next;\n\n      if (EStart.OutIdx != ClipperLib.ClipperBase.Skip) {\n        if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n          {\n            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X) this.ReverseHorizontal(E);\n          } else if (EStart.Bot.X != E.Bot.X) this.ReverseHorizontal(E);\n      }\n    }\n\n    EStart = E;\n\n    if (LeftBoundIsForward) {\n      while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip) Result = Result.Next;\n\n      if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip) {\n        //nb: at the top of a bound, horizontals are added to the bound\n        //only when the preceding edge attaches to the horizontal's left vertex\n        //unless a Skip edge is encountered when that becomes the top divide\n        Horz = Result;\n\n        while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal) Horz = Horz.Prev;\n\n        if (Horz.Prev.Top.X == Result.Next.Top.X) {\n          if (!LeftBoundIsForward) Result = Horz.Prev;\n        } else if (Horz.Prev.Top.X > Result.Next.Top.X) Result = Horz.Prev;\n      }\n\n      while (E != Result) {\n        E.NextInLML = E.Next;\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X) this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n\n      if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X) this.ReverseHorizontal(E);\n      Result = Result.Next; //move to the edge just beyond current bound\n    } else {\n      while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip) Result = Result.Prev;\n\n      if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip) {\n        Horz = Result;\n\n        while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal) Horz = Horz.Next;\n\n        if (Horz.Next.Top.X == Result.Prev.Top.X) {\n          if (!LeftBoundIsForward) Result = Horz.Next;\n        } else if (Horz.Next.Top.X > Result.Prev.Top.X) Result = Horz.Next;\n      }\n\n      while (E != Result) {\n        E.NextInLML = E.Prev;\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X) this.ReverseHorizontal(E);\n        E = E.Prev;\n      }\n\n      if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X) this.ReverseHorizontal(E);\n      Result = Result.Prev; //move to the edge just beyond current bound\n    }\n\n    return Result;\n  };\n\n  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed) {\n    if (use_lines) {\n      if (!Closed && polyType == ClipperLib.PolyType.ptClip) ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n    } else {\n      if (!Closed) ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n    }\n\n    var highI = pg.length - 1;\n    if (Closed) while (highI > 0 && ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])) --highI;\n\n    while (highI > 0 && ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])) --highI;\n\n    if (Closed && highI < 2 || !Closed && highI < 1) return false; //create a new edge array ...\n\n    var edges = new Array();\n\n    for (var i = 0; i <= highI; i++) edges.push(new ClipperLib.TEdge());\n\n    var IsFlat = true; //1. Basic (first) edge initialization ...\n    //edges[1].Curr = pg[1];\n\n    edges[1].Curr.X = pg[1].X;\n    edges[1].Curr.Y = pg[1].Y;\n    var $1 = {\n      Value: this.m_UseFullRange\n    };\n    this.RangeTest(pg[0], $1);\n    this.m_UseFullRange = $1.Value;\n    $1.Value = this.m_UseFullRange;\n    this.RangeTest(pg[highI], $1);\n    this.m_UseFullRange = $1.Value;\n    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n\n    for (var i = highI - 1; i >= 1; --i) {\n      $1.Value = this.m_UseFullRange;\n      this.RangeTest(pg[i], $1);\n      this.m_UseFullRange = $1.Value;\n      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n    }\n\n    var eStart = edges[0]; //2. Remove duplicate vertices, and (when closed) collinear edges ...\n\n    var E = eStart,\n        eLoopStop = eStart;\n\n    for (;;) {\n      //console.log(E.Next, eStart);\n      //nb: allows matching start and end points when not Closed ...\n      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart)) {\n        if (E == E.Next) break;\n        if (E == eStart) eStart = E.Next;\n        E = this.RemoveEdge(E);\n        eLoopStop = E;\n        continue;\n      }\n\n      if (E.Prev == E.Next) break;else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr))) {\n        //Collinear edges are allowed for open paths but in closed paths\n        //the default is to merge adjacent collinear edges into a single edge.\n        //However, if the PreserveCollinear property is enabled, only overlapping\n        //collinear edges (ie spikes) will be removed from closed paths.\n        if (E == eStart) eStart = E.Next;\n        E = this.RemoveEdge(E);\n        E = E.Prev;\n        eLoopStop = E;\n        continue;\n      }\n      E = E.Next;\n      if (E == eLoopStop || !Closed && E.Next == eStart) break;\n    }\n\n    if (!Closed && E == E.Next || Closed && E.Prev == E.Next) return false;\n\n    if (!Closed) {\n      this.m_HasOpenPaths = true;\n      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n    } //3. Do second stage of edge initialization ...\n\n\n    E = eStart;\n\n    do {\n      this.InitEdge2(E, polyType);\n      E = E.Next;\n      if (IsFlat && E.Curr.Y != eStart.Curr.Y) IsFlat = false;\n    } while (E != eStart); //4. Finally, add edge bounds to LocalMinima list ...\n    //Totally flat paths must be handled differently when adding them\n    //to LocalMinima list to avoid endless loops etc ...\n\n\n    if (IsFlat) {\n      if (Closed) return false;\n      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n      if (E.Prev.Bot.X < E.Prev.Top.X) this.ReverseHorizontal(E.Prev);\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      locMin.RightBound.WindDelta = 0;\n\n      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip) {\n        E.NextInLML = E.Next;\n        if (E.Bot.X != E.Prev.Top.X) this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n\n      this.InsertLocalMinima(locMin);\n      this.m_edges.push(edges);\n      return true;\n    }\n\n    this.m_edges.push(edges);\n    var leftBoundIsForward;\n    var EMin = null; //workaround to avoid an endless loop in the while loop below when\n    //open paths have matching start and end points ...\n\n    if (ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top)) E = E.Next;\n\n    for (;;) {\n      E = this.FindNextLocMin(E);\n      if (E == EMin) break;else if (EMin == null) EMin = E; //E and E.Prev now share a local minima (left aligned if horizontal).\n      //Compare their slopes to find which starts which bound ...\n\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n\n      if (E.Dx < E.Prev.Dx) {\n        locMin.LeftBound = E.Prev;\n        locMin.RightBound = E;\n        leftBoundIsForward = false; //Q.nextInLML = Q.prev\n      } else {\n        locMin.LeftBound = E;\n        locMin.RightBound = E.Prev;\n        leftBoundIsForward = true; //Q.nextInLML = Q.next\n      }\n\n      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      if (!Closed) locMin.LeftBound.WindDelta = 0;else if (locMin.LeftBound.Next == locMin.RightBound) locMin.LeftBound.WindDelta = -1;else locMin.LeftBound.WindDelta = 1;\n      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n      if (E.OutIdx == ClipperLib.ClipperBase.Skip) E = this.ProcessBound(E, leftBoundIsForward);\n      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip) locMin.LeftBound = null;else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip) locMin.RightBound = null;\n      this.InsertLocalMinima(locMin);\n      if (!leftBoundIsForward) E = E2;\n    }\n\n    return true;\n  };\n\n  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed) {\n    //  console.log(\"-------------------------------------------\");\n    //  console.log(JSON.stringify(ppg));\n    var result = false;\n\n    for (var i = 0, ilen = ppg.length; i < ilen; ++i) if (this.AddPath(ppg[i], polyType, closed)) result = true;\n\n    return result;\n  }; //------------------------------------------------------------------------------\n\n\n  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3) {\n    if (ClipperLib.IntPoint.op_Equality(pt1, pt3) || ClipperLib.IntPoint.op_Equality(pt1, pt2) || ClipperLib.IntPoint.op_Equality(pt3, pt2)) //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n      return false;else if (pt1.X != pt3.X) return pt2.X > pt1.X == pt2.X < pt3.X;else return pt2.Y > pt1.Y == pt2.Y < pt3.Y;\n  };\n\n  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e) {\n    //removes e from double_linked_list (but without removing from memory)\n    e.Prev.Next = e.Next;\n    e.Next.Prev = e.Prev;\n    var result = e.Next;\n    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n\n    return result;\n  };\n\n  ClipperLib.ClipperBase.prototype.SetDx = function (e) {\n    e.Delta.X = e.Top.X - e.Bot.X;\n    e.Delta.Y = e.Top.Y - e.Bot.Y;\n    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;else e.Dx = e.Delta.X / e.Delta.Y;\n  };\n\n  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm) {\n    if (this.m_MinimaList === null) {\n      this.m_MinimaList = newLm;\n    } else if (newLm.Y >= this.m_MinimaList.Y) {\n      newLm.Next = this.m_MinimaList;\n      this.m_MinimaList = newLm;\n    } else {\n      var tmpLm = this.m_MinimaList;\n\n      while (tmpLm.Next !== null && newLm.Y < tmpLm.Next.Y) tmpLm = tmpLm.Next;\n\n      newLm.Next = tmpLm.Next;\n      tmpLm.Next = newLm;\n    }\n  };\n\n  ClipperLib.ClipperBase.prototype.PopLocalMinima = function () {\n    if (this.m_CurrentLM === null) return;\n    this.m_CurrentLM = this.m_CurrentLM.Next;\n  };\n\n  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e) {\n    //swap horizontal edges' top and bottom x's so they follow the natural\n    //progression of the bounds - ie so their xbots will align with the\n    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n    var tmp = e.Top.X;\n    e.Top.X = e.Bot.X;\n    e.Bot.X = tmp;\n\n    if (use_xyz) {\n      tmp = e.Top.Z;\n      e.Top.Z = e.Bot.Z;\n      e.Bot.Z = tmp;\n    }\n  };\n\n  ClipperLib.ClipperBase.prototype.Reset = function () {\n    this.m_CurrentLM = this.m_MinimaList;\n    if (this.m_CurrentLM == null) return; //ie nothing to process\n    //reset all edges ...\n\n    var lm = this.m_MinimaList;\n\n    while (lm != null) {\n      var e = lm.LeftBound;\n\n      if (e != null) {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esLeft;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n\n      e = lm.RightBound;\n\n      if (e != null) {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esRight;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n\n      lm = lm.Next;\n    }\n  };\n\n  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n  {\n    if (typeof InitOptions == \"undefined\") InitOptions = 0;\n    this.m_PolyOuts = null;\n    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = null;\n    this.m_IntersectNodeComparer = null;\n    this.m_ExecuteLocked = false;\n    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_Joins = null;\n    this.m_GhostJoins = null;\n    this.m_UsingPolyTree = false;\n    this.ReverseSolution = false;\n    this.StrictlySimple = false;\n    ClipperLib.ClipperBase.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = new Array();\n    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n    this.m_ExecuteLocked = false;\n    this.m_UsingPolyTree = false;\n    this.m_PolyOuts = new Array();\n    this.m_Joins = new Array();\n    this.m_GhostJoins = new Array();\n    this.ReverseSolution = (1 & InitOptions) !== 0;\n    this.StrictlySimple = (2 & InitOptions) !== 0;\n    this.PreserveCollinear = (4 & InitOptions) !== 0;\n\n    if (use_xyz) {\n      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n    }\n  };\n\n  ClipperLib.Clipper.ioReverseSolution = 1;\n  ClipperLib.Clipper.ioStrictlySimple = 2;\n  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\n  ClipperLib.Clipper.prototype.Clear = function () {\n    if (this.m_edges.length === 0) return; //avoids problems with ClipperBase destructor\n\n    this.DisposeAllPolyPts();\n    ClipperLib.ClipperBase.prototype.Clear.call(this);\n  };\n\n  ClipperLib.Clipper.prototype.DisposeScanbeamList = function () {\n    while (this.m_Scanbeam !== null) {\n      var sb2 = this.m_Scanbeam.Next;\n      this.m_Scanbeam = null;\n      this.m_Scanbeam = sb2;\n    }\n  };\n\n  ClipperLib.Clipper.prototype.Reset = function () {\n    ClipperLib.ClipperBase.prototype.Reset.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    var lm = this.m_MinimaList;\n\n    while (lm !== null) {\n      this.InsertScanbeam(lm.Y);\n      lm = lm.Next;\n    }\n  };\n\n  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y) {\n    if (this.m_Scanbeam === null) {\n      this.m_Scanbeam = new ClipperLib.Scanbeam();\n      this.m_Scanbeam.Next = null;\n      this.m_Scanbeam.Y = Y;\n    } else if (Y > this.m_Scanbeam.Y) {\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = this.m_Scanbeam;\n      this.m_Scanbeam = newSb;\n    } else {\n      var sb2 = this.m_Scanbeam;\n\n      while (sb2.Next !== null && Y <= sb2.Next.Y) sb2 = sb2.Next;\n\n      if (Y == sb2.Y) return; //ie ignores duplicates\n\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = sb2.Next;\n      sb2.Next = newSb;\n    }\n  }; // ************************************\n\n\n  ClipperLib.Clipper.prototype.Execute = function () {\n    var a = arguments,\n        alen = a.length,\n        ispolytree = a[1] instanceof ClipperLib.PolyTree;\n\n    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n      {\n        var clipType = a[0],\n            solution = a[1],\n            subjFillType = a[2],\n            clipFillType = a[3];\n        if (this.m_ExecuteLocked) return false;\n        if (this.m_HasOpenPaths) ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n        this.m_ExecuteLocked = true;\n        ClipperLib.Clear(solution);\n        this.m_SubjFillType = subjFillType;\n        this.m_ClipFillType = clipFillType;\n        this.m_ClipType = clipType;\n        this.m_UsingPolyTree = false;\n\n        try {\n          var succeeded = this.ExecuteInternal(); //build the return polygons ...\n\n          if (succeeded) this.BuildResult(solution);\n        } finally {\n          this.DisposeAllPolyPts();\n          this.m_ExecuteLocked = false;\n        }\n\n        return succeeded;\n      } else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n      {\n        var clipType = a[0],\n            polytree = a[1],\n            subjFillType = a[2],\n            clipFillType = a[3];\n        if (this.m_ExecuteLocked) return false;\n        this.m_ExecuteLocked = true;\n        this.m_SubjFillType = subjFillType;\n        this.m_ClipFillType = clipFillType;\n        this.m_ClipType = clipType;\n        this.m_UsingPolyTree = true;\n\n        try {\n          var succeeded = this.ExecuteInternal(); //build the return polygons ...\n\n          if (succeeded) this.BuildResult2(polytree);\n        } finally {\n          this.DisposeAllPolyPts();\n          this.m_ExecuteLocked = false;\n        }\n\n        return succeeded;\n      } else if (alen == 2 && !ispolytree) // function (clipType, solution)\n      {\n        var clipType = a[0],\n            solution = a[1];\n        return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n      } else if (alen == 2 && ispolytree) // function (clipType, polytree)\n      {\n        var clipType = a[0],\n            polytree = a[1];\n        return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n      }\n  };\n\n  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec) {\n    //skip if an outermost polygon or\n    //already already points to the correct FirstLeft ...\n    if (outRec.FirstLeft === null || outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null) return;\n    var orfl = outRec.FirstLeft;\n\n    while (orfl !== null && (orfl.IsHole == outRec.IsHole || orfl.Pts === null)) orfl = orfl.FirstLeft;\n\n    outRec.FirstLeft = orfl;\n  };\n\n  ClipperLib.Clipper.prototype.ExecuteInternal = function () {\n    try {\n      this.Reset();\n      if (this.m_CurrentLM === null) return false;\n      var botY = this.PopScanbeam();\n\n      do {\n        this.InsertLocalMinimaIntoAEL(botY);\n        ClipperLib.Clear(this.m_GhostJoins);\n        this.ProcessHorizontals(false);\n        if (this.m_Scanbeam === null) break;\n        var topY = this.PopScanbeam();\n        if (!this.ProcessIntersections(topY)) return false;\n        this.ProcessEdgesAtTopOfScanbeam(topY);\n        botY = topY;\n      } while (this.m_Scanbeam !== null || this.m_CurrentLM !== null); //fix orientations ...\n\n\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts === null || outRec.IsOpen) continue;\n        if ((outRec.IsHole ^ this.ReverseSolution) == this.Area(outRec) > 0) this.ReversePolyPtLinks(outRec.Pts);\n      }\n\n      this.JoinCommonEdges();\n\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts !== null && !outRec.IsOpen) this.FixupOutPolygon(outRec);\n      }\n\n      if (this.StrictlySimple) this.DoSimplePolygons();\n      return true;\n    } finally {\n      ClipperLib.Clear(this.m_Joins);\n      ClipperLib.Clear(this.m_GhostJoins);\n    }\n  };\n\n  ClipperLib.Clipper.prototype.PopScanbeam = function () {\n    var Y = this.m_Scanbeam.Y;\n    this.m_Scanbeam = this.m_Scanbeam.Next;\n    return Y;\n  };\n\n  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function () {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i) this.DisposeOutRec(i);\n\n    ClipperLib.Clear(this.m_PolyOuts);\n  };\n\n  ClipperLib.Clipper.prototype.DisposeOutRec = function (index) {\n    var outRec = this.m_PolyOuts[index];\n    outRec.Pts = null;\n    outRec = null;\n    this.m_PolyOuts[index] = null;\n  };\n\n  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt) {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op1;\n    j.OutPt2 = Op2; //j.OffPt = OffPt;\n\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_Joins.push(j);\n  };\n\n  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt) {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op; //j.OffPt = OffPt;\n\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_GhostJoins.push(j);\n  };\n\n  if (use_xyz) {\n    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2) {\n      if (this.ZFillFunction !== null) {\n        if (pt.Z != 0 || this.ZFillFunction === null) return;else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n      }\n    }; //------------------------------------------------------------------------------\n\n  }\n\n  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY) {\n    while (this.m_CurrentLM !== null && this.m_CurrentLM.Y == botY) {\n      var lb = this.m_CurrentLM.LeftBound;\n      var rb = this.m_CurrentLM.RightBound;\n      this.PopLocalMinima();\n      var Op1 = null;\n\n      if (lb === null) {\n        this.InsertEdgeIntoAEL(rb, null);\n        this.SetWindingCount(rb);\n        if (this.IsContributing(rb)) Op1 = this.AddOutPt(rb, rb.Bot);\n      } else if (rb == null) {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.SetWindingCount(lb);\n        if (this.IsContributing(lb)) Op1 = this.AddOutPt(lb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      } else {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.InsertEdgeIntoAEL(rb, lb);\n        this.SetWindingCount(lb);\n        rb.WindCnt = lb.WindCnt;\n        rb.WindCnt2 = lb.WindCnt2;\n        if (this.IsContributing(lb)) Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n\n      if (rb != null) {\n        if (ClipperLib.ClipperBase.IsHorizontal(rb)) this.AddEdgeToSEL(rb);else this.InsertScanbeam(rb.Top.Y);\n      }\n\n      if (lb == null || rb == null) continue; //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n\n      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0) {\n        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++) {\n          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n          //the 'ghost' join to a real join ready for later ...\n          var j = this.m_GhostJoins[i];\n          if (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X)) this.AddJoin(j.OutPt1, Op1, j.OffPt);\n        }\n      }\n\n      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null && lb.PrevInAEL.Curr.X == lb.Bot.X && lb.PrevInAEL.OutIdx >= 0 && ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) && lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0) {\n        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n        this.AddJoin(Op1, Op2, lb.Top);\n      }\n\n      if (lb.NextInAEL != rb) {\n        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 && ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) && rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0) {\n          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n          this.AddJoin(Op1, Op2, rb.Top);\n        }\n\n        var e = lb.NextInAEL;\n        if (e !== null) while (e != rb) {\n          //nb: For calculating winding counts etc, IntersectEdges() assumes\n          //that param1 will be to the right of param2 ABOVE the intersection ...\n          this.IntersectEdges(rb, e, lb.Curr, false); //order important here\n\n          e = e.NextInAEL;\n        }\n      }\n    }\n  };\n\n  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge) {\n    if (this.m_ActiveEdges === null) {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = null;\n      this.m_ActiveEdges = edge;\n    } else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge)) {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = this.m_ActiveEdges;\n      this.m_ActiveEdges.PrevInAEL = edge;\n      this.m_ActiveEdges = edge;\n    } else {\n      if (startEdge === null) startEdge = this.m_ActiveEdges;\n\n      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge)) startEdge = startEdge.NextInAEL;\n\n      edge.NextInAEL = startEdge.NextInAEL;\n      if (startEdge.NextInAEL !== null) startEdge.NextInAEL.PrevInAEL = edge;\n      edge.PrevInAEL = startEdge;\n      startEdge.NextInAEL = edge;\n    }\n  };\n\n  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2) {\n    if (e2.Curr.X == e1.Curr.X) {\n      if (e2.Top.Y > e1.Top.Y) return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);else return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n    } else return e2.Curr.X < e1.Curr.X;\n  };\n\n  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge) {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject) return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;else return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n\n  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge) {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject) return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;else return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n\n  ClipperLib.Clipper.prototype.IsContributing = function (edge) {\n    var pft, pft2;\n\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject) {\n      pft = this.m_SubjFillType;\n      pft2 = this.m_ClipFillType;\n    } else {\n      pft = this.m_ClipFillType;\n      pft2 = this.m_SubjFillType;\n    }\n\n    switch (pft) {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n        if (edge.WindDelta === 0 && edge.WindCnt != 1) return false;\n        break;\n\n      case ClipperLib.PolyFillType.pftNonZero:\n        if (Math.abs(edge.WindCnt) != 1) return false;\n        break;\n\n      case ClipperLib.PolyFillType.pftPositive:\n        if (edge.WindCnt != 1) return false;\n        break;\n\n      default:\n        if (edge.WindCnt != -1) return false;\n        break;\n    }\n\n    switch (this.m_ClipType) {\n      case ClipperLib.ClipType.ctIntersection:\n        switch (pft2) {\n          case ClipperLib.PolyFillType.pftEvenOdd:\n          case ClipperLib.PolyFillType.pftNonZero:\n            return edge.WindCnt2 !== 0;\n\n          case ClipperLib.PolyFillType.pftPositive:\n            return edge.WindCnt2 > 0;\n\n          default:\n            return edge.WindCnt2 < 0;\n        }\n\n      case ClipperLib.ClipType.ctUnion:\n        switch (pft2) {\n          case ClipperLib.PolyFillType.pftEvenOdd:\n          case ClipperLib.PolyFillType.pftNonZero:\n            return edge.WindCnt2 === 0;\n\n          case ClipperLib.PolyFillType.pftPositive:\n            return edge.WindCnt2 <= 0;\n\n          default:\n            return edge.WindCnt2 >= 0;\n        }\n\n      case ClipperLib.ClipType.ctDifference:\n        if (edge.PolyTyp == ClipperLib.PolyType.ptSubject) switch (pft2) {\n          case ClipperLib.PolyFillType.pftEvenOdd:\n          case ClipperLib.PolyFillType.pftNonZero:\n            return edge.WindCnt2 === 0;\n\n          case ClipperLib.PolyFillType.pftPositive:\n            return edge.WindCnt2 <= 0;\n\n          default:\n            return edge.WindCnt2 >= 0;\n        } else switch (pft2) {\n          case ClipperLib.PolyFillType.pftEvenOdd:\n          case ClipperLib.PolyFillType.pftNonZero:\n            return edge.WindCnt2 !== 0;\n\n          case ClipperLib.PolyFillType.pftPositive:\n            return edge.WindCnt2 > 0;\n\n          default:\n            return edge.WindCnt2 < 0;\n        }\n\n      case ClipperLib.ClipType.ctXor:\n        if (edge.WindDelta === 0) switch (pft2) {\n          case ClipperLib.PolyFillType.pftEvenOdd:\n          case ClipperLib.PolyFillType.pftNonZero:\n            return edge.WindCnt2 === 0;\n\n          case ClipperLib.PolyFillType.pftPositive:\n            return edge.WindCnt2 <= 0;\n\n          default:\n            return edge.WindCnt2 >= 0;\n        } else return true;\n    }\n\n    return true;\n  };\n\n  ClipperLib.Clipper.prototype.SetWindingCount = function (edge) {\n    var e = edge.PrevInAEL; //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n\n    while (e !== null && (e.PolyTyp != edge.PolyTyp || e.WindDelta === 0)) e = e.PrevInAEL;\n\n    if (e === null) {\n      edge.WindCnt = edge.WindDelta === 0 ? 1 : edge.WindDelta;\n      edge.WindCnt2 = 0;\n      e = this.m_ActiveEdges; //ie get ready to calc WindCnt2\n    } else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion) {\n      edge.WindCnt = 1;\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL; //ie get ready to calc WindCnt2\n    } else if (this.IsEvenOddFillType(edge)) {\n      //EvenOdd filling ...\n      if (edge.WindDelta === 0) {\n        //are we inside a subj polygon ...\n        var Inside = true;\n        var e2 = e.PrevInAEL;\n\n        while (e2 !== null) {\n          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0) Inside = !Inside;\n          e2 = e2.PrevInAEL;\n        }\n\n        edge.WindCnt = Inside ? 0 : 1;\n      } else {\n        edge.WindCnt = edge.WindDelta;\n      }\n\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL; //ie get ready to calc WindCnt2\n    } else {\n      //nonZero, Positive or Negative filling ...\n      if (e.WindCnt * e.WindDelta < 0) {\n        //prev edge is 'decreasing' WindCount (WC) toward zero\n        //so we're outside the previous polygon ...\n        if (Math.abs(e.WindCnt) > 1) {\n          //outside prev poly but still inside another.\n          //when reversing direction of prev poly use the same WC\n          if (e.WindDelta * edge.WindDelta < 0) edge.WindCnt = e.WindCnt;else edge.WindCnt = e.WindCnt + edge.WindDelta;\n        } else edge.WindCnt = edge.WindDelta === 0 ? 1 : edge.WindDelta;\n      } else {\n        //prev edge is 'increasing' WindCount (WC) away from zero\n        //so we're inside the previous polygon ...\n        if (edge.WindDelta === 0) edge.WindCnt = e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1;else if (e.WindDelta * edge.WindDelta < 0) edge.WindCnt = e.WindCnt;else edge.WindCnt = e.WindCnt + edge.WindDelta;\n      }\n\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL; //ie get ready to calc WindCnt2\n    } //update WindCnt2 ...\n\n\n    if (this.IsEvenOddAltFillType(edge)) {\n      //EvenOdd filling ...\n      while (e != edge) {\n        if (e.WindDelta !== 0) edge.WindCnt2 = edge.WindCnt2 === 0 ? 1 : 0;\n        e = e.NextInAEL;\n      }\n    } else {\n      //nonZero, Positive or Negative filling ...\n      while (e != edge) {\n        edge.WindCnt2 += e.WindDelta;\n        e = e.NextInAEL;\n      }\n    }\n  };\n\n  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge) {\n    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n    //However, we don't need to worry about order with horizontal edge processing.\n    if (this.m_SortedEdges === null) {\n      this.m_SortedEdges = edge;\n      edge.PrevInSEL = null;\n      edge.NextInSEL = null;\n    } else {\n      edge.NextInSEL = this.m_SortedEdges;\n      edge.PrevInSEL = null;\n      this.m_SortedEdges.PrevInSEL = edge;\n      this.m_SortedEdges = edge;\n    }\n  };\n\n  ClipperLib.Clipper.prototype.CopyAELToSEL = function () {\n    var e = this.m_ActiveEdges;\n    this.m_SortedEdges = e;\n\n    while (e !== null) {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e = e.NextInAEL;\n    }\n  };\n\n  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2) {\n    //check that one or other edge hasn't already been removed from AEL ...\n    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL) return;\n\n    if (edge1.NextInAEL == edge2) {\n      var next = edge2.NextInAEL;\n      if (next !== null) next.PrevInAEL = edge1;\n      var prev = edge1.PrevInAEL;\n      if (prev !== null) prev.NextInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      edge2.NextInAEL = edge1;\n      edge1.PrevInAEL = edge2;\n      edge1.NextInAEL = next;\n    } else if (edge2.NextInAEL == edge1) {\n      var next = edge1.NextInAEL;\n      if (next !== null) next.PrevInAEL = edge2;\n      var prev = edge2.PrevInAEL;\n      if (prev !== null) prev.NextInAEL = edge1;\n      edge1.PrevInAEL = prev;\n      edge1.NextInAEL = edge2;\n      edge2.PrevInAEL = edge1;\n      edge2.NextInAEL = next;\n    } else {\n      var next = edge1.NextInAEL;\n      var prev = edge1.PrevInAEL;\n      edge1.NextInAEL = edge2.NextInAEL;\n      if (edge1.NextInAEL !== null) edge1.NextInAEL.PrevInAEL = edge1;\n      edge1.PrevInAEL = edge2.PrevInAEL;\n      if (edge1.PrevInAEL !== null) edge1.PrevInAEL.NextInAEL = edge1;\n      edge2.NextInAEL = next;\n      if (edge2.NextInAEL !== null) edge2.NextInAEL.PrevInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      if (edge2.PrevInAEL !== null) edge2.PrevInAEL.NextInAEL = edge2;\n    }\n\n    if (edge1.PrevInAEL === null) this.m_ActiveEdges = edge1;else if (edge2.PrevInAEL === null) this.m_ActiveEdges = edge2;\n  };\n\n  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2) {\n    if (edge1.NextInSEL === null && edge1.PrevInSEL === null) return;\n    if (edge2.NextInSEL === null && edge2.PrevInSEL === null) return;\n\n    if (edge1.NextInSEL == edge2) {\n      var next = edge2.NextInSEL;\n      if (next !== null) next.PrevInSEL = edge1;\n      var prev = edge1.PrevInSEL;\n      if (prev !== null) prev.NextInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      edge2.NextInSEL = edge1;\n      edge1.PrevInSEL = edge2;\n      edge1.NextInSEL = next;\n    } else if (edge2.NextInSEL == edge1) {\n      var next = edge1.NextInSEL;\n      if (next !== null) next.PrevInSEL = edge2;\n      var prev = edge2.PrevInSEL;\n      if (prev !== null) prev.NextInSEL = edge1;\n      edge1.PrevInSEL = prev;\n      edge1.NextInSEL = edge2;\n      edge2.PrevInSEL = edge1;\n      edge2.NextInSEL = next;\n    } else {\n      var next = edge1.NextInSEL;\n      var prev = edge1.PrevInSEL;\n      edge1.NextInSEL = edge2.NextInSEL;\n      if (edge1.NextInSEL !== null) edge1.NextInSEL.PrevInSEL = edge1;\n      edge1.PrevInSEL = edge2.PrevInSEL;\n      if (edge1.PrevInSEL !== null) edge1.PrevInSEL.NextInSEL = edge1;\n      edge2.NextInSEL = next;\n      if (edge2.NextInSEL !== null) edge2.NextInSEL.PrevInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      if (edge2.PrevInSEL !== null) edge2.PrevInSEL.NextInSEL = edge2;\n    }\n\n    if (edge1.PrevInSEL === null) this.m_SortedEdges = edge1;else if (edge2.PrevInSEL === null) this.m_SortedEdges = edge2;\n  };\n\n  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt) {\n    this.AddOutPt(e1, pt);\n    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n\n    if (e1.OutIdx == e2.OutIdx) {\n      e1.OutIdx = -1;\n      e2.OutIdx = -1;\n    } else if (e1.OutIdx < e2.OutIdx) this.AppendPolygon(e1, e2);else this.AppendPolygon(e2, e1);\n  };\n\n  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt) {\n    var result;\n    var e, prevE;\n\n    if (ClipperLib.ClipperBase.IsHorizontal(e2) || e1.Dx > e2.Dx) {\n      result = this.AddOutPt(e1, pt);\n      e2.OutIdx = e1.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esLeft;\n      e2.Side = ClipperLib.EdgeSide.esRight;\n      e = e1;\n      if (e.PrevInAEL == e2) prevE = e2.PrevInAEL;else prevE = e.PrevInAEL;\n    } else {\n      result = this.AddOutPt(e2, pt);\n      e1.OutIdx = e2.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esRight;\n      e2.Side = ClipperLib.EdgeSide.esLeft;\n      e = e2;\n      if (e.PrevInAEL == e1) prevE = e1.PrevInAEL;else prevE = e.PrevInAEL;\n    }\n\n    if (prevE !== null && prevE.OutIdx >= 0 && ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && e.WindDelta !== 0 && prevE.WindDelta !== 0) {\n      var outPt = this.AddOutPt(prevE, pt);\n      this.AddJoin(result, outPt, e.Top);\n    }\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.CreateOutRec = function () {\n    var result = new ClipperLib.OutRec();\n    result.Idx = -1;\n    result.IsHole = false;\n    result.IsOpen = false;\n    result.FirstLeft = null;\n    result.Pts = null;\n    result.BottomPt = null;\n    result.PolyNode = null;\n    this.m_PolyOuts.push(result);\n    result.Idx = this.m_PolyOuts.length - 1;\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt) {\n    var ToFront = e.Side == ClipperLib.EdgeSide.esLeft;\n\n    if (e.OutIdx < 0) {\n      var outRec = this.CreateOutRec();\n      outRec.IsOpen = e.WindDelta === 0;\n      var newOp = new ClipperLib.OutPt();\n      outRec.Pts = newOp;\n      newOp.Idx = outRec.Idx; //newOp.Pt = pt;\n\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = newOp;\n      newOp.Prev = newOp;\n      if (!outRec.IsOpen) this.SetHoleState(e, outRec);\n      e.OutIdx = outRec.Idx; //nb: do this after SetZ !\n\n      return newOp;\n    } else {\n      var outRec = this.m_PolyOuts[e.OutIdx]; //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n\n      var op = outRec.Pts;\n      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt)) return op;else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt)) return op.Prev;\n      var newOp = new ClipperLib.OutPt();\n      newOp.Idx = outRec.Idx; //newOp.Pt = pt;\n\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = op;\n      newOp.Prev = op.Prev;\n      newOp.Prev.Next = newOp;\n      op.Prev = newOp;\n      if (ToFront) outRec.Pts = newOp;\n      return newOp;\n    }\n  };\n\n  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2) {\n    var tmp = new ClipperLib.IntPoint(pt1.Value); //pt1.Value = pt2.Value;\n\n    pt1.Value.X = pt2.Value.X;\n    pt1.Value.Y = pt2.Value.Y; //pt2.Value = tmp;\n\n    pt2.Value.X = tmp.X;\n    pt2.Value.Y = tmp.Y;\n  };\n\n  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b) {\n    var tmp;\n\n    if (seg1a > seg1b) {\n      tmp = seg1a;\n      seg1a = seg1b;\n      seg1b = tmp;\n    }\n\n    if (seg2a > seg2b) {\n      tmp = seg2a;\n      seg2a = seg2b;\n      seg2b = tmp;\n    }\n\n    return seg1a < seg2b && seg2a < seg1b;\n  };\n\n  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec) {\n    var isHole = false;\n    var e2 = e.PrevInAEL;\n\n    while (e2 !== null) {\n      if (e2.OutIdx >= 0 && e2.WindDelta != 0) {\n        isHole = !isHole;\n        if (outRec.FirstLeft === null) outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n      }\n\n      e2 = e2.PrevInAEL;\n    }\n\n    if (isHole) outRec.IsHole = true;\n  };\n\n  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2) {\n    if (pt1.Y == pt2.Y) return ClipperLib.ClipperBase.horizontal;else return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n  };\n\n  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2) {\n    var p = btmPt1.Prev;\n\n    while (ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt) && p != btmPt1) p = p.Prev;\n\n    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt1.Next;\n\n    while (ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt) && p != btmPt1) p = p.Next;\n\n    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt2.Prev;\n\n    while (ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt) && p != btmPt2) p = p.Prev;\n\n    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    p = btmPt2.Next;\n\n    while (ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt) && p != btmPt2) p = p.Next;\n\n    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    return dx1p >= dx2p && dx1p >= dx2n || dx1n >= dx2p && dx1n >= dx2n;\n  };\n\n  ClipperLib.Clipper.prototype.GetBottomPt = function (pp) {\n    var dups = null;\n    var p = pp.Next;\n\n    while (p != pp) {\n      if (p.Pt.Y > pp.Pt.Y) {\n        pp = p;\n        dups = null;\n      } else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X) {\n        if (p.Pt.X < pp.Pt.X) {\n          dups = null;\n          pp = p;\n        } else {\n          if (p.Next != pp && p.Prev != pp) dups = p;\n        }\n      }\n\n      p = p.Next;\n    }\n\n    if (dups !== null) {\n      //there appears to be at least 2 vertices at bottomPt so ...\n      while (dups != p) {\n        if (!this.FirstIsBottomPt(p, dups)) pp = dups;\n        dups = dups.Next;\n\n        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt)) dups = dups.Next;\n      }\n    }\n\n    return pp;\n  };\n\n  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2) {\n    //work out which polygon fragment has the correct hole state ...\n    if (outRec1.BottomPt === null) outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n    if (outRec2.BottomPt === null) outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n    var bPt1 = outRec1.BottomPt;\n    var bPt2 = outRec2.BottomPt;\n    if (bPt1.Pt.Y > bPt2.Pt.Y) return outRec1;else if (bPt1.Pt.Y < bPt2.Pt.Y) return outRec2;else if (bPt1.Pt.X < bPt2.Pt.X) return outRec1;else if (bPt1.Pt.X > bPt2.Pt.X) return outRec2;else if (bPt1.Next == bPt1) return outRec2;else if (bPt2.Next == bPt2) return outRec1;else if (this.FirstIsBottomPt(bPt1, bPt2)) return outRec1;else return outRec2;\n  };\n\n  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2) {\n    do {\n      outRec1 = outRec1.FirstLeft;\n      if (outRec1 == outRec2) return true;\n    } while (outRec1 !== null);\n\n    return false;\n  };\n\n  ClipperLib.Clipper.prototype.GetOutRec = function (idx) {\n    var outrec = this.m_PolyOuts[idx];\n\n    while (outrec != this.m_PolyOuts[outrec.Idx]) outrec = this.m_PolyOuts[outrec.Idx];\n\n    return outrec;\n  };\n\n  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2) {\n    //get the start and ends of both output polygons ...\n    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n    var holeStateRec;\n    if (this.Param1RightOfParam2(outRec1, outRec2)) holeStateRec = outRec2;else if (this.Param1RightOfParam2(outRec2, outRec1)) holeStateRec = outRec1;else holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n    var p1_lft = outRec1.Pts;\n    var p1_rt = p1_lft.Prev;\n    var p2_lft = outRec2.Pts;\n    var p2_rt = p2_lft.Prev;\n    var side; //join e2 poly onto e1 poly and delete pointers to e2 ...\n\n    if (e1.Side == ClipperLib.EdgeSide.esLeft) {\n      if (e2.Side == ClipperLib.EdgeSide.esLeft) {\n        //z y x a b c\n        this.ReversePolyPtLinks(p2_lft);\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        outRec1.Pts = p2_rt;\n      } else {\n        //x y z a b c\n        p2_rt.Next = p1_lft;\n        p1_lft.Prev = p2_rt;\n        p2_lft.Prev = p1_rt;\n        p1_rt.Next = p2_lft;\n        outRec1.Pts = p2_lft;\n      }\n\n      side = ClipperLib.EdgeSide.esLeft;\n    } else {\n      if (e2.Side == ClipperLib.EdgeSide.esRight) {\n        //a b c z y x\n        this.ReversePolyPtLinks(p2_lft);\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n      } else {\n        //a b c x y z\n        p1_rt.Next = p2_lft;\n        p2_lft.Prev = p1_rt;\n        p1_lft.Prev = p2_rt;\n        p2_rt.Next = p1_lft;\n      }\n\n      side = ClipperLib.EdgeSide.esRight;\n    }\n\n    outRec1.BottomPt = null;\n\n    if (holeStateRec == outRec2) {\n      if (outRec2.FirstLeft != outRec1) outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec1.IsHole = outRec2.IsHole;\n    }\n\n    outRec2.Pts = null;\n    outRec2.BottomPt = null;\n    outRec2.FirstLeft = outRec1;\n    var OKIdx = e1.OutIdx;\n    var ObsoleteIdx = e2.OutIdx;\n    e1.OutIdx = -1; //nb: safe because we only get here via AddLocalMaxPoly\n\n    e2.OutIdx = -1;\n    var e = this.m_ActiveEdges;\n\n    while (e !== null) {\n      if (e.OutIdx == ObsoleteIdx) {\n        e.OutIdx = OKIdx;\n        e.Side = side;\n        break;\n      }\n\n      e = e.NextInAEL;\n    }\n\n    outRec2.Idx = outRec1.Idx;\n  };\n\n  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp) {\n    if (pp === null) return;\n    var pp1;\n    var pp2;\n    pp1 = pp;\n\n    do {\n      pp2 = pp1.Next;\n      pp1.Next = pp1.Prev;\n      pp1.Prev = pp2;\n      pp1 = pp2;\n    } while (pp1 != pp);\n  };\n\n  ClipperLib.Clipper.SwapSides = function (edge1, edge2) {\n    var side = edge1.Side;\n    edge1.Side = edge2.Side;\n    edge2.Side = side;\n  };\n\n  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2) {\n    var outIdx = edge1.OutIdx;\n    edge1.OutIdx = edge2.OutIdx;\n    edge2.OutIdx = outIdx;\n  };\n\n  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt) {\n    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n    //e2 in AEL except when e1 is being inserted at the intersection point ...\n    var e1Contributing = e1.OutIdx >= 0;\n    var e2Contributing = e2.OutIdx >= 0;\n    if (use_xyz) this.SetZ(pt, e1, e2);\n\n    if (use_lines) {\n      //if either edge is on an OPEN path ...\n      if (e1.WindDelta === 0 || e2.WindDelta === 0) {\n        //ignore subject-subject open path intersections UNLESS they\n        //are both open paths, AND they are both 'contributing maximas' ...\n        if (e1.WindDelta == 0 && e2.WindDelta == 0) return; //if intersecting a subj line with a subj poly ...\n        else if (e1.PolyTyp == e2.PolyTyp && e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion) {\n          if (e1.WindDelta === 0) {\n            if (e2Contributing) {\n              this.AddOutPt(e1, pt);\n              if (e1Contributing) e1.OutIdx = -1;\n            }\n          } else {\n            if (e1Contributing) {\n              this.AddOutPt(e2, pt);\n              if (e2Contributing) e2.OutIdx = -1;\n            }\n          }\n        } else if (e1.PolyTyp != e2.PolyTyp) {\n          if (e1.WindDelta === 0 && Math.abs(e2.WindCnt) == 1 && (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0)) {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing) e1.OutIdx = -1;\n          } else if (e2.WindDelta === 0 && Math.abs(e1.WindCnt) == 1 && (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0)) {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing) e2.OutIdx = -1;\n          }\n        }\n        return;\n      }\n    } //update winding counts...\n    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n\n\n    if (e1.PolyTyp == e2.PolyTyp) {\n      if (this.IsEvenOddFillType(e1)) {\n        var oldE1WindCnt = e1.WindCnt;\n        e1.WindCnt = e2.WindCnt;\n        e2.WindCnt = oldE1WindCnt;\n      } else {\n        if (e1.WindCnt + e2.WindDelta === 0) e1.WindCnt = -e1.WindCnt;else e1.WindCnt += e2.WindDelta;\n        if (e2.WindCnt - e1.WindDelta === 0) e2.WindCnt = -e2.WindCnt;else e2.WindCnt -= e1.WindDelta;\n      }\n    } else {\n      if (!this.IsEvenOddFillType(e2)) e1.WindCnt2 += e2.WindDelta;else e1.WindCnt2 = e1.WindCnt2 === 0 ? 1 : 0;\n      if (!this.IsEvenOddFillType(e1)) e2.WindCnt2 -= e1.WindDelta;else e2.WindCnt2 = e2.WindCnt2 === 0 ? 1 : 0;\n    }\n\n    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n\n    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject) {\n      e1FillType = this.m_SubjFillType;\n      e1FillType2 = this.m_ClipFillType;\n    } else {\n      e1FillType = this.m_ClipFillType;\n      e1FillType2 = this.m_SubjFillType;\n    }\n\n    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject) {\n      e2FillType = this.m_SubjFillType;\n      e2FillType2 = this.m_ClipFillType;\n    } else {\n      e2FillType = this.m_ClipFillType;\n      e2FillType2 = this.m_SubjFillType;\n    }\n\n    var e1Wc, e2Wc;\n\n    switch (e1FillType) {\n      case ClipperLib.PolyFillType.pftPositive:\n        e1Wc = e1.WindCnt;\n        break;\n\n      case ClipperLib.PolyFillType.pftNegative:\n        e1Wc = -e1.WindCnt;\n        break;\n\n      default:\n        e1Wc = Math.abs(e1.WindCnt);\n        break;\n    }\n\n    switch (e2FillType) {\n      case ClipperLib.PolyFillType.pftPositive:\n        e2Wc = e2.WindCnt;\n        break;\n\n      case ClipperLib.PolyFillType.pftNegative:\n        e2Wc = -e2.WindCnt;\n        break;\n\n      default:\n        e2Wc = Math.abs(e2.WindCnt);\n        break;\n    }\n\n    if (e1Contributing && e2Contributing) {\n      if (e1Wc != 0 && e1Wc != 1 || e2Wc != 0 && e2Wc != 1 || e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor) {\n        this.AddLocalMaxPoly(e1, e2, pt);\n      } else {\n        this.AddOutPt(e1, pt);\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    } else if (e1Contributing) {\n      if (e2Wc === 0 || e2Wc == 1) {\n        this.AddOutPt(e1, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    } else if (e2Contributing) {\n      if (e1Wc === 0 || e1Wc == 1) {\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    } else if ((e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1)) {\n      //neither edge is currently contributing ...\n      var e1Wc2, e2Wc2;\n\n      switch (e1FillType2) {\n        case ClipperLib.PolyFillType.pftPositive:\n          e1Wc2 = e1.WindCnt2;\n          break;\n\n        case ClipperLib.PolyFillType.pftNegative:\n          e1Wc2 = -e1.WindCnt2;\n          break;\n\n        default:\n          e1Wc2 = Math.abs(e1.WindCnt2);\n          break;\n      }\n\n      switch (e2FillType2) {\n        case ClipperLib.PolyFillType.pftPositive:\n          e2Wc2 = e2.WindCnt2;\n          break;\n\n        case ClipperLib.PolyFillType.pftNegative:\n          e2Wc2 = -e2.WindCnt2;\n          break;\n\n        default:\n          e2Wc2 = Math.abs(e2.WindCnt2);\n          break;\n      }\n\n      if (e1.PolyTyp != e2.PolyTyp) {\n        this.AddLocalMinPoly(e1, e2, pt);\n      } else if (e1Wc == 1 && e2Wc == 1) switch (this.m_ClipType) {\n        case ClipperLib.ClipType.ctIntersection:\n          if (e1Wc2 > 0 && e2Wc2 > 0) this.AddLocalMinPoly(e1, e2, pt);\n          break;\n\n        case ClipperLib.ClipType.ctUnion:\n          if (e1Wc2 <= 0 && e2Wc2 <= 0) this.AddLocalMinPoly(e1, e2, pt);\n          break;\n\n        case ClipperLib.ClipType.ctDifference:\n          if (e1.PolyTyp == ClipperLib.PolyType.ptClip && e1Wc2 > 0 && e2Wc2 > 0 || e1.PolyTyp == ClipperLib.PolyType.ptSubject && e1Wc2 <= 0 && e2Wc2 <= 0) this.AddLocalMinPoly(e1, e2, pt);\n          break;\n\n        case ClipperLib.ClipType.ctXor:\n          this.AddLocalMinPoly(e1, e2, pt);\n          break;\n      } else ClipperLib.Clipper.SwapSides(e1, e2);\n    }\n  };\n\n  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e) {\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    if (AelPrev === null && AelNext === null && e != this.m_ActiveEdges) return; //already deleted\n\n    if (AelPrev !== null) AelPrev.NextInAEL = AelNext;else this.m_ActiveEdges = AelNext;\n    if (AelNext !== null) AelNext.PrevInAEL = AelPrev;\n    e.NextInAEL = null;\n    e.PrevInAEL = null;\n  };\n\n  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e) {\n    var SelPrev = e.PrevInSEL;\n    var SelNext = e.NextInSEL;\n    if (SelPrev === null && SelNext === null && e != this.m_SortedEdges) return; //already deleted\n\n    if (SelPrev !== null) SelPrev.NextInSEL = SelNext;else this.m_SortedEdges = SelNext;\n    if (SelNext !== null) SelNext.PrevInSEL = SelPrev;\n    e.NextInSEL = null;\n    e.PrevInSEL = null;\n  };\n\n  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e) {\n    if (e.NextInLML === null) ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    e.NextInLML.OutIdx = e.OutIdx;\n    if (AelPrev !== null) AelPrev.NextInAEL = e.NextInLML;else this.m_ActiveEdges = e.NextInLML;\n    if (AelNext !== null) AelNext.PrevInAEL = e.NextInLML;\n    e.NextInLML.Side = e.Side;\n    e.NextInLML.WindDelta = e.WindDelta;\n    e.NextInLML.WindCnt = e.WindCnt;\n    e.NextInLML.WindCnt2 = e.WindCnt2;\n    e = e.NextInLML; //    e.Curr = e.Bot;\n\n    e.Curr.X = e.Bot.X;\n    e.Curr.Y = e.Bot.Y;\n    e.PrevInAEL = AelPrev;\n    e.NextInAEL = AelNext;\n    if (!ClipperLib.ClipperBase.IsHorizontal(e)) this.InsertScanbeam(e.Top.Y);\n    return e;\n  };\n\n  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam) {\n    var horzEdge = this.m_SortedEdges;\n\n    while (horzEdge !== null) {\n      this.DeleteFromSEL(horzEdge);\n      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n      horzEdge = this.m_SortedEdges;\n    }\n  };\n\n  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var) {\n    if (HorzEdge.Bot.X < HorzEdge.Top.X) {\n      $var.Left = HorzEdge.Bot.X;\n      $var.Right = HorzEdge.Top.X;\n      $var.Dir = ClipperLib.Direction.dLeftToRight;\n    } else {\n      $var.Left = HorzEdge.Top.X;\n      $var.Right = HorzEdge.Bot.X;\n      $var.Dir = ClipperLib.Direction.dRightToLeft;\n    }\n  };\n\n  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam) {\n    var $var = {\n      Dir: null,\n      Left: null,\n      Right: null\n    };\n    this.GetHorzDirection(horzEdge, $var);\n    var dir = $var.Dir;\n    var horzLeft = $var.Left;\n    var horzRight = $var.Right;\n    var eLastHorz = horzEdge,\n        eMaxPair = null;\n\n    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML)) eLastHorz = eLastHorz.NextInLML;\n\n    if (eLastHorz.NextInLML === null) eMaxPair = this.GetMaximaPair(eLastHorz);\n\n    for (;;) {\n      var IsLastHorz = horzEdge == eLastHorz;\n      var e = this.GetNextInAEL(horzEdge, dir);\n\n      while (e !== null) {\n        //Break if we've got to the end of an intermediate horizontal edge ...\n        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx) break;\n        var eNext = this.GetNextInAEL(e, dir); //saves eNext for later\n\n        if (dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight || dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft) {\n          //so far we're still in range of the horizontal Edge  but make sure\n          //we're at the last of consec. horizontals when matching with eMaxPair\n          if (e == eMaxPair && IsLastHorz) {\n            if (horzEdge.OutIdx >= 0) {\n              var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n              var eNextHorz = this.m_SortedEdges;\n\n              while (eNextHorz !== null) {\n                if (eNextHorz.OutIdx >= 0 && this.HorzSegmentsOverlap(horzEdge.Bot.X, horzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X)) {\n                  var op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n                  this.AddJoin(op2, op1, eNextHorz.Top);\n                }\n\n                eNextHorz = eNextHorz.NextInSEL;\n              }\n\n              this.AddGhostJoin(op1, horzEdge.Bot);\n              this.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n            }\n\n            this.DeleteFromAEL(horzEdge);\n            this.DeleteFromAEL(eMaxPair);\n            return;\n          } else if (dir == ClipperLib.Direction.dLeftToRight) {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(horzEdge, e, Pt);\n          } else {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(e, horzEdge, Pt);\n          }\n\n          this.SwapPositionsInAEL(horzEdge, e);\n        } else if (dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight || dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft) break;\n\n        e = eNext;\n      } //end while\n\n\n      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML)) {\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.OutIdx >= 0) this.AddOutPt(horzEdge, horzEdge.Bot);\n        var $var = {\n          Dir: dir,\n          Left: horzLeft,\n          Right: horzRight\n        };\n        this.GetHorzDirection(horzEdge, $var);\n        dir = $var.Dir;\n        horzLeft = $var.Left;\n        horzRight = $var.Right;\n      } else break;\n    } //end for (;;)\n\n\n    if (horzEdge.NextInLML !== null) {\n      if (horzEdge.OutIdx >= 0) {\n        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n        if (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.WindDelta === 0) return; //nb: HorzEdge is no longer horizontal here\n\n        var ePrev = horzEdge.PrevInAEL;\n        var eNext = horzEdge.NextInAEL;\n\n        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X && ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 && ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y && ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)) {\n          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        } else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X && eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 && eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y && ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange)) {\n          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n      } else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    } else {\n      if (horzEdge.OutIdx >= 0) this.AddOutPt(horzEdge, horzEdge.Top);\n      this.DeleteFromAEL(horzEdge);\n    }\n  };\n\n  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction) {\n    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n  };\n\n  ClipperLib.Clipper.prototype.IsMinima = function (e) {\n    return e !== null && e.Prev.NextInLML != e && e.Next.NextInLML != e;\n  };\n\n  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y) {\n    return e !== null && e.Top.Y == Y && e.NextInLML === null;\n  };\n\n  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y) {\n    return e.Top.Y == Y && e.NextInLML !== null;\n  };\n\n  ClipperLib.Clipper.prototype.GetMaximaPair = function (e) {\n    var result = null;\n    if (ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top) && e.Next.NextInLML === null) result = e.Next;else if (ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top) && e.Prev.NextInLML === null) result = e.Prev;\n    if (result !== null && (result.OutIdx == -2 || result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))) return null;\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY) {\n    if (this.m_ActiveEdges == null) return true;\n\n    try {\n      this.BuildIntersectList(topY);\n      if (this.m_IntersectList.length == 0) return true;\n      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder()) this.ProcessIntersectList();else return false;\n    } catch ($$e2) {\n      this.m_SortedEdges = null;\n      this.m_IntersectList.length = 0;\n      ClipperLib.Error(\"ProcessIntersections error\");\n    }\n\n    this.m_SortedEdges = null;\n    return true;\n  };\n\n  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY) {\n    if (this.m_ActiveEdges === null) return; //prepare for sorting ...\n\n    var e = this.m_ActiveEdges; //console.log(JSON.stringify(JSON.decycle( e )));\n\n    this.m_SortedEdges = e;\n\n    while (e !== null) {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n      e = e.NextInAEL;\n    } //bubblesort ...\n\n\n    var isModified = true;\n\n    while (isModified && this.m_SortedEdges !== null) {\n      isModified = false;\n      e = this.m_SortedEdges;\n\n      while (e.NextInSEL !== null) {\n        var eNext = e.NextInSEL;\n        var pt = new ClipperLib.IntPoint(); //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n\n        if (e.Curr.X > eNext.Curr.X) {\n          this.IntersectPoint(e, eNext, pt);\n          var newNode = new ClipperLib.IntersectNode();\n          newNode.Edge1 = e;\n          newNode.Edge2 = eNext; //newNode.Pt = pt;\n\n          newNode.Pt.X = pt.X;\n          newNode.Pt.Y = pt.Y;\n          this.m_IntersectList.push(newNode);\n          this.SwapPositionsInSEL(e, eNext);\n          isModified = true;\n        } else e = eNext;\n      }\n\n      if (e.PrevInSEL !== null) e.PrevInSEL.NextInSEL = null;else break;\n    }\n\n    this.m_SortedEdges = null;\n  };\n\n  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode) {\n    return inode.Edge1.NextInSEL == inode.Edge2 || inode.Edge1.PrevInSEL == inode.Edge2;\n  };\n\n  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2) {\n    //the following typecast is safe because the differences in Pt.Y will\n    //be limited to the height of the scanbeam.\n    return node2.Pt.Y - node1.Pt.Y;\n  };\n\n  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function () {\n    //pre-condition: intersections are sorted bottom-most first.\n    //Now it's crucial that intersections are made only between adjacent edges,\n    //so to ensure this the order of intersections may need adjusting ...\n    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n    this.CopyAELToSEL();\n    var cnt = this.m_IntersectList.length;\n\n    for (var i = 0; i < cnt; i++) {\n      if (!this.EdgesAdjacent(this.m_IntersectList[i])) {\n        var j = i + 1;\n\n        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j])) j++;\n\n        if (j == cnt) return false;\n        var tmp = this.m_IntersectList[i];\n        this.m_IntersectList[i] = this.m_IntersectList[j];\n        this.m_IntersectList[j] = tmp;\n      }\n\n      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n    }\n\n    return true;\n  };\n\n  ClipperLib.Clipper.prototype.ProcessIntersectList = function () {\n    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++) {\n      var iNode = this.m_IntersectList[i];\n      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n    }\n\n    this.m_IntersectList.length = 0;\n  };\n  /*\n  --------------------------------\n  Round speedtest: http://jsperf.com/fastest-round\n  --------------------------------\n  */\n\n\n  var R1 = function (a) {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a);\n  };\n\n  var R2 = function (a) {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5);\n  };\n\n  var R3 = function (a) {\n    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a);\n  };\n\n  var R4 = function (a) {\n    if (a < 0) {\n      a -= 0.5;\n      return a < -2147483648 ? Math.ceil(a) : a | 0;\n    } else {\n      a += 0.5;\n      return a > 2147483647 ? Math.floor(a) : a | 0;\n    }\n  };\n\n  if (browser.msie) ClipperLib.Clipper.Round = R1;else if (browser.chromium) ClipperLib.Clipper.Round = R3;else if (browser.safari) ClipperLib.Clipper.Round = R4;else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n\n  ClipperLib.Clipper.TopX = function (edge, currentY) {\n    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n    if (currentY == edge.Top.Y) return edge.Top.X;\n    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n  };\n\n  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip) {\n    ip.X = 0;\n    ip.Y = 0;\n    var b1, b2; //nb: with very large coordinate values, it's possible for SlopesEqual() to\n    //return false but for the edge.Dx value be equal due to double precision rounding.\n\n    if (edge1.Dx == edge2.Dx) {\n      ip.Y = edge1.Curr.Y;\n      ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n      return;\n    }\n\n    if (edge1.Delta.X === 0) {\n      ip.X = edge1.Bot.X;\n\n      if (ClipperLib.ClipperBase.IsHorizontal(edge2)) {\n        ip.Y = edge2.Bot.Y;\n      } else {\n        b2 = edge2.Bot.Y - edge2.Bot.X / edge2.Dx;\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n      }\n    } else if (edge2.Delta.X === 0) {\n      ip.X = edge2.Bot.X;\n\n      if (ClipperLib.ClipperBase.IsHorizontal(edge1)) {\n        ip.Y = edge1.Bot.Y;\n      } else {\n        b1 = edge1.Bot.Y - edge1.Bot.X / edge1.Dx;\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n      }\n    } else {\n      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n      ip.Y = ClipperLib.Clipper.Round(q);\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx)) ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);else ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n    }\n\n    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y) {\n      if (edge1.Top.Y > edge2.Top.Y) {\n        ip.Y = edge1.Top.Y;\n        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n        return ip.X < edge1.Top.X;\n      } else ip.Y = edge2.Top.Y;\n\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx)) ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);else ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n    } //finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\n\n    if (ip.Y > edge1.Curr.Y) {\n      ip.Y = edge1.Curr.Y; //better to use the more vertical edge to derive X ...\n\n      if (Math.abs(edge1.Dx) > Math.abs(edge2.Dx)) ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);else ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n    }\n  };\n\n  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY) {\n    var e = this.m_ActiveEdges;\n\n    while (e !== null) {\n      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n      var IsMaximaEdge = this.IsMaxima(e, topY);\n\n      if (IsMaximaEdge) {\n        var eMaxPair = this.GetMaximaPair(e);\n        IsMaximaEdge = eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair);\n      }\n\n      if (IsMaximaEdge) {\n        var ePrev = e.PrevInAEL;\n        this.DoMaxima(e);\n        if (ePrev === null) e = this.m_ActiveEdges;else e = ePrev.NextInAEL;\n      } else {\n        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML)) {\n          e = this.UpdateEdgeIntoAEL(e);\n          if (e.OutIdx >= 0) this.AddOutPt(e, e.Bot);\n          this.AddEdgeToSEL(e);\n        } else {\n          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n          e.Curr.Y = topY;\n        }\n\n        if (this.StrictlySimple) {\n          var ePrev = e.PrevInAEL;\n\n          if (e.OutIdx >= 0 && e.WindDelta !== 0 && ePrev !== null && ePrev.OutIdx >= 0 && ePrev.Curr.X == e.Curr.X && ePrev.WindDelta !== 0) {\n            var ip = new ClipperLib.IntPoint(e.Curr);\n\n            if (use_xyz) {\n              this.SetZ(ip, ePrev, e);\n            }\n\n            var op = this.AddOutPt(ePrev, ip);\n            var op2 = this.AddOutPt(e, ip);\n            this.AddJoin(op, op2, ip); //StrictlySimple (type-3) join\n          }\n        }\n\n        e = e.NextInAEL;\n      }\n    } //3. Process horizontals at the Top of the scanbeam ...\n\n\n    this.ProcessHorizontals(true); //4. Promote intermediate vertices ...\n\n    e = this.m_ActiveEdges;\n\n    while (e !== null) {\n      if (this.IsIntermediate(e, topY)) {\n        var op = null;\n        if (e.OutIdx >= 0) op = this.AddOutPt(e, e.Top);\n        e = this.UpdateEdgeIntoAEL(e); //if output polygons share an edge, they'll need joining later ...\n\n        var ePrev = e.PrevInAEL;\n        var eNext = e.NextInAEL;\n\n        if (ePrev !== null && ePrev.Curr.X == e.Bot.X && ePrev.Curr.Y == e.Bot.Y && op !== null && ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y && ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) && e.WindDelta !== 0 && ePrev.WindDelta !== 0) {\n          var op2 = this.AddOutPt(ePrev, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        } else if (eNext !== null && eNext.Curr.X == e.Bot.X && eNext.Curr.Y == e.Bot.Y && op !== null && eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y && ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) && e.WindDelta !== 0 && eNext.WindDelta !== 0) {\n          var op2 = this.AddOutPt(eNext, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n      }\n\n      e = e.NextInAEL;\n    }\n  };\n\n  ClipperLib.Clipper.prototype.DoMaxima = function (e) {\n    var eMaxPair = this.GetMaximaPair(e);\n\n    if (eMaxPair === null) {\n      if (e.OutIdx >= 0) this.AddOutPt(e, e.Top);\n      this.DeleteFromAEL(e);\n      return;\n    }\n\n    var eNext = e.NextInAEL;\n    var use_lines = true;\n\n    while (eNext !== null && eNext != eMaxPair) {\n      this.IntersectEdges(e, eNext, e.Top);\n      this.SwapPositionsInAEL(e, eNext);\n      eNext = e.NextInAEL;\n    }\n\n    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1) {\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    } else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0) {\n      if (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    } else if (use_lines && e.WindDelta === 0) {\n      if (e.OutIdx >= 0) {\n        this.AddOutPt(e, e.Top);\n        e.OutIdx = -1;\n      }\n\n      this.DeleteFromAEL(e);\n\n      if (eMaxPair.OutIdx >= 0) {\n        this.AddOutPt(eMaxPair, e.Top);\n        eMaxPair.OutIdx = -1;\n      }\n\n      this.DeleteFromAEL(eMaxPair);\n    } else ClipperLib.Error(\"DoMaxima error\");\n  };\n\n  ClipperLib.Clipper.ReversePaths = function (polys) {\n    for (var i = 0, len = polys.length; i < len; i++) polys[i].reverse();\n  };\n\n  ClipperLib.Clipper.Orientation = function (poly) {\n    return ClipperLib.Clipper.Area(poly) >= 0;\n  };\n\n  ClipperLib.Clipper.prototype.PointCount = function (pts) {\n    if (pts === null) return 0;\n    var result = 0;\n    var p = pts;\n\n    do {\n      result++;\n      p = p.Next;\n    } while (p != pts);\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.BuildResult = function (polyg) {\n    ClipperLib.Clear(polyg);\n\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null) continue;\n      var p = outRec.Pts.Prev;\n      var cnt = this.PointCount(p);\n      if (cnt < 2) continue;\n      var pg = new Array(cnt);\n\n      for (var j = 0; j < cnt; j++) {\n        pg[j] = p.Pt;\n        p = p.Prev;\n      }\n\n      polyg.push(pg);\n    }\n  };\n\n  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree) {\n    polytree.Clear(); //add each output polygon/contour to polytree ...\n    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n      var outRec = this.m_PolyOuts[i];\n      var cnt = this.PointCount(outRec.Pts);\n      if (outRec.IsOpen && cnt < 2 || !outRec.IsOpen && cnt < 3) continue;\n      this.FixHoleLinkage(outRec);\n      var pn = new ClipperLib.PolyNode();\n      polytree.m_AllPolys.push(pn);\n      outRec.PolyNode = pn;\n      pn.m_polygon.length = cnt;\n      var op = outRec.Pts.Prev;\n\n      for (var j = 0; j < cnt; j++) {\n        pn.m_polygon[j] = op.Pt;\n        op = op.Prev;\n      }\n    } //fixup PolyNode links etc ...\n    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n\n\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.PolyNode === null) continue;else if (outRec.IsOpen) {\n        outRec.PolyNode.IsOpen = true;\n        polytree.AddChild(outRec.PolyNode);\n      } else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null) outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);else polytree.AddChild(outRec.PolyNode);\n    }\n  };\n\n  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec) {\n    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n    //parallel edges by removing the middle vertex.\n    var lastOK = null;\n    outRec.BottomPt = null;\n    var pp = outRec.Pts;\n\n    for (;;) {\n      if (pp.Prev == pp || pp.Prev == pp.Next) {\n        outRec.Pts = null;\n        return;\n      } //test for duplicate points and collinear edges ...\n\n\n      if (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt) || ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt) || ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))) {\n        lastOK = null;\n        pp.Prev.Next = pp.Next;\n        pp.Next.Prev = pp.Prev;\n        pp = pp.Prev;\n      } else if (pp == lastOK) break;else {\n        if (lastOK === null) lastOK = pp;\n        pp = pp.Next;\n      }\n    }\n\n    outRec.Pts = pp;\n  };\n\n  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter) {\n    var result = new ClipperLib.OutPt(); //result.Pt = outPt.Pt;\n\n    result.Pt.X = outPt.Pt.X;\n    result.Pt.Y = outPt.Pt.Y;\n    result.Idx = outPt.Idx;\n\n    if (InsertAfter) {\n      result.Next = outPt.Next;\n      result.Prev = outPt;\n      outPt.Next.Prev = result;\n      outPt.Next = result;\n    } else {\n      result.Prev = outPt.Prev;\n      result.Next = outPt;\n      outPt.Prev.Next = result;\n      outPt.Prev = result;\n    }\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val) {\n    if (a1 < a2) {\n      if (b1 < b2) {\n        $val.Left = Math.max(a1, b1);\n        $val.Right = Math.min(a2, b2);\n      } else {\n        $val.Left = Math.max(a1, b2);\n        $val.Right = Math.min(a2, b1);\n      }\n    } else {\n      if (b1 < b2) {\n        $val.Left = Math.max(a2, b1);\n        $val.Right = Math.min(a1, b2);\n      } else {\n        $val.Left = Math.max(a2, b2);\n        $val.Right = Math.min(a1, b1);\n      }\n    }\n\n    return $val.Left < $val.Right;\n  };\n\n  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft) {\n    var Dir1 = op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight;\n    var Dir2 = op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight;\n    if (Dir1 == Dir2) return false; //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n    //So, to facilitate this while inserting Op1b and Op2b ...\n    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n\n    if (Dir1 == ClipperLib.Direction.dLeftToRight) {\n      while (op1.Next.Pt.X <= Pt.X && op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y) op1 = op1.Next;\n\n      if (DiscardLeft && op1.Pt.X != Pt.X) op1 = op1.Next;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt)) {\n        op1 = op1b; //op1.Pt = Pt;\n\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, !DiscardLeft);\n      }\n    } else {\n      while (op1.Next.Pt.X >= Pt.X && op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y) op1 = op1.Next;\n\n      if (!DiscardLeft && op1.Pt.X != Pt.X) op1 = op1.Next;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt)) {\n        op1 = op1b; //op1.Pt = Pt;\n\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, DiscardLeft);\n      }\n    }\n\n    if (Dir2 == ClipperLib.Direction.dLeftToRight) {\n      while (op2.Next.Pt.X <= Pt.X && op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y) op2 = op2.Next;\n\n      if (DiscardLeft && op2.Pt.X != Pt.X) op2 = op2.Next;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt)) {\n        op2 = op2b; //op2.Pt = Pt;\n\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, !DiscardLeft);\n      }\n    } else {\n      while (op2.Next.Pt.X >= Pt.X && op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y) op2 = op2.Next;\n\n      if (!DiscardLeft && op2.Pt.X != Pt.X) op2 = op2.Next;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt)) {\n        op2 = op2b; //op2.Pt = Pt;\n\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, DiscardLeft);\n      }\n    }\n\n    if (Dir1 == ClipperLib.Direction.dLeftToRight == DiscardLeft) {\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n    } else {\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n    }\n\n    return true;\n  };\n\n  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2) {\n    var op1 = j.OutPt1,\n        op1b = new ClipperLib.OutPt();\n    var op2 = j.OutPt2,\n        op2b = new ClipperLib.OutPt(); //There are 3 kinds of joins for output polygons ...\n    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n    //3. StrictlySimple joins where edges touch but are not collinear and where\n    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n\n    var isHorizontal = j.OutPt1.Pt.Y == j.OffPt.Y;\n\n    if (isHorizontal && ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt) && ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)) {\n      //Strictly Simple join ...\n      if (outRec1 != outRec2) return false;\n      op1b = j.OutPt1.Next;\n\n      while (op1b != op1 && ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)) op1b = op1b.Next;\n\n      var reverse1 = op1b.Pt.Y > j.OffPt.Y;\n      op2b = j.OutPt2.Next;\n\n      while (op2b != op2 && ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)) op2b = op2b.Next;\n\n      var reverse2 = op2b.Pt.Y > j.OffPt.Y;\n      if (reverse1 == reverse2) return false;\n\n      if (reverse1) {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      } else {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    } else if (isHorizontal) {\n      //treat horizontal joins differently to non-horizontal joins since with\n      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n      //may be anywhere along the horizontal edge.\n      op1b = op1;\n\n      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2) op1 = op1.Prev;\n\n      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2) op1b = op1b.Next;\n\n      if (op1b.Next == op1 || op1b.Next == op2) return false; //a flat 'polygon'\n\n      op2b = op2;\n\n      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b) op2 = op2.Prev;\n\n      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1) op2b = op2b.Next;\n\n      if (op2b.Next == op2 || op2b.Next == op1) return false; //a flat 'polygon'\n      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n      var $val = {\n        Left: null,\n        Right: null\n      };\n      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val)) return false;\n      var Left = $val.Left;\n      var Right = $val.Right; //DiscardLeftSide: when overlapping edges are joined, a spike will created\n      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n      //on the discard Side as either may still be needed for other joins ...\n\n      var Pt = new ClipperLib.IntPoint();\n      var DiscardLeftSide;\n\n      if (op1.Pt.X >= Left && op1.Pt.X <= Right) {\n        //Pt = op1.Pt;\n        Pt.X = op1.Pt.X;\n        Pt.Y = op1.Pt.Y;\n        DiscardLeftSide = op1.Pt.X > op1b.Pt.X;\n      } else if (op2.Pt.X >= Left && op2.Pt.X <= Right) {\n        //Pt = op2.Pt;\n        Pt.X = op2.Pt.X;\n        Pt.Y = op2.Pt.Y;\n        DiscardLeftSide = op2.Pt.X > op2b.Pt.X;\n      } else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right) {\n        //Pt = op1b.Pt;\n        Pt.X = op1b.Pt.X;\n        Pt.Y = op1b.Pt.Y;\n        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n      } else {\n        //Pt = op2b.Pt;\n        Pt.X = op2b.Pt.X;\n        Pt.Y = op2b.Pt.Y;\n        DiscardLeftSide = op2b.Pt.X > op2.Pt.X;\n      }\n\n      j.OutPt1 = op1;\n      j.OutPt2 = op2;\n      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n    } else {\n      //nb: For non-horizontal joins ...\n      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n      //make sure the polygons are correctly oriented ...\n      op1b = op1.Next;\n\n      while (ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt) && op1b != op1) op1b = op1b.Next;\n\n      var Reverse1 = op1b.Pt.Y > op1.Pt.Y || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange);\n\n      if (Reverse1) {\n        op1b = op1.Prev;\n\n        while (ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt) && op1b != op1) op1b = op1b.Prev;\n\n        if (op1b.Pt.Y > op1.Pt.Y || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange)) return false;\n      }\n\n      op2b = op2.Next;\n\n      while (ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt) && op2b != op2) op2b = op2b.Next;\n\n      var Reverse2 = op2b.Pt.Y > op2.Pt.Y || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange);\n\n      if (Reverse2) {\n        op2b = op2.Prev;\n\n        while (ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt) && op2b != op2) op2b = op2b.Prev;\n\n        if (op2b.Pt.Y > op2.Pt.Y || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange)) return false;\n      }\n\n      if (op1b == op1 || op2b == op2 || op1b == op2b || outRec1 == outRec2 && Reverse1 == Reverse2) return false;\n\n      if (Reverse1) {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      } else {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n  };\n\n  ClipperLib.Clipper.GetBounds = function (paths) {\n    var i = 0,\n        cnt = paths.length;\n\n    while (i < cnt && paths[i].length == 0) i++;\n\n    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n    var result = new ClipperLib.IntRect();\n    result.left = paths[i][0].X;\n    result.right = result.left;\n    result.top = paths[i][0].Y;\n    result.bottom = result.top;\n\n    for (; i < cnt; i++) for (var j = 0, jlen = paths[i].length; j < jlen; j++) {\n      if (paths[i][j].X < result.left) result.left = paths[i][j].X;else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n      if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n    }\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.GetBounds2 = function (ops) {\n    var opStart = ops;\n    var result = new ClipperLib.IntRect();\n    result.left = ops.Pt.X;\n    result.right = ops.Pt.X;\n    result.top = ops.Pt.Y;\n    result.bottom = ops.Pt.Y;\n    ops = ops.Next;\n\n    while (ops != opStart) {\n      if (ops.Pt.X < result.left) result.left = ops.Pt.X;\n      if (ops.Pt.X > result.right) result.right = ops.Pt.X;\n      if (ops.Pt.Y < result.top) result.top = ops.Pt.Y;\n      if (ops.Pt.Y > result.bottom) result.bottom = ops.Pt.Y;\n      ops = ops.Next;\n    }\n\n    return result;\n  };\n\n  ClipperLib.Clipper.PointInPolygon = function (pt, path) {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n    //See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0,\n        cnt = path.length;\n    if (cnt < 3) return 0;\n    var ip = path[0];\n\n    for (var i = 1; i <= cnt; ++i) {\n      var ipNext = i == cnt ? path[0] : path[i];\n\n      if (ipNext.Y == pt.Y) {\n        if (ipNext.X == pt.X || ip.Y == pt.Y && ipNext.X > pt.X == ip.X < pt.X) return -1;\n      }\n\n      if (ip.Y < pt.Y != ipNext.Y < pt.Y) {\n        if (ip.X >= pt.X) {\n          if (ipNext.X > pt.X) result = 1 - result;else {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0) return -1;else if (d > 0 == ipNext.Y > ip.Y) result = 1 - result;\n          }\n        } else {\n          if (ipNext.X > pt.X) {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0) return -1;else if (d > 0 == ipNext.Y > ip.Y) result = 1 - result;\n          }\n        }\n      }\n\n      ip = ipNext;\n    }\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op) {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n    //See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0;\n    var startOp = op;\n    var ptx = pt.X,\n        pty = pt.Y;\n    var poly0x = op.Pt.X,\n        poly0y = op.Pt.Y;\n\n    do {\n      op = op.Next;\n      var poly1x = op.Pt.X,\n          poly1y = op.Pt.Y;\n\n      if (poly1y == pty) {\n        if (poly1x == ptx || poly0y == pty && poly1x > ptx == poly0x < ptx) return -1;\n      }\n\n      if (poly0y < pty != poly1y < pty) {\n        if (poly0x >= ptx) {\n          if (poly1x > ptx) result = 1 - result;else {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0) return -1;\n            if (d > 0 == poly1y > poly0y) result = 1 - result;\n          }\n        } else {\n          if (poly1x > ptx) {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0) return -1;\n            if (d > 0 == poly1y > poly0y) result = 1 - result;\n          }\n        }\n      }\n\n      poly0x = poly1x;\n      poly0y = poly1y;\n    } while (startOp != op);\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2) {\n    var op = outPt1;\n\n    do {\n      //nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n      var res = this.PointInPolygon(op.Pt, outPt2);\n      if (res >= 0) return res > 0;\n      op = op.Next;\n    } while (op != outPt1);\n\n    return true;\n  };\n\n  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec) {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts == null || outRec.FirstLeft == null) continue;\n      var firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\n      if (firstLeft == OldOutRec) {\n        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts)) outRec.FirstLeft = NewOutRec;\n      }\n    }\n  };\n\n  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec) {\n    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2]) if (outRec.FirstLeft == OldOutRec) outRec.FirstLeft = NewOutRec;\n  };\n\n  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft) {\n    while (FirstLeft != null && FirstLeft.Pts == null) FirstLeft = FirstLeft.FirstLeft;\n\n    return FirstLeft;\n  };\n\n  ClipperLib.Clipper.prototype.JoinCommonEdges = function () {\n    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++) {\n      var join = this.m_Joins[i];\n      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n      if (outRec1.Pts == null || outRec2.Pts == null) continue; //get the polygon fragment with the correct hole state (FirstLeft)\n      //before calling JoinPoints() ...\n\n      var holeStateRec;\n      if (outRec1 == outRec2) holeStateRec = outRec1;else if (this.Param1RightOfParam2(outRec1, outRec2)) holeStateRec = outRec2;else if (this.Param1RightOfParam2(outRec2, outRec1)) holeStateRec = outRec1;else holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n      if (outRec1 == outRec2) {\n        //instead of joining two polygons, we've just created a new one by\n        //splitting one polygon into two.\n        outRec1.Pts = join.OutPt1;\n        outRec1.BottomPt = null;\n        outRec2 = this.CreateOutRec();\n        outRec2.Pts = join.OutPt2; //update all OutRec2.Pts Idx's ...\n\n        this.UpdateOutPtIdxs(outRec2); //We now need to check every OutRec.FirstLeft pointer. If it points\n        //to OutRec1 it may need to point to OutRec2 instead ...\n\n        if (this.m_UsingPolyTree) for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++) {\n          var oRec = this.m_PolyOuts[j];\n          if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole) continue;\n          if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2)) oRec.FirstLeft = outRec2;\n        }\n\n        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts)) {\n          //outRec2 is contained by outRec1 ...\n          outRec2.IsHole = !outRec1.IsHole;\n          outRec2.FirstLeft = outRec1; //fixup FirstLeft pointers that may need reassigning to OutRec1\n\n          if (this.m_UsingPolyTree) this.FixupFirstLefts2(outRec2, outRec1);\n          if ((outRec2.IsHole ^ this.ReverseSolution) == this.Area(outRec2) > 0) this.ReversePolyPtLinks(outRec2.Pts);\n        } else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts)) {\n          //outRec1 is contained by outRec2 ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec1.IsHole = !outRec2.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          outRec1.FirstLeft = outRec2; //fixup FirstLeft pointers that may need reassigning to OutRec1\n\n          if (this.m_UsingPolyTree) this.FixupFirstLefts2(outRec1, outRec2);\n          if ((outRec1.IsHole ^ this.ReverseSolution) == this.Area(outRec1) > 0) this.ReversePolyPtLinks(outRec1.Pts);\n        } else {\n          //the 2 polygons are completely separate ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft; //fixup FirstLeft pointers that may need reassigning to OutRec2\n\n          if (this.m_UsingPolyTree) this.FixupFirstLefts1(outRec1, outRec2);\n        }\n      } else {\n        //joined 2 polygons together ...\n        outRec2.Pts = null;\n        outRec2.BottomPt = null;\n        outRec2.Idx = outRec1.Idx;\n        outRec1.IsHole = holeStateRec.IsHole;\n        if (holeStateRec == outRec2) outRec1.FirstLeft = outRec2.FirstLeft;\n        outRec2.FirstLeft = outRec1; //fixup FirstLeft pointers that may need reassigning to OutRec1\n\n        if (this.m_UsingPolyTree) this.FixupFirstLefts2(outRec2, outRec1);\n      }\n    }\n  };\n\n  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec) {\n    var op = outrec.Pts;\n\n    do {\n      op.Idx = outrec.Idx;\n      op = op.Prev;\n    } while (op != outrec.Pts);\n  };\n\n  ClipperLib.Clipper.prototype.DoSimplePolygons = function () {\n    var i = 0;\n\n    while (i < this.m_PolyOuts.length) {\n      var outrec = this.m_PolyOuts[i++];\n      var op = outrec.Pts;\n      if (op == null || outrec.IsOpen) continue;\n\n      do //for each Pt in Polygon until duplicate found do ...\n      {\n        var op2 = op.Next;\n\n        while (op2 != outrec.Pts) {\n          if (ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt) && op2.Next != op && op2.Prev != op) {\n            //split the polygon into two ...\n            var op3 = op.Prev;\n            var op4 = op2.Prev;\n            op.Prev = op4;\n            op4.Next = op;\n            op2.Prev = op3;\n            op3.Next = op2;\n            outrec.Pts = op;\n            var outrec2 = this.CreateOutRec();\n            outrec2.Pts = op2;\n            this.UpdateOutPtIdxs(outrec2);\n\n            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts)) {\n              //OutRec2 is contained by OutRec1 ...\n              outrec2.IsHole = !outrec.IsHole;\n              outrec2.FirstLeft = outrec;\n              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n            } else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts)) {\n              //OutRec1 is contained by OutRec2 ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec.IsHole = !outrec2.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n              outrec.FirstLeft = outrec2;\n              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n            } else {\n              //the 2 polygons are separate ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n              if (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n            }\n\n            op2 = op; //ie get ready for the next iteration\n          }\n\n          op2 = op2.Next;\n        }\n\n        op = op.Next;\n      } while (op != outrec.Pts);\n    }\n  };\n\n  ClipperLib.Clipper.Area = function (poly) {\n    var cnt = poly.length;\n    if (cnt < 3) return 0;\n    var a = 0;\n\n    for (var i = 0, j = cnt - 1; i < cnt; ++i) {\n      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n      j = i;\n    }\n\n    return -a * 0.5;\n  };\n\n  ClipperLib.Clipper.prototype.Area = function (outRec) {\n    var op = outRec.Pts;\n    if (op == null) return 0;\n    var a = 0;\n\n    do {\n      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n      op = op.Next;\n    } while (op != outRec.Pts);\n\n    return a * 0.5;\n  };\n\n  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType) {\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n\n  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType) {\n    if (typeof fillType == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n\n  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2) {\n    var dx = pt1.X - pt2.X;\n    var dy = pt1.Y - pt2.Y;\n    return dx * dx + dy * dy;\n  };\n\n  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2) {\n    //The equation of a line in general form (Ax + By + C = 0)\n    //given 2 points (x¹,y¹) & (x²,y²) is ...\n    //(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0\n    //A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹\n    //perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)\n    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n    var A = ln1.Y - ln2.Y;\n    var B = ln2.X - ln1.X;\n    var C = A * ln1.X + B * ln1.Y;\n    C = A * pt.X + B * pt.Y - C;\n    return C * C / (A * A + B * B);\n  };\n\n  ClipperLib.Clipper.SlopesNearCollinear = function (pt1, pt2, pt3, distSqrd) {\n    //this function is more accurate when the point that's GEOMETRICALLY\n    //between the other 2 points is the one that's tested for distance.\n    //nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n    if (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y)) {\n      if (pt1.X > pt2.X == pt1.X < pt3.X) return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;else if (pt2.X > pt1.X == pt2.X < pt3.X) return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;else return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n    } else {\n      if (pt1.Y > pt2.Y == pt1.Y < pt3.Y) return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;else if (pt2.Y > pt1.Y == pt2.Y < pt3.Y) return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;else return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n    }\n  };\n\n  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd) {\n    var dx = pt1.X - pt2.X;\n    var dy = pt1.Y - pt2.Y;\n    return dx * dx + dy * dy <= distSqrd;\n  }; //------------------------------------------------------------------------------\n\n\n  ClipperLib.Clipper.ExcludeOp = function (op) {\n    var result = op.Prev;\n    result.Next = op.Next;\n    op.Next.Prev = result;\n    result.Idx = 0;\n    return result;\n  };\n\n  ClipperLib.Clipper.CleanPolygon = function (path, distance) {\n    if (typeof distance == \"undefined\") distance = 1.415; //distance = proximity in units/pixels below which vertices will be stripped.\n    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n    //both x & y coords within 1 unit, then the second vertex will be stripped.\n\n    var cnt = path.length;\n    if (cnt == 0) return new Array();\n    var outPts = new Array(cnt);\n\n    for (var i = 0; i < cnt; ++i) outPts[i] = new ClipperLib.OutPt();\n\n    for (var i = 0; i < cnt; ++i) {\n      outPts[i].Pt = path[i];\n      outPts[i].Next = outPts[(i + 1) % cnt];\n      outPts[i].Next.Prev = outPts[i];\n      outPts[i].Idx = 0;\n    }\n\n    var distSqrd = distance * distance;\n    var op = outPts[0];\n\n    while (op.Idx == 0 && op.Next != op.Prev) {\n      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd)) {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      } else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd)) {\n        ClipperLib.Clipper.ExcludeOp(op.Next);\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt -= 2;\n      } else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd)) {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      } else {\n        op.Idx = 1;\n        op = op.Next;\n      }\n    }\n\n    if (cnt < 3) cnt = 0;\n    var result = new Array(cnt);\n\n    for (var i = 0; i < cnt; ++i) {\n      result[i] = new ClipperLib.IntPoint(op.Pt);\n      op = op.Next;\n    }\n\n    outPts = null;\n    return result;\n  };\n\n  ClipperLib.Clipper.CleanPolygons = function (polys, distance) {\n    var result = new Array(polys.length);\n\n    for (var i = 0, ilen = polys.length; i < ilen; i++) result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n\n    return result;\n  };\n\n  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed) {\n    var delta = IsClosed ? 1 : 0;\n    var polyCnt = pattern.length;\n    var pathCnt = path.length;\n    var result = new Array();\n    if (IsSum) for (var i = 0; i < pathCnt; i++) {\n      var p = new Array(polyCnt);\n\n      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j]) p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n\n      result.push(p);\n    } else for (var i = 0; i < pathCnt; i++) {\n      var p = new Array(polyCnt);\n\n      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j]) p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n\n      result.push(p);\n    }\n    var quads = new Array();\n\n    for (var i = 0; i < pathCnt - 1 + delta; i++) for (var j = 0; j < polyCnt; j++) {\n      var quad = new Array();\n      quad.push(result[i % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n      quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n      if (!ClipperLib.Clipper.Orientation(quad)) quad.reverse();\n      quads.push(quad);\n    }\n\n    return quads;\n  };\n\n  ClipperLib.Clipper.MinkowskiSum = function (pattern, path_or_paths, pathIsClosed) {\n    if (!(path_or_paths[0] instanceof Array)) {\n      var path = path_or_paths;\n      var paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n      var c = new ClipperLib.Clipper();\n      c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n      c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n      return paths;\n    } else {\n      var paths = path_or_paths;\n      var solution = new ClipperLib.Paths();\n      var c = new ClipperLib.Clipper();\n\n      for (var i = 0; i < paths.length; ++i) {\n        var tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n        c.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\n        if (pathIsClosed) {\n          var path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n          c.AddPath(path, ClipperLib.PolyType.ptClip, true);\n        }\n      }\n\n      c.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n      return solution;\n    }\n  }; //------------------------------------------------------------------------------\n\n\n  ClipperLib.Clipper.TranslatePath = function (path, delta) {\n    var outPath = new ClipperLib.Path();\n\n    for (var i = 0; i < path.length; i++) outPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\n    return outPath;\n  }; //------------------------------------------------------------------------------\n\n\n  ClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2) {\n    var paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n    var c = new ClipperLib.Clipper();\n    c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n    return paths;\n  };\n\n  ClipperLib.Clipper.PolyTreeToPaths = function (polytree) {\n    var result = new Array(); //result.set_Capacity(polytree.get_Total());\n\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n    return result;\n  };\n\n  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths) {\n    var match = true;\n\n    switch (nt) {\n      case ClipperLib.Clipper.NodeType.ntOpen:\n        return;\n\n      case ClipperLib.Clipper.NodeType.ntClosed:\n        match = !polynode.IsOpen;\n        break;\n\n      default:\n        break;\n    }\n\n    if (polynode.m_polygon.length > 0 && match) paths.push(polynode.m_polygon);\n\n    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3]) ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n  };\n\n  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree) {\n    var result = new ClipperLib.Paths(); //result.set_Capacity(polytree.ChildCount());\n\n    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++) if (polytree.Childs()[i].IsOpen) result.push(polytree.Childs()[i].m_polygon);\n\n    return result;\n  };\n\n  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree) {\n    var result = new ClipperLib.Paths(); //result.set_Capacity(polytree.Total());\n\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n    return result;\n  };\n\n  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n  ClipperLib.Clipper.NodeType = {\n    ntAny: 0,\n    ntOpen: 1,\n    ntClosed: 2\n  };\n\n  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance) {\n    if (typeof miterLimit == \"undefined\") miterLimit = 2;\n    if (typeof arcTolerance == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n    this.m_destPolys = new ClipperLib.Paths();\n    this.m_srcPoly = new ClipperLib.Path();\n    this.m_destPoly = new ClipperLib.Path();\n    this.m_normals = new Array();\n    this.m_delta = 0;\n    this.m_sinA = 0;\n    this.m_sin = 0;\n    this.m_cos = 0;\n    this.m_miterLim = 0;\n    this.m_StepsPerRad = 0;\n    this.m_lowest = new ClipperLib.IntPoint();\n    this.m_polyNodes = new ClipperLib.PolyNode();\n    this.MiterLimit = miterLimit;\n    this.ArcTolerance = arcTolerance;\n    this.m_lowest.X = -1;\n  };\n\n  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n\n  ClipperLib.ClipperOffset.prototype.Clear = function () {\n    ClipperLib.Clear(this.m_polyNodes.Childs());\n    this.m_lowest.X = -1;\n  };\n\n  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n\n  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType) {\n    var highI = path.length - 1;\n    if (highI < 0) return;\n    var newNode = new ClipperLib.PolyNode();\n    newNode.m_jointype = joinType;\n    newNode.m_endtype = endType; //strip duplicate points from path and also get index to the lowest point ...\n\n    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon) while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI])) highI--; //newNode.m_polygon.set_Capacity(highI + 1);\n\n    newNode.m_polygon.push(path[0]);\n    var j = 0,\n        k = 0;\n\n    for (var i = 1; i <= highI; i++) if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i])) {\n      j++;\n      newNode.m_polygon.push(path[i]);\n      if (path[i].Y > newNode.m_polygon[k].Y || path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X) k = j;\n    }\n\n    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n    this.m_polyNodes.AddChild(newNode); //if this path's lowest pt is lower than all the others then update m_lowest\n\n    if (endType != ClipperLib.EndType.etClosedPolygon) return;\n    if (this.m_lowest.X < 0) this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);else {\n      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n      if (newNode.m_polygon[k].Y > ip.Y || newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X) this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    }\n  };\n\n  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType) {\n    for (var i = 0, ilen = paths.length; i < ilen; i++) this.AddPath(paths[i], joinType, endType);\n  };\n\n  ClipperLib.ClipperOffset.prototype.FixOrientations = function () {\n    //fixup orientations of all closed paths if the orientation of the\n    //closed path with the lowermost vertex is wrong ...\n    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon)) {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)) node.m_polygon.reverse();\n      }\n    } else {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon)) node.m_polygon.reverse();\n      }\n    }\n  };\n\n  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2) {\n    var dx = pt2.X - pt1.X;\n    var dy = pt2.Y - pt1.Y;\n    if (dx == 0 && dy == 0) return new ClipperLib.DoublePoint(0, 0);\n    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n    dx *= f;\n    dy *= f;\n    return new ClipperLib.DoublePoint(dy, -dx);\n  };\n\n  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta) {\n    this.m_destPolys = new Array();\n    this.m_delta = delta; //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n\n    if (ClipperLib.ClipperBase.near_zero(delta)) {\n      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon) this.m_destPolys.push(node.m_polygon);\n      }\n\n      return;\n    } //see offset_triginometry3.svg in the documentation folder ...\n\n\n    if (this.MiterLimit > 2) this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);else this.m_miterLim = 0.5;\n    var y;\n    if (this.ArcTolerance <= 0) y = ClipperLib.ClipperOffset.def_arc_tolerance;else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance) y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;else y = this.ArcTolerance; //see offset_triginometry2.svg in the documentation folder ...\n\n    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n    if (delta < 0) this.m_sin = -this.m_sin; //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n      var node = this.m_polyNodes.Childs()[i];\n      this.m_srcPoly = node.m_polygon;\n      var len = this.m_srcPoly.length;\n      if (len == 0 || delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)) continue;\n      this.m_destPoly = new Array();\n\n      if (len == 1) {\n        if (node.m_jointype == ClipperLib.JoinType.jtRound) {\n          var X = 1,\n              Y = 0;\n\n          for (var j = 1; j <= steps; j++) {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            var X2 = X;\n            X = X * this.m_cos - this.m_sin * Y;\n            Y = X2 * this.m_sin + Y * this.m_cos;\n          }\n        } else {\n          var X = -1,\n              Y = -1;\n\n          for (var j = 0; j < 4; ++j) {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            if (X < 0) X = 1;else if (Y < 0) Y = 1;else X = -1;\n          }\n        }\n\n        this.m_destPolys.push(this.m_destPoly);\n        continue;\n      } //build m_normals ...\n\n\n      this.m_normals.length = 0; //this.m_normals.set_Capacity(len);\n\n      for (var j = 0; j < len - 1; j++) this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n\n      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon) this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));else this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon) {\n        var k = len - 1;\n\n        for (var j = 0; j < len; j++) k = this.OffsetPoint(j, k, node.m_jointype);\n\n        this.m_destPolys.push(this.m_destPoly);\n      } else if (node.m_endtype == ClipperLib.EndType.etClosedLine) {\n        var k = len - 1;\n\n        for (var j = 0; j < len; j++) k = this.OffsetPoint(j, k, node.m_jointype);\n\n        this.m_destPolys.push(this.m_destPoly);\n        this.m_destPoly = new Array(); //re-build m_normals ...\n\n        var n = this.m_normals[len - 1];\n\n        for (var j = len - 1; j > 0; j--) this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\n        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n        k = 0;\n\n        for (var j = len - 1; j >= 0; j--) k = this.OffsetPoint(j, k, node.m_jointype);\n\n        this.m_destPolys.push(this.m_destPoly);\n      } else {\n        var k = 0;\n\n        for (var j = 1; j < len - 1; ++j) k = this.OffsetPoint(j, k, node.m_jointype);\n\n        var pt1;\n\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt) {\n          var j = len - 1;\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n        } else {\n          var j = len - 1;\n          k = len - 2;\n          this.m_sinA = 0;\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare) this.DoSquare(j, k);else this.DoRound(j, k);\n        } //re-build m_normals ...\n\n\n        for (var j = len - 1; j > 0; j--) this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\n        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n        k = len - 1;\n\n        for (var j = k - 1; j > 0; --j) k = this.OffsetPoint(j, k, node.m_jointype);\n\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt) {\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n        } else {\n          k = 1;\n          this.m_sinA = 0;\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare) this.DoSquare(0, 1);else this.DoRound(0, 1);\n        }\n\n        this.m_destPolys.push(this.m_destPoly);\n      }\n    }\n  };\n\n  ClipperLib.ClipperOffset.prototype.Execute = function () {\n    var a = arguments,\n        ispolytree = a[0] instanceof ClipperLib.PolyTree;\n\n    if (!ispolytree) // function (solution, delta)\n      {\n        var solution = a[0],\n            delta = a[1];\n        ClipperLib.Clear(solution);\n        this.FixOrientations();\n        this.DoOffset(delta); //now clean up 'corners' ...\n\n        var clpr = new ClipperLib.Clipper(0);\n        clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\n        if (delta > 0) {\n          clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n        } else {\n          var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n          var outer = new ClipperLib.Path();\n          outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n          outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n          outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n          outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n          clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n          clpr.ReverseSolution = true;\n          clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n          if (solution.length > 0) solution.splice(0, 1);\n        } //console.log(JSON.stringify(solution));\n\n      } else // function (polytree, delta)\n      {\n        var solution = a[0],\n            delta = a[1];\n        solution.Clear();\n        this.FixOrientations();\n        this.DoOffset(delta); //now clean up 'corners' ...\n\n        var clpr = new ClipperLib.Clipper(0);\n        clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\n        if (delta > 0) {\n          clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n        } else {\n          var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n          var outer = new ClipperLib.Path();\n          outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n          outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n          outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n          outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n          clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n          clpr.ReverseSolution = true;\n          clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative); //remove the outer PolyNode rectangle ...\n\n          if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0) {\n            var outerNode = solution.Childs()[0]; //solution.Childs.set_Capacity(outerNode.ChildCount);\n\n            solution.Childs()[0] = outerNode.Childs()[0];\n            solution.Childs()[0].m_Parent = solution;\n\n            for (var i = 1; i < outerNode.ChildCount(); i++) solution.AddChild(outerNode.Childs()[i]);\n          } else solution.Clear();\n        }\n      }\n  };\n\n  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype) {\n    //cross product ...\n    this.m_sinA = this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y;\n\n    if (Math.abs(this.m_sinA * this.m_delta) < 1.0) {\n      //dot product ...\n      var cosA = this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y;\n\n      if (cosA > 0) // angle ==> 0 degrees\n        {\n          this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n          return k;\n        } //else angle ==> 180 degrees\n\n    } else if (this.m_sinA > 1) this.m_sinA = 1.0;else if (this.m_sinA < -1) this.m_sinA = -1.0;\n\n    if (this.m_sinA * this.m_delta < 0) {\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n    } else switch (jointype) {\n      case ClipperLib.JoinType.jtMiter:\n        {\n          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n          if (r >= this.m_miterLim) this.DoMiter(j, k, r);else this.DoSquare(j, k);\n          break;\n        }\n\n      case ClipperLib.JoinType.jtSquare:\n        this.DoSquare(j, k);\n        break;\n\n      case ClipperLib.JoinType.jtRound:\n        this.DoRound(j, k);\n        break;\n    }\n\n    k = j;\n    return k;\n  };\n\n  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k) {\n    var dx = Math.tan(Math.atan2(this.m_sinA, this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n    this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n    this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n  };\n\n  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r) {\n    var q = this.m_delta / r;\n    this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n  };\n\n  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k) {\n    var a = Math.atan2(this.m_sinA, this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n    var steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n    var X = this.m_normals[k].X,\n        Y = this.m_normals[k].Y,\n        X2;\n\n    for (var i = 0; i < steps; ++i) {\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n      X2 = X;\n      X = X * this.m_cos - this.m_sin * Y;\n      Y = X2 * this.m_sin + Y * this.m_cos;\n    }\n\n    this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n  };\n\n  ClipperLib.Error = function (message) {\n    try {\n      throw new Error(message);\n    } catch (err) {\n      alert(err.message);\n    }\n  }; // ---------------------------------\n  // JS extension by Timo 2013\n\n\n  ClipperLib.JS = {};\n\n  ClipperLib.JS.AreaOfPolygon = function (poly, scale) {\n    if (!scale) scale = 1;\n    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n  };\n\n  ClipperLib.JS.AreaOfPolygons = function (poly, scale) {\n    if (!scale) scale = 1;\n    var area = 0;\n\n    for (var i = 0; i < poly.length; i++) {\n      area += ClipperLib.Clipper.Area(poly[i]);\n    }\n\n    return area / (scale * scale);\n  };\n\n  ClipperLib.JS.BoundsOfPath = function (path, scale) {\n    return ClipperLib.JS.BoundsOfPaths([path], scale);\n  };\n\n  ClipperLib.JS.BoundsOfPaths = function (paths, scale) {\n    if (!scale) scale = 1;\n    var bounds = ClipperLib.Clipper.GetBounds(paths);\n    bounds.left /= scale;\n    bounds.bottom /= scale;\n    bounds.right /= scale;\n    bounds.top /= scale;\n    return bounds;\n  }; // Clean() joins vertices that are too near each other\n  // and causes distortion to offsetted polygons without cleaning\n\n\n  ClipperLib.JS.Clean = function (polygon, delta) {\n    if (!(polygon instanceof Array)) return [];\n    var isPolygons = polygon[0] instanceof Array;\n    var polygon = ClipperLib.JS.Clone(polygon);\n\n    if (typeof delta != \"number\" || delta === null) {\n      ClipperLib.Error(\"Delta is not a number in Clean().\");\n      return polygon;\n    }\n\n    if (polygon.length === 0 || polygon.length == 1 && polygon[0].length === 0 || delta < 0) return polygon;\n    if (!isPolygons) polygon = [polygon];\n    var k_length = polygon.length;\n    var len, poly, result, d, p, j, i;\n    var results = [];\n\n    for (var k = 0; k < k_length; k++) {\n      poly = polygon[k];\n      len = poly.length;\n      if (len === 0) continue;else if (len < 3) {\n        result = poly;\n        results.push(result);\n        continue;\n      }\n      result = poly;\n      d = delta * delta; //d = Math.floor(c_delta * c_delta);\n\n      p = poly[0];\n      j = 1;\n\n      for (i = 1; i < len; i++) {\n        if ((poly[i].X - p.X) * (poly[i].X - p.X) + (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d) continue;\n        result[j] = poly[i];\n        p = poly[i];\n        j++;\n      }\n\n      p = poly[j - 1];\n      if ((poly[0].X - p.X) * (poly[0].X - p.X) + (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d) j--;\n      if (j < len) result.splice(j, len - j);\n      if (result.length) results.push(result);\n    }\n\n    if (!isPolygons && results.length) results = results[0];else if (!isPolygons && results.length === 0) results = [];else if (isPolygons && results.length === 0) results = [[]];\n    return results;\n  }; // Make deep copy of Polygons or Polygon\n  // so that also IntPoint objects are cloned and not only referenced\n  // This should be the fastest way\n\n\n  ClipperLib.JS.Clone = function (polygon) {\n    if (!(polygon instanceof Array)) return [];\n    if (polygon.length === 0) return [];else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n    var isPolygons = polygon[0] instanceof Array;\n    if (!isPolygons) polygon = [polygon];\n    var len = polygon.length,\n        plen,\n        i,\n        j,\n        result;\n    var results = new Array(len);\n\n    for (i = 0; i < len; i++) {\n      plen = polygon[i].length;\n      result = new Array(plen);\n\n      for (j = 0; j < plen; j++) {\n        result[j] = {\n          X: polygon[i][j].X,\n          Y: polygon[i][j].Y\n        };\n      }\n\n      results[i] = result;\n    }\n\n    if (!isPolygons) results = results[0];\n    return results;\n  }; // Removes points that doesn't affect much to the visual appearance.\n  // If middle point is at or under certain distance (tolerance) of the line segment between\n  // start and end point, the middle point is removed.\n\n\n  ClipperLib.JS.Lighten = function (polygon, tolerance) {\n    if (!(polygon instanceof Array)) return [];\n\n    if (typeof tolerance != \"number\" || tolerance === null) {\n      ClipperLib.Error(\"Tolerance is not a number in Lighten().\");\n      return ClipperLib.JS.Clone(polygon);\n    }\n\n    if (polygon.length === 0 || polygon.length == 1 && polygon[0].length === 0 || tolerance < 0) {\n      return ClipperLib.JS.Clone(polygon);\n    }\n\n    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n    var bxax, byay, l, ax, ay;\n    var len = polygon.length;\n    var toleranceSq = tolerance * tolerance;\n    var results = [];\n\n    for (i = 0; i < len; i++) {\n      poly = polygon[i];\n      plen = poly.length;\n      if (plen == 0) continue;\n\n      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n      {\n        poly2 = [];\n        plen = poly.length; // the first have to added to the end, if first and last are not the same\n        // this way we ensure that also the actual last point can be removed if needed\n\n        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y) {\n          addlast = 1;\n          poly.push({\n            X: poly[0].X,\n            Y: poly[0].Y\n          });\n          plen = poly.length;\n        } else addlast = 0;\n\n        rem = []; // Indexes of removed points\n\n        for (j = 0; j < plen - 2; j++) {\n          A = poly[j]; // Start point of line segment\n\n          P = poly[j + 1]; // Middle point. This is the one to be removed.\n\n          B = poly[j + 2]; // End point of line segment\n\n          ax = A.X;\n          ay = A.Y;\n          bxax = B.X - ax;\n          byay = B.Y - ay;\n\n          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n            {\n              l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n\n              if (l > 1) {\n                ax = B.X;\n                ay = B.Y;\n              } else if (l > 0) {\n                ax += bxax * l;\n                ay += byay * l;\n              }\n            }\n\n          bxax = P.X - ax;\n          byay = P.Y - ay;\n          d = bxax * bxax + byay * byay;\n\n          if (d <= toleranceSq) {\n            rem[j + 1] = 1;\n            j++; // when removed, transfer the pointer to the next one\n          }\n        } // add all unremoved points to poly2\n\n\n        poly2.push({\n          X: poly[0].X,\n          Y: poly[0].Y\n        });\n\n        for (j = 1; j < plen - 1; j++) if (!rem[j]) poly2.push({\n          X: poly[j].X,\n          Y: poly[j].Y\n        });\n\n        poly2.push({\n          X: poly[plen - 1].X,\n          Y: poly[plen - 1].Y\n        }); // if the first point was added to the end, remove it\n\n        if (addlast) poly.pop(); // break, if there was not anymore removed points\n\n        if (!rem.length) break; // else continue looping using poly2, to check if there are points to remove\n        else poly = poly2;\n      }\n\n      plen = poly2.length; // remove duplicate from end, if needed\n\n      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y) {\n        poly2.pop();\n      }\n\n      if (poly2.length > 2) // to avoid two-point-polygons\n        results.push(poly2);\n    }\n\n    if (!(polygon[0] instanceof Array)) results = results[0];\n    if (typeof results == \"undefined\") results = [[]];\n    return results;\n  };\n\n  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale) {\n    if (typeof path == \"undefined\") return 0;\n    var sqrt = Math.sqrt;\n    var perimeter = 0.0;\n    var p1,\n        p2,\n        p1x = 0.0,\n        p1y = 0.0,\n        p2x = 0.0,\n        p2y = 0.0;\n    var j = path.length;\n    if (j < 2) return 0;\n\n    if (closed) {\n      path[j] = path[0];\n      j++;\n    }\n\n    while (--j) {\n      p1 = path[j];\n      p1x = p1.X;\n      p1y = p1.Y;\n      p2 = path[j - 1];\n      p2x = p2.X;\n      p2y = p2.Y;\n      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n    }\n\n    if (closed) path.pop();\n    return perimeter / scale;\n  };\n\n  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale) {\n    if (!scale) scale = 1;\n    var perimeter = 0;\n\n    for (var i = 0; i < paths.length; i++) {\n      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n    }\n\n    return perimeter;\n  };\n\n  ClipperLib.JS.ScaleDownPath = function (path, scale) {\n    var i, p;\n    if (!scale) scale = 1;\n    i = path.length;\n\n    while (i--) {\n      p = path[i];\n      p.X = p.X / scale;\n      p.Y = p.Y / scale;\n    }\n  };\n\n  ClipperLib.JS.ScaleDownPaths = function (paths, scale) {\n    var i, j, p;\n    if (!scale) scale = 1;\n    i = paths.length;\n\n    while (i--) {\n      j = paths[i].length;\n\n      while (j--) {\n        p = paths[i][j];\n        p.X = p.X / scale;\n        p.Y = p.Y / scale;\n      }\n    }\n  };\n\n  ClipperLib.JS.ScaleUpPath = function (path, scale) {\n    var i,\n        p,\n        round = Math.round;\n    if (!scale) scale = 1;\n    i = path.length;\n\n    while (i--) {\n      p = path[i];\n      p.X = round(p.X * scale);\n      p.Y = round(p.Y * scale);\n    }\n  };\n\n  ClipperLib.JS.ScaleUpPaths = function (paths, scale) {\n    var i,\n        j,\n        p,\n        round = Math.round;\n    if (!scale) scale = 1;\n    i = paths.length;\n\n    while (i--) {\n      j = paths[i].length;\n\n      while (j--) {\n        p = paths[i][j];\n        p.X = round(p.X * scale);\n        p.Y = round(p.Y * scale);\n      }\n    }\n  };\n\n  ClipperLib.ExPolygons = function () {\n    return [];\n  };\n\n  ClipperLib.ExPolygon = function () {\n    this.outer = null;\n    this.holes = null;\n  };\n\n  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons) {\n    var ep = new ClipperLib.ExPolygon();\n    ep.outer = polynode.Contour();\n    var childs = polynode.Childs();\n    var ilen = childs.length;\n    ep.holes = new Array(ilen);\n    var node, n, i, j, childs2, jlen;\n\n    for (i = 0; i < ilen; i++) {\n      node = childs[i];\n      ep.holes[i] = node.Contour(); //Add outer polygons contained by (nested within) holes ...\n\n      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++) {\n        n = childs2[j];\n        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n      }\n    }\n\n    expolygons.push(ep);\n  };\n\n  ClipperLib.JS.ExPolygonsToPaths = function (expolygons) {\n    var a, i, alen, ilen;\n    var paths = new ClipperLib.Paths();\n\n    for (a = 0, alen = expolygons.length; a < alen; a++) {\n      paths.push(expolygons[a].outer);\n\n      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++) {\n        paths.push(expolygons[a].holes[i]);\n      }\n    }\n\n    return paths;\n  };\n\n  ClipperLib.JS.PolyTreeToExPolygons = function (polytree) {\n    var expolygons = new ClipperLib.ExPolygons();\n    var node, i, childs, ilen;\n\n    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++) {\n      node = childs[i];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n    }\n\n    return expolygons;\n  };\n})();","map":{"version":3,"names":["use_int32","use_xyz","use_lines","ClipperLib","isNode","module","exports","define","amd","document","window","self","navigator_appName","nav","navigator","userAgent","toString","toLowerCase","appName","browser","indexOf","chrome","chromium","safari","firefox","firefox17","firefox15","firefox3","opera","msie10","msie9","msie8","msie7","msie","biginteger_used","dbits","canary","j_lm","BigInteger","a","b","c","fromInt","fromNumber","fromString","nbi","undefined","am1","i","x","w","j","n","v","Math","floor","am2","xl","xh","l","h","m","am3","prototype","am","DB","DM","DV","BI_FP","FV","pow","F1","F2","BI_RM","BI_RC","Array","rr","vv","charCodeAt","int2char","charAt","intAt","s","bnpCopyTo","r","t","bnpFromInt","nbv","bnpFromString","k","fromRadix","length","mi","sh","clamp","ZERO","subTo","bnpClamp","bnToString","negate","toRadix","km","d","p","bnNegate","bnAbs","bnCompareTo","nbits","bnBitLength","bnpDLShiftTo","bnpDRShiftTo","max","bnpLShiftTo","bs","cbs","bm","ds","bnpRShiftTo","bnpSubTo","min","bnpMultiplyTo","abs","y","bnpSquareTo","bnpDivRemTo","q","pm","pt","copyTo","ts","ms","nsh","lShiftTo","ys","y0","yt","d1","d2","e","dlShiftTo","compareTo","ONE","qd","drShiftTo","rShiftTo","bnMod","divRemTo","Classic","cConvert","mod","cRevert","cReduce","cMulTo","multiplyTo","reduce","cSqrTo","squareTo","convert","revert","mulTo","sqrTo","bnpInvDigit","Montgomery","mp","invDigit","mpl","mph","um","mt2","montConvert","montRevert","montReduce","u0","montSqrTo","montMulTo","bnpIsEven","bnpExp","z","r2","g","bnModPowInt","isEven","exp","bitLength","modPowInt","bnClone","bnIntValue","bnByteValue","bnShortValue","bnpChunkSize","LN2","log","bnSigNum","bnpToRadix","signum","cs","chunkSize","intValue","substr","bnpFromRadix","dMultiply","dAddOffset","bnpFromNumber","testBit","bitwiseTo","shiftLeft","op_or","isProbablePrime","nextBytes","bnToByteArray","bnEquals","bnMin","bnMax","bnpBitwiseTo","op","f","op_and","bnAnd","bnOr","op_xor","bnXor","op_andnot","bnAndNot","bnNot","bnShiftLeft","bnShiftRight","lbit","bnGetLowestSetBit","cbit","bnBitCount","bnTestBit","bnpChangeBit","bnSetBit","changeBit","bnClearBit","bnFlipBit","bnpAddTo","bnAdd","addTo","bnSubtract","bnMultiply","bnSquare","bnDivide","bnRemainder","bnDivideAndRemainder","bnpDMultiply","bnpDAddOffset","NullExp","nNop","nMulTo","nSqrTo","bnPow","bnpMultiplyLowerTo","bnpMultiplyUpperTo","Barrett","q3","mu","divide","barrettConvert","barrettRevert","barrettReduce","multiplyUpperTo","multiplyLowerTo","barrettSqrTo","barrettMulTo","bnModPow","k1","g2","is1","bnGCD","clone","getLowestSetBit","bnpModInt","bnModInverse","ac","u","subtract","add","lowprimes","lplim","bnIsProbablePrime","modInt","millerRabin","bnpMillerRabin","n1","shiftRight","random","modPow","byteValue","shortValue","toByteArray","equals","and","or","xor","andNot","not","bitCount","setBit","clearBit","flipBit","multiply","remainder","divideAndRemainder","modInverse","gcd","square","Int128","IsNegative","op_Equality","val1","val2","op_Inequality","op_GreaterThan","op_LessThan","op_Addition","lhs","rhs","op_Subtraction","Int128Mul","op_Division","ToDouble","parseFloat","Inherit","ce","ce2","Object","getOwnPropertyNames","$baseCtor","props","getOwnPropertyDescriptor","defineProperty","Path","Paths","DoublePoint","arguments","X","Y","DoublePoint0","DoublePoint1","dp","DoublePoint2","PolyNode","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","result","node","ChildCount","Contour","AddChild","Child","cnt","push","GetNext","GetNextSiblingUp","Childs","Parent","IsHole","PolyTree","m_AllPolys","call","Clear","ilen","GetFirst","Total","Math_Abs_Int64","Math_Abs_Int32","Math_Abs_Double","Math_Max_Int32_Int32","Cast_Int32","Cast_Int64","ceil","Number","toInteger","parseInt","PI","PI2","IntPoint","alen","Z","Clipper","Round","IntPoint0","IntPoint1","IntPoint1dp","IntPoint2","IntPoint3","IntRect","left","top","right","bottom","ir","IntRect0","IntRect1","IntRect4","ClipType","ctIntersection","ctUnion","ctDifference","ctXor","PolyType","ptSubject","ptClip","PolyFillType","pftEvenOdd","pftNonZero","pftPositive","pftNegative","JoinType","jtSquare","jtRound","jtMiter","EndType","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","etClosedPolygon","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_UseFullRange","m_HasOpenPaths","PreserveCollinear","horizontal","Skip","Unassigned","tolerance","loRange","hiRange","near_zero","val","IsHorizontal","PointIsVertex","pp","pp2","PointOnLineSegment","linePt1","linePt2","UseFullRange","PointOnPolygon","SlopesEqual","e1","e2","pt1","pt2","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","jlen","tmpLm","RangeTest","useFullRange","Value","Error","InitEdge","eNext","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","LeftBoundIsForward","EStart","Result","Horz","locMin","InsertLocalMinima","ReverseHorizontal","AddPath","pg","Closed","highI","edges","IsFlat","$1","eStart","eLoopStop","RemoveEdge","Pt2IsBetweenPt1AndPt3","leftBoundIsForward","EMin","AddPaths","ppg","closed","newLm","PopLocalMinima","tmp","Reset","lm","InitOptions","m_PolyOuts","m_ClipType","m_Scanbeam","m_ActiveEdges","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","StrictlySimple","ZFillFunction","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","DisposeScanbeamList","sb2","InsertScanbeam","newSb","Execute","ispolytree","clipType","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","outRec","orfl","botY","PopScanbeam","InsertLocalMinimaIntoAEL","ProcessHorizontals","topY","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolygon","DoSimplePolygons","DisposeOutRec","index","AddJoin","Op1","Op2","AddGhostJoin","Op","SetZ","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","edge","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","Inside","CopyAELToSEL","SwapPositionsInAEL","edge1","edge2","next","prev","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","outPt","CreateOutRec","ToFront","newOp","SetHoleState","SwapPoints","seg1a","seg1b","seg2a","seg2b","isHole","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","Param1RightOfParam2","GetOutRec","idx","outrec","holeStateRec","p1_lft","p1_rt","p2_lft","p2_rt","side","OKIdx","ObsoleteIdx","pp1","SwapSides","SwapPolyIndexes","outIdx","e1Contributing","e2Contributing","oldE1WindCnt","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Wc2","e2Wc2","DeleteFromAEL","AelPrev","AelNext","DeleteFromSEL","SelPrev","SelNext","UpdateEdgeIntoAEL","isTopOfScanbeam","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","IsLastHorz","GetNextInAEL","op1","eNextHorz","op2","IsMinima","IsMaxima","IsIntermediate","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","sort","iNode","R1","round","R2","R3","R4","currentY","ip","b1","b2","IsMaximaEdge","DoMaxima","ReversePaths","polys","len","reverse","Orientation","poly","PointCount","pts","polyg","pn","lastOK","DupOutPt","InsertAfter","GetOverlap","a1","a2","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","reverse2","DiscardLeftSide","Reverse1","Reverse2","GetBounds","paths","GetBounds2","ops","opStart","PointInPolygon","path","ipNext","startOp","ptx","pty","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","res","FixupFirstLefts1","OldOutRec","NewOutRec","firstLeft","ParseFirstLeft","FixupFirstLefts2","$i2","$t2","$l2","join","UpdateOutPtIdxs","oRec","op3","op4","outrec2","SimplifyPolygon","fillType","SimplifyPolygons","DistanceSqrd","dx","dy","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","distance","outPts","CleanPolygons","Minkowski","pattern","IsSum","IsClosed","delta","polyCnt","pathCnt","quads","quad","MinkowskiSum","path_or_paths","pathIsClosed","TranslatePath","outPath","MinkowskiDiff","poly1","poly2","PolyTreeToPaths","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","match","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","ClipperOffset","miterLimit","arcTolerance","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","MiterLimit","ArcTolerance","two_pi","joinType","endType","FixOrientations","GetUnitNormal","sqrt","DoOffset","steps","acos","sin","cos","X2","OffsetPoint","DoSquare","DoRound","clpr","outer","splice","outerNode","jointype","cosA","DoMiter","tan","atan2","message","err","alert","JS","AreaOfPolygon","scale","AreaOfPolygons","area","BoundsOfPath","BoundsOfPaths","bounds","Clean","polygon","isPolygons","Clone","k_length","results","plen","Lighten","P","rem","addlast","bxax","byay","ax","ay","toleranceSq","pop","PerimeterOfPath","perimeter","p1","p2","p1x","p1y","p2x","p2y","PerimeterOfPaths","ScaleDownPath","ScaleDownPaths","ScaleUpPath","ScaleUpPaths","ExPolygons","ExPolygon","holes","AddOuterPolyNodeToExPolygons","expolygons","ep","childs","childs2","ExPolygonsToPaths","PolyTreeToExPolygons"],"sources":["/Users/romanradionov/PycharmProjects/reactleafletgeodjango/my-app/node_modules/clipper-lib/clipper.js"],"sourcesContent":["// rev 482\n/********************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.2.1                                                          *\n * Date      :  31 October 2014                                                 *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2014                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.2.1.0                                                         *\n * Date      :  17 June 2016                                                 *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n * Because Javascript lacks support for 64-bit integers, the space              *\n * is a little more restricted than in C# version.                              *\n *                                                                              *\n * C# version has support for coordinate space:                                 *\n * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n * while Javascript version has support for space:                              *\n * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n *                                                                              *\n * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n * http://jsperf.com/big-integer-library-test                                   *\n *                                                                              *\n * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Basic JavaScript BN library - subset useful for RSA encryption.              *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n * Copyright (c) 2005  Tom Wu                                                   *\n * All Rights Reserved.                                                         *\n * See \"LICENSE\" for details:                                                   *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n *                                                                              *\n *******************************************************************************/\n(function ()\n{\n  \"use strict\";\n  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n  //improve performance but coordinate values are limited to the range +/- 46340\n  var use_int32 = false;\n  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n  var use_xyz = false;\n  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n  var use_lines = true;\n\n  var ClipperLib = {};\n  var isNode = false;\n  if (typeof module !== 'undefined' && module.exports)\n  {\n    module.exports = ClipperLib;\n    isNode = true;\n  }\n  else\n  {\n    if (typeof define === 'function' && define.amd) {\n      define(ClipperLib);\n    }\n    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n    else self['ClipperLib'] = ClipperLib;\n  }\n  var navigator_appName;\n  if (!isNode)\n  {\n    var nav = navigator.userAgent.toString().toLowerCase();\n    navigator_appName = navigator.appName;\n  }\n  else\n  {\n    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n  }\n  // Browser test to speedup performance critical functions\n  var browser = {};\n  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n  else browser.chrome = 0;\n  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n  else browser.chromium = 0;\n  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n  else browser.safari = 0;\n  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n  else browser.firefox = 0;\n  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n  else browser.firefox17 = 0;\n  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n  else browser.firefox15 = 0;\n  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n  else browser.firefox3 = 0;\n  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n  else browser.opera = 0;\n  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n  else browser.msie10 = 0;\n  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n  else browser.msie9 = 0;\n  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n  else browser.msie8 = 0;\n  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n  else browser.msie7 = 0;\n  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n  else browser.msie = 0;\n  ClipperLib.biginteger_used = null;\n\n  // Copyright (c) 2005  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Basic JavaScript BN library - subset useful for RSA encryption.\n  // Bits per digit\n  var dbits;\n  // JavaScript engine analysis\n  var canary = 0xdeadbeefcafe;\n  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n  // (public) Constructor\n  function BigInteger(a, b, c)\n  {\n    // This test variable can be removed,\n    // but at least for performance tests it is useful piece of knowledge\n    // This is the only ClipperLib related variable in BigInteger library\n    ClipperLib.biginteger_used = 1;\n    if (a != null)\n      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n    else this.fromString(a, b);\n  }\n  // return new, unset BigInteger\n  function nbi()\n  {\n    return new BigInteger(null,undefined,undefined);\n  }\n  // am: Compute w_j += (x*this_i), propagate carries,\n  // c is initial carry, returns final carry.\n  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n  // We need to select the fastest one that works in this environment.\n  // am1: use a single mult and divide to get the high bits,\n  // max digit bits should be 26 because\n  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n  function am1(i, x, w, j, c, n)\n  {\n    while (--n >= 0)\n    {\n      var v = x * this[i++] + w[j] + c;\n      c = Math.floor(v / 0x4000000);\n      w[j++] = v & 0x3ffffff;\n    }\n    return c;\n  }\n  // am2 avoids a big mult-and-extract completely.\n  // Max digit bits should be <= 30 because we do bitwise ops\n  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n  function am2(i, x, w, j, c, n)\n  {\n    var xl = x & 0x7fff,\n      xh = x >> 15;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x7fff;\n      var h = this[i++] >> 15;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n      w[j++] = l & 0x3fffffff;\n    }\n    return c;\n  }\n  // Alternately, set max digit bits to 28 since some\n  // browsers slow down when dealing with 32-bit numbers.\n  function am3(i, x, w, j, c, n)\n  {\n    var xl = x & 0x3fff,\n      xh = x >> 14;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x3fff;\n      var h = this[i++] >> 14;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n      c = (l >> 28) + (m >> 14) + xh * h;\n      w[j++] = l & 0xfffffff;\n    }\n    return c;\n  }\n  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n  {\n    BigInteger.prototype.am = am2;\n    dbits = 30;\n  }\n  else if (j_lm && (navigator_appName != \"Netscape\"))\n  {\n    BigInteger.prototype.am = am1;\n    dbits = 26;\n  }\n  else\n  { // Mozilla/Netscape seems to prefer am3\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n  }\n  BigInteger.prototype.DB = dbits;\n  BigInteger.prototype.DM = ((1 << dbits) - 1);\n  BigInteger.prototype.DV = (1 << dbits);\n  var BI_FP = 52;\n  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n  BigInteger.prototype.F1 = BI_FP - dbits;\n  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n  // Digit conversions\n  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n  var BI_RC = new Array();\n  var rr, vv;\n  rr = \"0\".charCodeAt(0);\n  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n  rr = \"a\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n  rr = \"A\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n  function int2char(n)\n  {\n    return BI_RM.charAt(n);\n  }\n\n  function intAt(s, i)\n  {\n    var c = BI_RC[s.charCodeAt(i)];\n    return (c == null) ? -1 : c;\n  }\n  // (protected) copy this to r\n  function bnpCopyTo(r)\n  {\n    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n    r.t = this.t;\n    r.s = this.s;\n  }\n  // (protected) set from integer value x, -DV <= x < DV\n  function bnpFromInt(x)\n  {\n    this.t = 1;\n    this.s = (x < 0) ? -1 : 0;\n    if (x > 0) this[0] = x;\n    else if (x < -1) this[0] = x + this.DV;\n    else this.t = 0;\n  }\n  // return bigint initialized to value\n  function nbv(i)\n  {\n    var r = nbi();\n    r.fromInt(i);\n    return r;\n  }\n  // (protected) set from string and radix\n  function bnpFromString(s, b)\n  {\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 256) k = 8; // byte array\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else\n    {\n      this.fromRadix(s, b);\n      return;\n    }\n    this.t = 0;\n    this.s = 0;\n    var i = s.length,\n      mi = false,\n      sh = 0;\n    while (--i >= 0)\n    {\n      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\") mi = true;\n        continue;\n      }\n      mi = false;\n      if (sh == 0)\n        this[this.t++] = x;\n      else if (sh + k > this.DB)\n      {\n        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n        this[this.t++] = (x >> (this.DB - sh));\n      }\n      else\n        this[this.t - 1] |= x << sh;\n      sh += k;\n      if (sh >= this.DB) sh -= this.DB;\n    }\n    if (k == 8 && (s[0] & 0x80) != 0)\n    {\n      this.s = -1;\n      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n    }\n    this.clamp();\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) clamp off excess high words\n  function bnpClamp()\n  {\n    var c = this.s & this.DM;\n    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n  }\n  // (public) return string representation in given radix\n  function bnToString(b)\n  {\n    if (this.s < 0) return \"-\" + this.negate().toString(b);\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else return this.toRadix(b);\n    var km = (1 << k) - 1,\n      d, m = false,\n      r = \"\",\n      i = this.t;\n    var p = this.DB - (i * this.DB) % k;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) > 0)\n      {\n        m = true;\n        r = int2char(d);\n      }\n      while (i >= 0)\n      {\n        if (p < k)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (k - p);\n          d |= this[--i] >> (p += this.DB - k);\n        }\n        else\n        {\n          d = (this[i] >> (p -= k)) & km;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if (d > 0) m = true;\n        if (m) r += int2char(d);\n      }\n    }\n    return m ? r : \"0\";\n  }\n  // (public) -this\n  function bnNegate()\n  {\n    var r = nbi();\n    BigInteger.ZERO.subTo(this, r);\n    return r;\n  }\n  // (public) |this|\n  function bnAbs()\n  {\n    return (this.s < 0) ? this.negate() : this;\n  }\n  // (public) return + if this > a, - if this < a, 0 if equal\n  function bnCompareTo(a)\n  {\n    var r = this.s - a.s;\n    if (r != 0) return r;\n    var i = this.t;\n    r = i - a.t;\n    if (r != 0) return (this.s < 0) ? -r : r;\n    while (--i >= 0)\n      if ((r = this[i] - a[i]) != 0) return r;\n    return 0;\n  }\n  // returns bit length of the integer x\n  function nbits(x)\n  {\n    var r = 1,\n      t;\n    if ((t = x >>> 16) != 0)\n    {\n      x = t;\n      r += 16;\n    }\n    if ((t = x >> 8) != 0)\n    {\n      x = t;\n      r += 8;\n    }\n    if ((t = x >> 4) != 0)\n    {\n      x = t;\n      r += 4;\n    }\n    if ((t = x >> 2) != 0)\n    {\n      x = t;\n      r += 2;\n    }\n    if ((t = x >> 1) != 0)\n    {\n      x = t;\n      r += 1;\n    }\n    return r;\n  }\n  // (public) return the number of bits in \"this\"\n  function bnBitLength()\n  {\n    if (this.t <= 0) return 0;\n    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n  }\n  // (protected) r = this << n*DB\n  function bnpDLShiftTo(n, r)\n  {\n    var i;\n    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n    for (i = n - 1; i >= 0; --i) r[i] = 0;\n    r.t = this.t + n;\n    r.s = this.s;\n  }\n  // (protected) r = this >> n*DB\n  function bnpDRShiftTo(n, r)\n  {\n    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n  }\n  // (protected) r = this << n\n  function bnpLShiftTo(n, r)\n  {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB),\n      c = (this.s << bs) & this.DM,\n      i;\n    for (i = this.t - 1; i >= 0; --i)\n    {\n      r[i + ds + 1] = (this[i] >> cbs) | c;\n      c = (this[i] & bm) << bs;\n    }\n    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n    r[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n  }\n  // (protected) r = this >> n\n  function bnpRShiftTo(n, r)\n  {\n    r.s = this.s;\n    var ds = Math.floor(n / this.DB);\n    if (ds >= this.t)\n    {\n      r.t = 0;\n      return;\n    }\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << bs) - 1;\n    r[0] = this[ds] >> bs;\n    for (var i = ds + 1; i < this.t; ++i)\n    {\n      r[i - ds - 1] |= (this[i] & bm) << cbs;\n      r[i - ds] = this[i] >> bs;\n    }\n    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n    r.t = this.t - ds;\n    r.clamp();\n  }\n  // (protected) r = this - a\n  function bnpSubTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] - a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c -= a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c -= a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c -= a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c < -1) r[i++] = this.DV + c;\n    else if (c > 0) r[i++] = c;\n    r.t = i;\n    r.clamp();\n  }\n  // (protected) r = this * a, r != this,a (HAC 14.12)\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyTo(a, r)\n  {\n    var x = this.abs(),\n      y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n  }\n  // (protected) r = this^2, r != this (HAC 14.16)\n  function bnpSquareTo(r)\n  {\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < x.t - 1; ++i)\n    {\n      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n      {\n        r[i + x.t] -= x.DV;\n        r[i + x.t + 1] = 1;\n      }\n    }\n    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n    r.s = 0;\n    r.clamp();\n  }\n  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n  // r != q, this != m.  q or r may be null.\n  function bnpDivRemTo(m, q, r)\n  {\n    var pm = m.abs();\n    if (pm.t <= 0) return;\n    var pt = this.abs();\n    if (pt.t < pm.t)\n    {\n      if (q != null) q.fromInt(0);\n      if (r != null) this.copyTo(r);\n      return;\n    }\n    if (r == null) r = nbi();\n    var y = nbi(),\n      ts = this.s,\n      ms = m.s;\n    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n    if (nsh > 0)\n    {\n      pm.lShiftTo(nsh, y);\n      pt.lShiftTo(nsh, r);\n    }\n    else\n    {\n      pm.copyTo(y);\n      pt.copyTo(r);\n    }\n    var ys = y.t;\n    var y0 = y[ys - 1];\n    if (y0 == 0) return;\n    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n    var d1 = this.FV / yt,\n      d2 = (1 << this.F1) / yt,\n      e = 1 << this.F2;\n    var i = r.t,\n      j = i - ys,\n      t = (q == null) ? nbi() : q;\n    y.dlShiftTo(j, t);\n    if (r.compareTo(t) >= 0)\n    {\n      r[r.t++] = 1;\n      r.subTo(t, r);\n    }\n    BigInteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n    while (y.t < ys) y[y.t++] = 0;\n    while (--j >= 0)\n    {\n      // Estimate quotient digit\n      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n      { // Try it out\n        y.dlShiftTo(j, t);\n        r.subTo(t, r);\n        while (r[i] < --qd) r.subTo(t, r);\n      }\n    }\n    if (q != null)\n    {\n      r.drShiftTo(ys, q);\n      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n    }\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n  }\n  // (public) this mod a\n  function bnMod(a)\n  {\n    var r = nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n    return r;\n  }\n  // Modular reduction using \"classic\" algorithm\n  function Classic(m)\n  {\n    this.m = m;\n  }\n\n  function cConvert(x)\n  {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n    else return x;\n  }\n\n  function cRevert(x)\n  {\n    return x;\n  }\n\n  function cReduce(x)\n  {\n    x.divRemTo(this.m, null, x);\n  }\n\n  function cMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n\n  function cSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  Classic.prototype.convert = cConvert;\n  Classic.prototype.revert = cRevert;\n  Classic.prototype.reduce = cReduce;\n  Classic.prototype.mulTo = cMulTo;\n  Classic.prototype.sqrTo = cSqrTo;\n  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n  // justification:\n  //         xy == 1 (mod m)\n  //         xy =  1+km\n  //   xy(2-xy) = (1+km)(1-km)\n  // x[y(2-xy)] = 1-k^2m^2\n  // x[y(2-xy)] == 1 (mod m^2)\n  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n  function bnpInvDigit()\n  {\n    if (this.t < 1) return 0;\n    var x = this[0];\n    if ((x & 1) == 0) return 0;\n    var y = x & 3; // y == 1/x mod 2^2\n    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n    // we really want the negative inverse, and -DV < y < DV\n    return (y > 0) ? this.DV - y : -y;\n  }\n  // Montgomery reduction\n  function Montgomery(m)\n  {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << (m.DB - 15)) - 1;\n    this.mt2 = 2 * m.t;\n  }\n  // xR mod m\n  function montConvert(x)\n  {\n    var r = nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n    return r;\n  }\n  // x/R mod m\n  function montRevert(x)\n  {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  }\n  // x = x/R mod m (HAC 14.32)\n  function montReduce(x)\n  {\n    while (x.t <= this.mt2) // pad x so am has enough room later\n      x[x.t++] = 0;\n    for (var i = 0; i < this.m.t; ++i)\n    {\n      // faster way of calculating u0 = x[i]*mp mod DV\n      var j = x[i] & 0x7fff;\n      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n      // use am to combine the multiply-shift-add into one call\n      j = i + this.m.t;\n      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n      // propagate carry\n      while (x[j] >= x.DV)\n      {\n        x[j] -= x.DV;\n        x[++j]++;\n      }\n    }\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = \"x^2/R mod m\"; x != r\n  function montSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = \"xy/R mod m\"; x,y != r\n  function montMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Montgomery.prototype.convert = montConvert;\n  Montgomery.prototype.revert = montRevert;\n  Montgomery.prototype.reduce = montReduce;\n  Montgomery.prototype.mulTo = montMulTo;\n  Montgomery.prototype.sqrTo = montSqrTo;\n  // (protected) true iff this is even\n  function bnpIsEven()\n  {\n    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n  }\n  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n  function bnpExp(e, z)\n  {\n    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n    var r = nbi(),\n      r2 = nbi(),\n      g = z.convert(this),\n      i = nbits(e) - 1;\n    g.copyTo(r);\n    while (--i >= 0)\n    {\n      z.sqrTo(r, r2);\n      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n      else\n      {\n        var t = r;\n        r = r2;\n        r2 = t;\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) this^e % m, 0 <= e < 2^32\n  function bnModPowInt(e, m)\n  {\n    var z;\n    if (e < 256 || m.isEven()) z = new Classic(m);\n    else z = new Montgomery(m);\n    return this.exp(e, z);\n  }\n  // protected\n  BigInteger.prototype.copyTo = bnpCopyTo;\n  BigInteger.prototype.fromInt = bnpFromInt;\n  BigInteger.prototype.fromString = bnpFromString;\n  BigInteger.prototype.clamp = bnpClamp;\n  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n  BigInteger.prototype.subTo = bnpSubTo;\n  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n  BigInteger.prototype.squareTo = bnpSquareTo;\n  BigInteger.prototype.divRemTo = bnpDivRemTo;\n  BigInteger.prototype.invDigit = bnpInvDigit;\n  BigInteger.prototype.isEven = bnpIsEven;\n  BigInteger.prototype.exp = bnpExp;\n  // public\n  BigInteger.prototype.toString = bnToString;\n  BigInteger.prototype.negate = bnNegate;\n  BigInteger.prototype.abs = bnAbs;\n  BigInteger.prototype.compareTo = bnCompareTo;\n  BigInteger.prototype.bitLength = bnBitLength;\n  BigInteger.prototype.mod = bnMod;\n  BigInteger.prototype.modPowInt = bnModPowInt;\n  // \"constants\"\n  BigInteger.ZERO = nbv(0);\n  BigInteger.ONE = nbv(1);\n  // Copyright (c) 2005-2009  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Extended JavaScript BN functions, required for RSA private ops.\n  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n  // Version 1.2: square() API, isProbablePrime fix\n  // (public)\n  function bnClone()\n  {\n    var r = nbi();\n    this.copyTo(r);\n    return r;\n  }\n  // (public) return value as integer\n  function bnIntValue()\n  {\n    if (this.s < 0)\n    {\n      if (this.t == 1) return this[0] - this.DV;\n      else if (this.t == 0) return -1;\n    }\n    else if (this.t == 1) return this[0];\n    else if (this.t == 0) return 0;\n    // assumes 16 < DB < 32\n    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n  }\n  // (public) return value as byte\n  function bnByteValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n  }\n  // (public) return value as short (assumes DB>=16)\n  function bnShortValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n  }\n  // (protected) return x s.t. r^x < DV\n  function bnpChunkSize(r)\n  {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n  }\n  // (public) 0 if this == 0, 1 if this > 0\n  function bnSigNum()\n  {\n    if (this.s < 0) return -1;\n    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n    else return 1;\n  }\n  // (protected) convert to radix string\n  function bnpToRadix(b)\n  {\n    if (b == null) b = 10;\n    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n    var cs = this.chunkSize(b);\n    var a = Math.pow(b, cs);\n    var d = nbv(a),\n      y = nbi(),\n      z = nbi(),\n      r = \"\";\n    this.divRemTo(d, y, z);\n    while (y.signum() > 0)\n    {\n      r = (a + z.intValue()).toString(b).substr(1) + r;\n      y.divRemTo(d, y, z);\n    }\n    return z.intValue().toString(b) + r;\n  }\n  // (protected) convert from radix string\n  function bnpFromRadix(s, b)\n  {\n    this.fromInt(0);\n    if (b == null) b = 10;\n    var cs = this.chunkSize(b);\n    var d = Math.pow(b, cs),\n      mi = false,\n      j = 0,\n      w = 0;\n    for (var i = 0; i < s.length; ++i)\n    {\n      var x = intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n        continue;\n      }\n      w = b * w + x;\n      if (++j >= cs)\n      {\n        this.dMultiply(d);\n        this.dAddOffset(w, 0);\n        j = 0;\n        w = 0;\n      }\n    }\n    if (j > 0)\n    {\n      this.dMultiply(Math.pow(b, j));\n      this.dAddOffset(w, 0);\n    }\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) alternate constructor\n  function bnpFromNumber(a, b, c)\n  {\n    if (\"number\" == typeof b)\n    {\n      // new BigInteger(int,int,RNG)\n      if (a < 2) this.fromInt(1);\n      else\n      {\n        this.fromNumber(a, c);\n        if (!this.testBit(a - 1)) // force MSB set\n          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n        while (!this.isProbablePrime(b))\n        {\n          this.dAddOffset(2, 0);\n          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n        }\n      }\n    }\n    else\n    {\n      // new BigInteger(int,RNG)\n      var x = new Array(),\n        t = a & 7;\n      x.length = (a >> 3) + 1;\n      b.nextBytes(x);\n      if (t > 0) x[0] &= ((1 << t) - 1);\n      else x[0] = 0;\n      this.fromString(x, 256);\n    }\n  }\n  // (public) convert to bigendian byte array\n  function bnToByteArray()\n  {\n    var i = this.t,\n      r = new Array();\n    r[0] = this.s;\n    var p = this.DB - (i * this.DB) % 8,\n      d, k = 0;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n        r[k++] = d | (this.s << (this.DB - p));\n      while (i >= 0)\n      {\n        if (p < 8)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n          d |= this[--i] >> (p += this.DB - 8);\n        }\n        else\n        {\n          d = (this[i] >> (p -= 8)) & 0xff;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if ((d & 0x80) != 0) d |= -256;\n        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n        if (k > 0 || d != this.s) r[k++] = d;\n      }\n    }\n    return r;\n  }\n\n  function bnEquals(a)\n  {\n    return (this.compareTo(a) == 0);\n  }\n\n  function bnMin(a)\n  {\n    return (this.compareTo(a) < 0) ? this : a;\n  }\n\n  function bnMax(a)\n  {\n    return (this.compareTo(a) > 0) ? this : a;\n  }\n  // (protected) r = this op a (bitwise)\n  function bnpBitwiseTo(a, op, r)\n  {\n    var i, f, m = Math.min(a.t, this.t);\n    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n    if (a.t < this.t)\n    {\n      f = a.s & this.DM;\n      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n      r.t = this.t;\n    }\n    else\n    {\n      f = this.s & this.DM;\n      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n      r.t = a.t;\n    }\n    r.s = op(this.s, a.s);\n    r.clamp();\n  }\n  // (public) this & a\n  function op_and(x, y)\n  {\n    return x & y;\n  }\n\n  function bnAnd(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_and, r);\n    return r;\n  }\n  // (public) this | a\n  function op_or(x, y)\n  {\n    return x | y;\n  }\n\n  function bnOr(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_or, r);\n    return r;\n  }\n  // (public) this ^ a\n  function op_xor(x, y)\n  {\n    return x ^ y;\n  }\n\n  function bnXor(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_xor, r);\n    return r;\n  }\n  // (public) this & ~a\n  function op_andnot(x, y)\n  {\n    return x & ~y;\n  }\n\n  function bnAndNot(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_andnot, r);\n    return r;\n  }\n  // (public) ~this\n  function bnNot()\n  {\n    var r = nbi();\n    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n  }\n  // (public) this << n\n  function bnShiftLeft(n)\n  {\n    var r = nbi();\n    if (n < 0) this.rShiftTo(-n, r);\n    else this.lShiftTo(n, r);\n    return r;\n  }\n  // (public) this >> n\n  function bnShiftRight(n)\n  {\n    var r = nbi();\n    if (n < 0) this.lShiftTo(-n, r);\n    else this.rShiftTo(n, r);\n    return r;\n  }\n  // return index of lowest 1-bit in x, x < 2^31\n  function lbit(x)\n  {\n    if (x == 0) return -1;\n    var r = 0;\n    if ((x & 0xffff) == 0)\n    {\n      x >>= 16;\n      r += 16;\n    }\n    if ((x & 0xff) == 0)\n    {\n      x >>= 8;\n      r += 8;\n    }\n    if ((x & 0xf) == 0)\n    {\n      x >>= 4;\n      r += 4;\n    }\n    if ((x & 3) == 0)\n    {\n      x >>= 2;\n      r += 2;\n    }\n    if ((x & 1) == 0)++r;\n    return r;\n  }\n  // (public) returns index of lowest 1-bit (or -1 if none)\n  function bnGetLowestSetBit()\n  {\n    for (var i = 0; i < this.t; ++i)\n      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n    if (this.s < 0) return this.t * this.DB;\n    return -1;\n  }\n  // return number of 1 bits in x\n  function cbit(x)\n  {\n    var r = 0;\n    while (x != 0)\n    {\n      x &= x - 1;\n      ++r;\n    }\n    return r;\n  }\n  // (public) return number of set bits\n  function bnBitCount()\n  {\n    var r = 0,\n      x = this.s & this.DM;\n    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n    return r;\n  }\n  // (public) true iff nth bit is set\n  function bnTestBit(n)\n  {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) return (this.s != 0);\n    return ((this[j] & (1 << (n % this.DB))) != 0);\n  }\n  // (protected) this op (1<<n)\n  function bnpChangeBit(n, op)\n  {\n    var r = BigInteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n  }\n  // (public) this | (1<<n)\n  function bnSetBit(n)\n  {\n    return this.changeBit(n, op_or);\n  }\n  // (public) this & ~(1<<n)\n  function bnClearBit(n)\n  {\n    return this.changeBit(n, op_andnot);\n  }\n  // (public) this ^ (1<<n)\n  function bnFlipBit(n)\n  {\n    return this.changeBit(n, op_xor);\n  }\n  // (protected) r = this + a\n  function bnpAddTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] + a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c += a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c += a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c > 0) r[i++] = c;\n    else if (c < -1) r[i++] = this.DV + c;\n    r.t = i;\n    r.clamp();\n  }\n  // (public) this + a\n  function bnAdd(a)\n  {\n    var r = nbi();\n    this.addTo(a, r);\n    return r;\n  }\n  // (public) this - a\n  function bnSubtract(a)\n  {\n    var r = nbi();\n    this.subTo(a, r);\n    return r;\n  }\n  // (public) this * a\n  function bnMultiply(a)\n  {\n    var r = nbi();\n    this.multiplyTo(a, r);\n    return r;\n  }\n  // (public) this^2\n  function bnSquare()\n  {\n    var r = nbi();\n    this.squareTo(r);\n    return r;\n  }\n  // (public) this / a\n  function bnDivide(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, r, null);\n    return r;\n  }\n  // (public) this % a\n  function bnRemainder(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, null, r);\n    return r;\n  }\n  // (public) [this/a,this%a]\n  function bnDivideAndRemainder(a)\n  {\n    var q = nbi(),\n      r = nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n  }\n  // (protected) this *= n, this >= 0, 1 < n < DV\n  function bnpDMultiply(n)\n  {\n    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n  }\n  // (protected) this += n << w words, this >= 0\n  function bnpDAddOffset(n, w)\n  {\n    if (n == 0) return;\n    while (this.t <= w) this[this.t++] = 0;\n    this[w] += n;\n    while (this[w] >= this.DV)\n    {\n      this[w] -= this.DV;\n      if (++w >= this.t) this[this.t++] = 0;\n      ++this[w];\n    }\n  }\n  // A \"null\" reducer\n  function NullExp()\n  {}\n\n  function nNop(x)\n  {\n    return x;\n  }\n\n  function nMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n  }\n\n  function nSqrTo(x, r)\n  {\n    x.squareTo(r);\n  }\n  NullExp.prototype.convert = nNop;\n  NullExp.prototype.revert = nNop;\n  NullExp.prototype.mulTo = nMulTo;\n  NullExp.prototype.sqrTo = nSqrTo;\n  // (public) this^e\n  function bnPow(e)\n  {\n    return this.exp(e, new NullExp());\n  }\n  // (protected) r = lower n words of \"this * a\", a.t <= n\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyLowerTo(a, n, r)\n  {\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n    r.t = i;\n    while (i > 0) r[--i] = 0;\n    var j;\n    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n    r.clamp();\n  }\n  // (protected) r = \"this * a\" without lower n words, n > 0\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyUpperTo(a, n, r)\n  {\n    --n;\n    var i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n    while (--i >= 0) r[i] = 0;\n    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n    r.clamp();\n    r.drShiftTo(1, r);\n  }\n  // Barrett modular reduction\n  function Barrett(m)\n  {\n    // setup Barrett\n    this.r2 = nbi();\n    this.q3 = nbi();\n    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n  }\n\n  function barrettConvert(x)\n  {\n    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n    else if (x.compareTo(this.m) < 0) return x;\n    else\n    {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n  }\n\n  function barrettRevert(x)\n  {\n    return x;\n  }\n  // x = x mod m (HAC 14.42)\n  function barrettReduce(x)\n  {\n    x.drShiftTo(this.m.t - 1, this.r2);\n    if (x.t > this.m.t + 1)\n    {\n      x.t = this.m.t + 1;\n      x.clamp();\n    }\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n    x.subTo(this.r2, x);\n    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = x^2 mod m; x != r\n  function barrettSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = x*y mod m; x,y != r\n  function barrettMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Barrett.prototype.convert = barrettConvert;\n  Barrett.prototype.revert = barrettRevert;\n  Barrett.prototype.reduce = barrettReduce;\n  Barrett.prototype.mulTo = barrettMulTo;\n  Barrett.prototype.sqrTo = barrettSqrTo;\n  // (public) this^e % m (HAC 14.85)\n  function bnModPow(e, m)\n  {\n    var i = e.bitLength(),\n      k, r = nbv(1),\n      z;\n    if (i <= 0) return r;\n    else if (i < 18) k = 1;\n    else if (i < 48) k = 3;\n    else if (i < 144) k = 4;\n    else if (i < 768) k = 5;\n    else k = 6;\n    if (i < 8)\n      z = new Classic(m);\n    else if (m.isEven())\n      z = new Barrett(m);\n    else\n      z = new Montgomery(m);\n    // precomputation\n    var g = new Array(),\n      n = 3,\n      k1 = k - 1,\n      km = (1 << k) - 1;\n    g[1] = z.convert(this);\n    if (k > 1)\n    {\n      var g2 = nbi();\n      z.sqrTo(g[1], g2);\n      while (n <= km)\n      {\n        g[n] = nbi();\n        z.mulTo(g2, g[n - 2], g[n]);\n        n += 2;\n      }\n    }\n    var j = e.t - 1,\n      w, is1 = true,\n      r2 = nbi(),\n      t;\n    i = nbits(e[j]) - 1;\n    while (j >= 0)\n    {\n      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n      else\n      {\n        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n      }\n      n = k;\n      while ((w & 1) == 0)\n      {\n        w >>= 1;\n        --n;\n      }\n      if ((i -= n) < 0)\n      {\n        i += this.DB;\n        --j;\n      }\n      if (is1)\n      { // ret == 1, don't bother squaring or multiplying it\n        g[w].copyTo(r);\n        is1 = false;\n      }\n      else\n      {\n        while (n > 1)\n        {\n          z.sqrTo(r, r2);\n          z.sqrTo(r2, r);\n          n -= 2;\n        }\n        if (n > 0) z.sqrTo(r, r2);\n        else\n        {\n          t = r;\n          r = r2;\n          r2 = t;\n        }\n        z.mulTo(r2, g[w], r);\n      }\n      while (j >= 0 && (e[j] & (1 << i)) == 0)\n      {\n        z.sqrTo(r, r2);\n        t = r;\n        r = r2;\n        r2 = t;\n        if (--i < 0)\n        {\n          i = this.DB - 1;\n          --j;\n        }\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) gcd(this,a) (HAC 14.54)\n  function bnGCD(a)\n  {\n    var x = (this.s < 0) ? this.negate() : this.clone();\n    var y = (a.s < 0) ? a.negate() : a.clone();\n    if (x.compareTo(y) < 0)\n    {\n      var t = x;\n      x = y;\n      y = t;\n    }\n    var i = x.getLowestSetBit(),\n      g = y.getLowestSetBit();\n    if (g < 0) return x;\n    if (i < g) g = i;\n    if (g > 0)\n    {\n      x.rShiftTo(g, x);\n      y.rShiftTo(g, y);\n    }\n    while (x.signum() > 0)\n    {\n      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n      if (x.compareTo(y) >= 0)\n      {\n        x.subTo(y, x);\n        x.rShiftTo(1, x);\n      }\n      else\n      {\n        y.subTo(x, y);\n        y.rShiftTo(1, y);\n      }\n    }\n    if (g > 0) y.lShiftTo(g, y);\n    return y;\n  }\n  // (protected) this % n, n < 2^26\n  function bnpModInt(n)\n  {\n    if (n <= 0) return 0;\n    var d = this.DV % n,\n      r = (this.s < 0) ? n - 1 : 0;\n    if (this.t > 0)\n      if (d == 0) r = this[0] % n;\n      else\n        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n    return r;\n  }\n  // (public) 1/this % m (HAC 14.61)\n  function bnModInverse(m)\n  {\n    var ac = m.isEven();\n    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n    var u = m.clone(),\n      v = this.clone();\n    var a = nbv(1),\n      b = nbv(0),\n      c = nbv(0),\n      d = nbv(1);\n    while (u.signum() != 0)\n    {\n      while (u.isEven())\n      {\n        u.rShiftTo(1, u);\n        if (ac)\n        {\n          if (!a.isEven() || !b.isEven())\n          {\n            a.addTo(this, a);\n            b.subTo(m, b);\n          }\n          a.rShiftTo(1, a);\n        }\n        else if (!b.isEven()) b.subTo(m, b);\n        b.rShiftTo(1, b);\n      }\n      while (v.isEven())\n      {\n        v.rShiftTo(1, v);\n        if (ac)\n        {\n          if (!c.isEven() || !d.isEven())\n          {\n            c.addTo(this, c);\n            d.subTo(m, d);\n          }\n          c.rShiftTo(1, c);\n        }\n        else if (!d.isEven()) d.subTo(m, d);\n        d.rShiftTo(1, d);\n      }\n      if (u.compareTo(v) >= 0)\n      {\n        u.subTo(v, u);\n        if (ac) a.subTo(c, a);\n        b.subTo(d, b);\n      }\n      else\n      {\n        v.subTo(u, v);\n        if (ac) c.subTo(a, c);\n        d.subTo(b, d);\n      }\n    }\n    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n    if (d.compareTo(m) >= 0) return d.subtract(m);\n    if (d.signum() < 0) d.addTo(m, d);\n    else return d;\n    if (d.signum() < 0) return d.add(m);\n    else return d;\n  }\n  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n  // (public) test primality with certainty >= 1-.5^t\n  function bnIsProbablePrime(t)\n  {\n    var i, x = this.abs();\n    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n    {\n      for (i = 0; i < lowprimes.length; ++i)\n        if (x[0] == lowprimes[i]) return true;\n      return false;\n    }\n    if (x.isEven()) return false;\n    i = 1;\n    while (i < lowprimes.length)\n    {\n      var m = lowprimes[i],\n        j = i + 1;\n      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n      m = x.modInt(m);\n      while (i < j)\n        if (m % lowprimes[i++] == 0) return false;\n    }\n    return x.millerRabin(t);\n  }\n  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n  function bnpMillerRabin(t)\n  {\n    var n1 = this.subtract(BigInteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) return false;\n    var r = n1.shiftRight(k);\n    t = (t + 1) >> 1;\n    if (t > lowprimes.length) t = lowprimes.length;\n    var a = nbi();\n    for (var i = 0; i < t; ++i)\n    {\n      //Pick bases at random, instead of starting at 2\n      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n      var y = a.modPow(r, this);\n      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n      {\n        var j = 1;\n        while (j++ < k && y.compareTo(n1) != 0)\n        {\n          y = y.modPowInt(2, this);\n          if (y.compareTo(BigInteger.ONE) == 0) return false;\n        }\n        if (y.compareTo(n1) != 0) return false;\n      }\n    }\n    return true;\n  }\n  // protected\n  BigInteger.prototype.chunkSize = bnpChunkSize;\n  BigInteger.prototype.toRadix = bnpToRadix;\n  BigInteger.prototype.fromRadix = bnpFromRadix;\n  BigInteger.prototype.fromNumber = bnpFromNumber;\n  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n  BigInteger.prototype.changeBit = bnpChangeBit;\n  BigInteger.prototype.addTo = bnpAddTo;\n  BigInteger.prototype.dMultiply = bnpDMultiply;\n  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n  BigInteger.prototype.modInt = bnpModInt;\n  BigInteger.prototype.millerRabin = bnpMillerRabin;\n  // public\n  BigInteger.prototype.clone = bnClone;\n  BigInteger.prototype.intValue = bnIntValue;\n  BigInteger.prototype.byteValue = bnByteValue;\n  BigInteger.prototype.shortValue = bnShortValue;\n  BigInteger.prototype.signum = bnSigNum;\n  BigInteger.prototype.toByteArray = bnToByteArray;\n  BigInteger.prototype.equals = bnEquals;\n  BigInteger.prototype.min = bnMin;\n  BigInteger.prototype.max = bnMax;\n  BigInteger.prototype.and = bnAnd;\n  BigInteger.prototype.or = bnOr;\n  BigInteger.prototype.xor = bnXor;\n  BigInteger.prototype.andNot = bnAndNot;\n  BigInteger.prototype.not = bnNot;\n  BigInteger.prototype.shiftLeft = bnShiftLeft;\n  BigInteger.prototype.shiftRight = bnShiftRight;\n  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n  BigInteger.prototype.bitCount = bnBitCount;\n  BigInteger.prototype.testBit = bnTestBit;\n  BigInteger.prototype.setBit = bnSetBit;\n  BigInteger.prototype.clearBit = bnClearBit;\n  BigInteger.prototype.flipBit = bnFlipBit;\n  BigInteger.prototype.add = bnAdd;\n  BigInteger.prototype.subtract = bnSubtract;\n  BigInteger.prototype.multiply = bnMultiply;\n  BigInteger.prototype.divide = bnDivide;\n  BigInteger.prototype.remainder = bnRemainder;\n  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n  BigInteger.prototype.modPow = bnModPow;\n  BigInteger.prototype.modInverse = bnModInverse;\n  BigInteger.prototype.pow = bnPow;\n  BigInteger.prototype.gcd = bnGCD;\n  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n  // JSBN-specific extension\n  BigInteger.prototype.square = bnSquare;\n  var Int128 = BigInteger;\n  // BigInteger interfaces not implemented in jsbn:\n  // BigInteger(int signum, byte[] magnitude)\n  // double doubleValue()\n  // float floatValue()\n  // int hashCode()\n  // long longValue()\n  // static BigInteger valueOf(long val)\n  // Helper functions to make BigInteger functions callable with two parameters\n  // as in original C# Clipper\n  Int128.prototype.IsNegative = function ()\n  {\n    if (this.compareTo(Int128.ZERO) == -1) return true;\n    else return false;\n  };\n  Int128.op_Equality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) == 0) return true;\n    else return false;\n  };\n  Int128.op_Inequality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) != 0) return true;\n    else return false;\n  };\n  Int128.op_GreaterThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) > 0) return true;\n    else return false;\n  };\n  Int128.op_LessThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) < 0) return true;\n    else return false;\n  };\n  Int128.op_Addition = function (lhs, rhs)\n  {\n    return new Int128(lhs).add(new Int128(rhs));\n  };\n  Int128.op_Subtraction = function (lhs, rhs)\n  {\n    return new Int128(lhs).subtract(new Int128(rhs));\n  };\n  Int128.Int128Mul = function (lhs, rhs)\n  {\n    return new Int128(lhs).multiply(new Int128(rhs));\n  };\n  Int128.op_Division = function (lhs, rhs)\n  {\n    return lhs.divide(rhs);\n  };\n  Int128.prototype.ToDouble = function ()\n  {\n    return parseFloat(this.toString()); // This could be something faster\n  };\n  // end of Int128 section\n  /*\n  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n  else self.Int128 = Int128;\n  */\n\n\n  // ---------------------------------------------\n  // Here starts the actual Clipper library:\n  // Helper function to support Inheritance in Javascript\n\tvar Inherit = function (ce, ce2)\n\t{\n\t\tvar p;\n\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t{\n\t\t\tfor (p in ce2.prototype)\n\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t};\n  ClipperLib.Path = function ()\n  {\n    return [];\n  };\n  ClipperLib.Paths = function ()\n  {\n    return []; // Was previously [[]], but caused problems when pushed\n  };\n  // Preserves the calling way of original C# Clipper\n  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n  ClipperLib.DoublePoint = function ()\n  {\n    var a = arguments;\n    this.X = 0;\n    this.Y = 0;\n    // public DoublePoint(DoublePoint dp)\n    // public DoublePoint(IntPoint ip)\n    if (a.length == 1)\n    {\n      this.X = a[0].X;\n      this.Y = a[0].Y;\n    }\n    else if (a.length == 2)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n    }\n  }; // This is internal faster function when called without arguments\n  ClipperLib.DoublePoint0 = function ()\n  {\n    this.X = 0;\n    this.Y = 0;\n  };\n  // This is internal faster function when called with 1 argument (dp or ip)\n  ClipperLib.DoublePoint1 = function (dp)\n  {\n    this.X = dp.X;\n    this.Y = dp.Y;\n  };\n  // This is internal faster function when called with 2 arguments (x and y)\n  ClipperLib.DoublePoint2 = function (x, y)\n  {\n    this.X = x;\n    this.Y = y;\n  };\n  // PolyTree & PolyNode start\n  // -------------------------------\n  ClipperLib.PolyNode = function ()\n  {\n    this.m_Parent = null;\n    this.m_polygon = new ClipperLib.Path();\n    this.m_Index = 0;\n    this.m_jointype = 0;\n    this.m_endtype = 0;\n    this.m_Childs = [];\n    this.IsOpen = false;\n  };\n  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n  {\n    var result = true;\n    var node = this.m_Parent;\n    while (node !== null)\n    {\n      result = !result;\n      node = node.m_Parent;\n    }\n    return result;\n  };\n  ClipperLib.PolyNode.prototype.ChildCount = function ()\n  {\n    return this.m_Childs.length;\n  };\n  ClipperLib.PolyNode.prototype.Contour = function ()\n  {\n    return this.m_polygon;\n  };\n  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n  {\n    var cnt = this.m_Childs.length;\n    this.m_Childs.push(Child);\n    Child.m_Parent = this;\n    Child.m_Index = cnt;\n  };\n  ClipperLib.PolyNode.prototype.GetNext = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return this.GetNextSiblingUp();\n  };\n  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n  {\n    if (this.m_Parent === null)\n      return null;\n    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n      return this.m_Parent.GetNextSiblingUp();\n    else\n      return this.m_Parent.m_Childs[this.m_Index + 1];\n  };\n  ClipperLib.PolyNode.prototype.Childs = function ()\n  {\n    return this.m_Childs;\n  };\n  ClipperLib.PolyNode.prototype.Parent = function ()\n  {\n    return this.m_Parent;\n  };\n  ClipperLib.PolyNode.prototype.IsHole = function ()\n  {\n    return this.IsHoleNode();\n  };\n  // PolyTree : PolyNode\n  ClipperLib.PolyTree = function ()\n  {\n    this.m_AllPolys = [];\n    ClipperLib.PolyNode.call(this);\n  };\n  ClipperLib.PolyTree.prototype.Clear = function ()\n  {\n    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n      this.m_AllPolys[i] = null;\n    this.m_AllPolys.length = 0;\n    this.m_Childs.length = 0;\n  };\n  ClipperLib.PolyTree.prototype.GetFirst = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return null;\n  };\n  ClipperLib.PolyTree.prototype.Total = function ()\n  {\n\t\tvar result = this.m_AllPolys.length;\n\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\treturn result;\n  };\n  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n  // -------------------------------\n  // PolyTree & PolyNode end\n  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n  {\n    return Math.abs(a);\n  };\n  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n  {\n    return Math.max(a, b);\n  };\n  /*\n  -----------------------------------\n  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n  -----------------------------------\n  */\n  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n  {\n    return a | 0;\n  };\n  else ClipperLib.Cast_Int32 = function (a)\n  { // eg. browser.chrome || browser.chromium || browser.firefox\n    return~~ a;\n  };\n  /*\n  --------------------------\n  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n  Chrome: bitwise_not_floor\n  Firefox17: toInteger (typeof test)\n  IE9: bitwise_or_floor\n  IE7 and IE8: to_parseint\n  Chromium: to_floor_or_ceil\n  Firefox3: to_floor_or_ceil\n  Firefox15: to_floor_or_ceil\n  Opera: to_floor_or_ceil\n  Safari: to_floor_or_ceil\n  --------------------------\n  */\n  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    else return~~ a;\n  };\n  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n  {\n    return Number.toInteger(a);\n  };\n  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n  {\n    return parseInt(a, 10);\n  };\n  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    return a | 0;\n  };\n  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n  else ClipperLib.Cast_Int64 = function (a)\n  {\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  };\n  ClipperLib.Clear = function (a)\n  {\n    a.length = 0;\n  };\n  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n  ClipperLib.PI = 3.141592653589793;\n  ClipperLib.PI2 = 2 * 3.141592653589793;\n  ClipperLib.IntPoint = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    this.X = 0;\n    this.Y = 0;\n    if (use_xyz)\n    {\n      this.Z = 0;\n      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = a[2];\n      }\n      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = 0;\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n          this.Z = 0;\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n          this.X = pt.X;\n          this.Y = pt.Y;\n          this.Z = pt.Z;\n        }\n      }\n      else // public IntPoint()\n      {\n        this.X = 0;\n        this.Y = 0;\n        this.Z = 0;\n      }\n    }\n    else // if (!use_xyz)\n    {\n      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          this.X = pt.X;\n          this.Y = pt.Y;\n        }\n      }\n      else // public IntPoint(IntPoint pt)\n      {\n        this.X = 0;\n        this.Y = 0;\n      }\n    }\n  };\n  ClipperLib.IntPoint.op_Equality = function (a, b)\n  {\n    //return a == b;\n    return a.X == b.X && a.Y == b.Y;\n  };\n  ClipperLib.IntPoint.op_Inequality = function (a, b)\n  {\n    //return a != b;\n    return a.X != b.X || a.Y != b.Y;\n  };\n  /*\n  ClipperLib.IntPoint.prototype.Equals = function (obj)\n  {\n    if (obj === null)\n        return false;\n    if (obj instanceof ClipperLib.IntPoint)\n    {\n        var a = Cast(obj, ClipperLib.IntPoint);\n        return (this.X == a.X) && (this.Y == a.Y);\n    }\n    else\n        return false;\n  };\n*/\n  if (use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n      this.Z = pt.Z;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint3 = function (x, y, z)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = z;\n    };\n  }\n  else // if (!use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n    };\n  }\n  ClipperLib.IntRect = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    if (alen == 4) // function (l, t, r, b)\n    {\n      this.left = a[0];\n      this.top = a[1];\n      this.right = a[2];\n      this.bottom = a[3];\n    }\n    else if (alen == 1) // function (ir)\n    {\n      this.left = ir.left;\n      this.top = ir.top;\n      this.right = ir.right;\n      this.bottom = ir.bottom;\n    }\n    else // function ()\n    {\n      this.left = 0;\n      this.top = 0;\n      this.right = 0;\n      this.bottom = 0;\n    }\n  };\n  ClipperLib.IntRect0 = function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  };\n  ClipperLib.IntRect1 = function (ir)\n  {\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  };\n  ClipperLib.IntRect4 = function (l, t, r, b)\n  {\n    this.left = l;\n    this.top = t;\n    this.right = r;\n    this.bottom = b;\n  };\n  ClipperLib.ClipType = {\n    ctIntersection: 0,\n    ctUnion: 1,\n    ctDifference: 2,\n    ctXor: 3\n  };\n  ClipperLib.PolyType = {\n    ptSubject: 0,\n    ptClip: 1\n  };\n  ClipperLib.PolyFillType = {\n    pftEvenOdd: 0,\n    pftNonZero: 1,\n    pftPositive: 2,\n    pftNegative: 3\n  };\n  ClipperLib.JoinType = {\n    jtSquare: 0,\n    jtRound: 1,\n    jtMiter: 2\n  };\n  ClipperLib.EndType = {\n    etOpenSquare: 0,\n    etOpenRound: 1,\n    etOpenButt: 2,\n    etClosedLine: 3,\n    etClosedPolygon: 4\n  };\n  ClipperLib.EdgeSide = {\n    esLeft: 0,\n    esRight: 1\n  };\n  ClipperLib.Direction = {\n    dRightToLeft: 0,\n    dLeftToRight: 1\n  };\n  ClipperLib.TEdge = function ()\n  {\n    this.Bot = new ClipperLib.IntPoint();\n    this.Curr = new ClipperLib.IntPoint();\n    this.Top = new ClipperLib.IntPoint();\n    this.Delta = new ClipperLib.IntPoint();\n    this.Dx = 0;\n    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n    this.Side = ClipperLib.EdgeSide.esLeft;\n    this.WindDelta = 0;\n    this.WindCnt = 0;\n    this.WindCnt2 = 0;\n    this.OutIdx = 0;\n    this.Next = null;\n    this.Prev = null;\n    this.NextInLML = null;\n    this.NextInAEL = null;\n    this.PrevInAEL = null;\n    this.NextInSEL = null;\n    this.PrevInSEL = null;\n  };\n  ClipperLib.IntersectNode = function ()\n  {\n    this.Edge1 = null;\n    this.Edge2 = null;\n    this.Pt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.MyIntersectNodeSort = function () {};\n  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n  {\n    var i = node2.Pt.Y - node1.Pt.Y;\n    if (i > 0) return 1;\n    else if (i < 0) return -1;\n    else return 0;\n  };\n\n  ClipperLib.LocalMinima = function ()\n  {\n    this.Y = 0;\n    this.LeftBound = null;\n    this.RightBound = null;\n    this.Next = null;\n  };\n  ClipperLib.Scanbeam = function ()\n  {\n    this.Y = 0;\n    this.Next = null;\n  };\n  ClipperLib.OutRec = function ()\n  {\n    this.Idx = 0;\n    this.IsHole = false;\n    this.IsOpen = false;\n    this.FirstLeft = null;\n    this.Pts = null;\n    this.BottomPt = null;\n    this.PolyNode = null;\n  };\n  ClipperLib.OutPt = function ()\n  {\n    this.Idx = 0;\n    this.Pt = new ClipperLib.IntPoint();\n    this.Next = null;\n    this.Prev = null;\n  };\n  ClipperLib.Join = function ()\n  {\n    this.OutPt1 = null;\n    this.OutPt2 = null;\n    this.OffPt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.ClipperBase = function ()\n  {\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_edges = new Array();\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n    this.PreserveCollinear = false;\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n  // protected const double horizontal = -3.4E+38;\n  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n  // So had to adjust them to more suitable for Javascript.\n  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n  ClipperLib.ClipperBase.Skip = -2;\n  ClipperLib.ClipperBase.Unassigned = -1;\n  ClipperLib.ClipperBase.tolerance = 1E-20;\n  if (use_int32)\n  {\n    ClipperLib.ClipperBase.loRange = 0x7FFF;\n    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n  }\n  else\n  {\n    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n  }\n\n  ClipperLib.ClipperBase.near_zero = function (val)\n  {\n    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n  };\n  ClipperLib.ClipperBase.IsHorizontal = function (e)\n  {\n    return e.Delta.Y === 0;\n  };\n  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n  {\n    var pp2 = pp;\n    do {\n      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n        return true;\n      pp2 = pp2.Next;\n    }\n    while (pp2 != pp)\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n  {\n    if (UseFullRange)\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n    else\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n  };\n  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n  {\n    var pp2 = pp;\n    while (true)\n    {\n      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n        return true;\n      pp2 = pp2.Next;\n      if (pp2 == pp)\n        break;\n    }\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n    if (alen == 3) // function (e1, e2, UseFullRange)\n    {\n      e1 = a[0];\n      e2 = a[1];\n      UseFullRange = a[2];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n      else\n        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n    }\n    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      UseFullRange = a[3];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n    }\n    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      pt4 = a[3];\n      UseFullRange = a[4];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n    }\n  };\n  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n    else\n      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n  };\n  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.prototype.Clear = function ()\n  {\n    this.DisposeLocalMinimaList();\n    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n    {\n      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n        this.m_edges[i][j] = null;\n      ClipperLib.Clear(this.m_edges[i]);\n    }\n    ClipperLib.Clear(this.m_edges);\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n  {\n    while (this.m_MinimaList !== null)\n    {\n      var tmpLm = this.m_MinimaList.Next;\n      this.m_MinimaList = null;\n      this.m_MinimaList = tmpLm;\n    }\n    this.m_CurrentLM = null;\n  };\n  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n  {\n    if (useFullRange.Value)\n    {\n      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n    }\n    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n    {\n      useFullRange.Value = true;\n      this.RangeTest(Pt, useFullRange);\n    }\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n  {\n    e.Next = eNext;\n    e.Prev = ePrev;\n    //e.Curr = pt;\n    e.Curr.X = pt.X;\n    e.Curr.Y = pt.Y;\n    e.OutIdx = -1;\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n  {\n    if (e.Curr.Y >= e.Next.Curr.Y)\n    {\n      //e.Bot = e.Curr;\n      e.Bot.X = e.Curr.X;\n      e.Bot.Y = e.Curr.Y;\n      //e.Top = e.Next.Curr;\n      e.Top.X = e.Next.Curr.X;\n      e.Top.Y = e.Next.Curr.Y;\n    }\n    else\n    {\n      //e.Top = e.Curr;\n      e.Top.X = e.Curr.X;\n      e.Top.Y = e.Curr.Y;\n      //e.Bot = e.Next.Curr;\n      e.Bot.X = e.Next.Curr.X;\n      e.Bot.Y = e.Next.Curr.Y;\n    }\n    this.SetDx(e);\n    e.PolyTyp = polyType;\n  };\n  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n  {\n    var E2;\n    for (;;)\n    {\n      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n        E = E.Next;\n      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n        break;\n      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Prev;\n      E2 = E;\n      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Next;\n      if (E.Top.Y == E.Prev.Bot.Y)\n        continue;\n      //ie just an intermediate horz.\n      if (E2.Prev.Bot.X < E.Bot.X)\n        E = E2;\n      break;\n    }\n    return E;\n  };\n  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n  {\n    var EStart;\n    var Result = E;\n    var Horz;\n\n      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n      {\n        //check if there are edges beyond the skip edge in the bound and if so\n        //create another LocMin and calling ProcessBound once more ...\n        E = Result;\n        if (LeftBoundIsForward)\n        {\n          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n        }\n        else\n        {\n          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n        }\n        if (E == Result)\n        {\n          if (LeftBoundIsForward) Result = E.Next;\n          else Result = E.Prev;\n        }\n        else\n        {\n          //there are more edges in the bound beyond result starting with E\n          if (LeftBoundIsForward)\n            E = Result.Next;\n          else\n            E = Result.Prev;\n          var locMin = new ClipperLib.LocalMinima();\n          locMin.Next = null;\n          locMin.Y = E.Bot.Y;\n          locMin.LeftBound = null;\n          locMin.RightBound = E;\n          E.WindDelta = 0;\n          Result = this.ProcessBound(E, LeftBoundIsForward);\n          this.InsertLocalMinima(locMin);\n        }\n        return Result;\n      }\n\n      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n      {\n        //We need to be careful with open paths because this may not be a\n        //true local minima (ie E may be following a skip edge).\n        //Also, consecutive horz. edges may start heading left before going right.\n        if (LeftBoundIsForward) EStart = E.Prev;\n        else EStart = E.Next;\n        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n          {\n            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n              this.ReverseHorizontal(E);\n          }\n          else if (EStart.Bot.X != E.Bot.X)\n            this.ReverseHorizontal(E);\n        }\n      }\n\n      EStart = E;\n      if (LeftBoundIsForward)\n      {\n        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Next;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          //nb: at the top of a bound, horizontals are added to the bound\n          //only when the preceding edge attaches to the horizontal's left vertex\n          //unless a Skip edge is encountered when that becomes the top divide\n          Horz = Result;\n          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Prev;\n          if (Horz.Prev.Top.X == Result.Next.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Prev;\n          }\n          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n            Result = Horz.Prev;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Next;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Next;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Next;\n        //move to the edge just beyond current bound\n      }\n      else\n      {\n        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Prev;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          Horz = Result;\n          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Next;\n          if (Horz.Next.Top.X == Result.Prev.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Next;\n          }\n          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n            Result = Horz.Next;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Prev;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Prev;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Prev;\n        //move to the edge just beyond current bound\n      }\n\n    return Result;\n  };\n\n  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n  {\n    if (use_lines)\n    {\n      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n    }\n    else\n    {\n      if (!Closed)\n        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n    }\n    var highI = pg.length - 1;\n    if (Closed)\n      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n    --highI;\n    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n    --highI;\n    if ((Closed && highI < 2) || (!Closed && highI < 1))\n      return false;\n    //create a new edge array ...\n    var edges = new Array();\n    for (var i = 0; i <= highI; i++)\n      edges.push(new ClipperLib.TEdge());\n    var IsFlat = true;\n    //1. Basic (first) edge initialization ...\n\n    //edges[1].Curr = pg[1];\n    edges[1].Curr.X = pg[1].X;\n    edges[1].Curr.Y = pg[1].Y;\n\n    var $1 = {Value: this.m_UseFullRange};\n    this.RangeTest(pg[0], $1);\n    this.m_UseFullRange = $1.Value;\n\n    $1.Value = this.m_UseFullRange;\n    this.RangeTest(pg[highI], $1);\n    this.m_UseFullRange = $1.Value;\n\n    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n    for (var i = highI - 1; i >= 1; --i)\n    {\n      $1.Value = this.m_UseFullRange;\n      this.RangeTest(pg[i], $1);\n      this.m_UseFullRange = $1.Value;\n\n      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n    }\n\n    var eStart = edges[0];\n    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n    var E = eStart,\n      eLoopStop = eStart;\n    for (;;)\n    {\n    //console.log(E.Next, eStart);\n    \t//nb: allows matching start and end points when not Closed ...\n      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n      {\n        if (E == E.Next)\n          break;\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        eLoopStop = E;\n        continue;\n      }\n      if (E.Prev == E.Next)\n        break;\n      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n      {\n        //Collinear edges are allowed for open paths but in closed paths\n        //the default is to merge adjacent collinear edges into a single edge.\n        //However, if the PreserveCollinear property is enabled, only overlapping\n        //collinear edges (ie spikes) will be removed from closed paths.\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        E = E.Prev;\n        eLoopStop = E;\n        continue;\n      }\n      E = E.Next;\n      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n    }\n    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n      return false;\n    if (!Closed)\n    {\n      this.m_HasOpenPaths = true;\n      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n    }\n    //3. Do second stage of edge initialization ...\n    E = eStart;\n    do {\n      this.InitEdge2(E, polyType);\n      E = E.Next;\n      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n        IsFlat = false;\n    }\n    while (E != eStart)\n    //4. Finally, add edge bounds to LocalMinima list ...\n    //Totally flat paths must be handled differently when adding them\n    //to LocalMinima list to avoid endless loops etc ...\n    if (IsFlat)\n    {\n      if (Closed)\n        return false;\n      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n      if (E.Prev.Bot.X < E.Prev.Top.X)\n        this.ReverseHorizontal(E.Prev);\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      locMin.RightBound.WindDelta = 0;\n      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n      {\n        E.NextInLML = E.Next;\n        if (E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n      this.InsertLocalMinima(locMin);\n      this.m_edges.push(edges);\n      return true;\n    }\n    this.m_edges.push(edges);\n    var leftBoundIsForward;\n    var EMin = null;\n\n\t\t//workaround to avoid an endless loop in the while loop below when\n    //open paths have matching start and end points ...\n    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n    \tE = E.Next;\n\n    for (;;)\n    {\n      E = this.FindNextLocMin(E);\n      if (E == EMin)\n        break;\n      else if (EMin == null)\n        EMin = E;\n      //E and E.Prev now share a local minima (left aligned if horizontal).\n      //Compare their slopes to find which starts which bound ...\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      if (E.Dx < E.Prev.Dx)\n      {\n        locMin.LeftBound = E.Prev;\n        locMin.RightBound = E;\n        leftBoundIsForward = false;\n        //Q.nextInLML = Q.prev\n      }\n      else\n      {\n        locMin.LeftBound = E;\n        locMin.RightBound = E.Prev;\n        leftBoundIsForward = true;\n        //Q.nextInLML = Q.next\n      }\n      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      if (!Closed)\n        locMin.LeftBound.WindDelta = 0;\n      else if (locMin.LeftBound.Next == locMin.RightBound)\n        locMin.LeftBound.WindDelta = -1;\n      else\n        locMin.LeftBound.WindDelta = 1;\n      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n      \tE = this.ProcessBound(E, leftBoundIsForward);\n      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.LeftBound = null;\n      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.RightBound = null;\n      this.InsertLocalMinima(locMin);\n      if (!leftBoundIsForward)\n        E = E2;\n    }\n    return true;\n  };\n  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n  {\n    //  console.log(\"-------------------------------------------\");\n    //  console.log(JSON.stringify(ppg));\n    var result = false;\n    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n      if (this.AddPath(ppg[i], polyType, closed))\n        result = true;\n    return result;\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n  {\n    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\n   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n   return false;\n\n    else if (pt1.X != pt3.X)\n      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n    else\n      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n  };\n  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n  {\n    //removes e from double_linked_list (but without removing from memory)\n    e.Prev.Next = e.Next;\n    e.Next.Prev = e.Prev;\n    var result = e.Next;\n    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n    return result;\n  };\n  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n  {\n    e.Delta.X = (e.Top.X - e.Bot.X);\n    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n  };\n  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n  {\n    if (this.m_MinimaList === null)\n    {\n      this.m_MinimaList = newLm;\n    }\n    else if (newLm.Y >= this.m_MinimaList.Y)\n    {\n      newLm.Next = this.m_MinimaList;\n      this.m_MinimaList = newLm;\n    }\n    else\n    {\n      var tmpLm = this.m_MinimaList;\n      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n        tmpLm = tmpLm.Next;\n      newLm.Next = tmpLm.Next;\n      tmpLm.Next = newLm;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n  {\n    if (this.m_CurrentLM === null)\n      return;\n    this.m_CurrentLM = this.m_CurrentLM.Next;\n  };\n  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n  {\n    //swap horizontal edges' top and bottom x's so they follow the natural\n    //progression of the bounds - ie so their xbots will align with the\n    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n    var tmp = e.Top.X;\n    e.Top.X = e.Bot.X;\n    e.Bot.X = tmp;\n    if (use_xyz)\n    {\n      tmp = e.Top.Z;\n      e.Top.Z = e.Bot.Z;\n      e.Bot.Z = tmp;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.Reset = function ()\n  {\n    this.m_CurrentLM = this.m_MinimaList;\n    if (this.m_CurrentLM == null)\n      return;\n    //ie nothing to process\n    //reset all edges ...\n    var lm = this.m_MinimaList;\n    while (lm != null)\n    {\n      var e = lm.LeftBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esLeft;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      e = lm.RightBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esRight;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n  {\n    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n    this.m_PolyOuts = null;\n    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = null;\n    this.m_IntersectNodeComparer = null;\n    this.m_ExecuteLocked = false;\n    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_Joins = null;\n    this.m_GhostJoins = null;\n    this.m_UsingPolyTree = false;\n    this.ReverseSolution = false;\n    this.StrictlySimple = false;\n    ClipperLib.ClipperBase.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = new Array();\n    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n    this.m_ExecuteLocked = false;\n    this.m_UsingPolyTree = false;\n    this.m_PolyOuts = new Array();\n    this.m_Joins = new Array();\n    this.m_GhostJoins = new Array();\n    this.ReverseSolution = (1 & InitOptions) !== 0;\n    this.StrictlySimple = (2 & InitOptions) !== 0;\n    this.PreserveCollinear = (4 & InitOptions) !== 0;\n    if (use_xyz)\n    {\n      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n    }\n  };\n  ClipperLib.Clipper.ioReverseSolution = 1;\n  ClipperLib.Clipper.ioStrictlySimple = 2;\n  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\n  ClipperLib.Clipper.prototype.Clear = function ()\n  {\n    if (this.m_edges.length === 0)\n      return;\n    //avoids problems with ClipperBase destructor\n    this.DisposeAllPolyPts();\n    ClipperLib.ClipperBase.prototype.Clear.call(this);\n  };\n\n  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n  {\n    while (this.m_Scanbeam !== null)\n    {\n      var sb2 = this.m_Scanbeam.Next;\n      this.m_Scanbeam = null;\n      this.m_Scanbeam = sb2;\n    }\n  };\n  ClipperLib.Clipper.prototype.Reset = function ()\n  {\n    ClipperLib.ClipperBase.prototype.Reset.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n\n    var lm = this.m_MinimaList;\n    while (lm !== null)\n    {\n      this.InsertScanbeam(lm.Y);\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n  {\n    if (this.m_Scanbeam === null)\n    {\n      this.m_Scanbeam = new ClipperLib.Scanbeam();\n      this.m_Scanbeam.Next = null;\n      this.m_Scanbeam.Y = Y;\n    }\n    else if (Y > this.m_Scanbeam.Y)\n    {\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = this.m_Scanbeam;\n      this.m_Scanbeam = newSb;\n    }\n    else\n    {\n      var sb2 = this.m_Scanbeam;\n      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n        sb2 = sb2.Next;\n      if (Y == sb2.Y)\n        return;\n      //ie ignores duplicates\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = sb2.Next;\n      sb2.Next = newSb;\n    }\n  };\n  // ************************************\n  ClipperLib.Clipper.prototype.Execute = function ()\n  {\n    var a = arguments,\n      alen = a.length,\n      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        solution = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      if (this.m_HasOpenPaths)\n        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n      this.m_ExecuteLocked = true;\n      ClipperLib.Clear(solution);\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = false;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult(solution);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        polytree = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      this.m_ExecuteLocked = true;\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = true;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult2(polytree);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n    {\n      var clipType = a[0],\n        solution = a[1];\n      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n    {\n      var clipType = a[0],\n        polytree = a[1];\n      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n  {\n    //skip if an outermost polygon or\n    //already already points to the correct FirstLeft ...\n    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n      return;\n    var orfl = outRec.FirstLeft;\n    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n      orfl = orfl.FirstLeft;\n    outRec.FirstLeft = orfl;\n  };\n  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n  {\n    try\n    {\n      this.Reset();\n      if (this.m_CurrentLM === null)\n        return false;\n      var botY = this.PopScanbeam();\n      do {\n        this.InsertLocalMinimaIntoAEL(botY);\n        ClipperLib.Clear(this.m_GhostJoins);\n        this.ProcessHorizontals(false);\n        if (this.m_Scanbeam === null)\n          break;\n        var topY = this.PopScanbeam();\n        if (!this.ProcessIntersections(topY)) return false;\n\n        this.ProcessEdgesAtTopOfScanbeam(topY);\n        botY = topY;\n      }\n      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n      //fix orientations ...\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts === null || outRec.IsOpen)\n          continue;\n        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n          this.ReversePolyPtLinks(outRec.Pts);\n      }\n      this.JoinCommonEdges();\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts !== null && !outRec.IsOpen)\n          this.FixupOutPolygon(outRec);\n      }\n      if (this.StrictlySimple)\n        this.DoSimplePolygons();\n      return true;\n    }\n    finally\n    {\n      ClipperLib.Clear(this.m_Joins);\n      ClipperLib.Clear(this.m_GhostJoins);\n    }\n  };\n  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n  {\n    var Y = this.m_Scanbeam.Y;\n    this.m_Scanbeam = this.m_Scanbeam.Next;\n    return Y;\n  };\n\n  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n      this.DisposeOutRec(i);\n    ClipperLib.Clear(this.m_PolyOuts);\n  };\n  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n  {\n    var outRec = this.m_PolyOuts[index];\n    outRec.Pts = null;\n    outRec = null;\n    this.m_PolyOuts[index] = null;\n  };\n\n  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op1;\n    j.OutPt2 = Op2;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_Joins.push(j);\n  };\n  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_GhostJoins.push(j);\n  };\n  if (use_xyz)\n  {\n    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n    {\n      if (this.ZFillFunction !== null)\n      {\n        if (pt.Z != 0 || this.ZFillFunction === null) return;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n      }\n    };\n\n    //------------------------------------------------------------------------------\n  }\n\n  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n  {\n    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n    {\n      var lb = this.m_CurrentLM.LeftBound;\n      var rb = this.m_CurrentLM.RightBound;\n      this.PopLocalMinima();\n      var Op1 = null;\n      if (lb === null)\n      {\n        this.InsertEdgeIntoAEL(rb, null);\n        this.SetWindingCount(rb);\n        if (this.IsContributing(rb))\n          Op1 = this.AddOutPt(rb, rb.Bot);\n      }\n      else if (rb == null)\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.SetWindingCount(lb);\n        if (this.IsContributing(lb))\n          Op1 = this.AddOutPt(lb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      else\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.InsertEdgeIntoAEL(rb, lb);\n        this.SetWindingCount(lb);\n        rb.WindCnt = lb.WindCnt;\n        rb.WindCnt2 = lb.WindCnt2;\n        if (this.IsContributing(lb))\n          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      if (rb != null)\n      {\n        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n          this.AddEdgeToSEL(rb);\n        else\n          this.InsertScanbeam(rb.Top.Y);\n      }\n      if (lb == null || rb == null) continue;\n      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n      {\n        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n        {\n          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n          //the 'ghost' join to a real join ready for later ...\n          var j = this.m_GhostJoins[i];\n\n\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n        }\n      }\n      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n        lb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n      {\n        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n        this.AddJoin(Op1, Op2, lb.Top);\n      }\n      if (lb.NextInAEL != rb)\n      {\n        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n        {\n          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n          this.AddJoin(Op1, Op2, rb.Top);\n        }\n        var e = lb.NextInAEL;\n        if (e !== null)\n          while (e != rb)\n          {\n            //nb: For calculating winding counts etc, IntersectEdges() assumes\n            //that param1 will be to the right of param2 ABOVE the intersection ...\n            this.IntersectEdges(rb, e, lb.Curr, false);\n            //order important here\n            e = e.NextInAEL;\n          }\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n  {\n    if (this.m_ActiveEdges === null)\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = null;\n      this.m_ActiveEdges = edge;\n    }\n    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = this.m_ActiveEdges;\n      this.m_ActiveEdges.PrevInAEL = edge;\n      this.m_ActiveEdges = edge;\n    }\n    else\n    {\n      if (startEdge === null)\n        startEdge = this.m_ActiveEdges;\n      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n        startEdge = startEdge.NextInAEL;\n      edge.NextInAEL = startEdge.NextInAEL;\n      if (startEdge.NextInAEL !== null)\n        startEdge.NextInAEL.PrevInAEL = edge;\n      edge.PrevInAEL = startEdge;\n      startEdge.NextInAEL = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n  {\n    if (e2.Curr.X == e1.Curr.X)\n    {\n      if (e2.Top.Y > e1.Top.Y)\n        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n      else\n        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n    }\n    else\n      return e2.Curr.X < e1.Curr.X;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n  {\n    var pft, pft2;\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      pft = this.m_SubjFillType;\n      pft2 = this.m_ClipFillType;\n    }\n    else\n    {\n      pft = this.m_ClipFillType;\n      pft2 = this.m_SubjFillType;\n    }\n    switch (pft)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftNonZero:\n      if (Math.abs(edge.WindCnt) != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftPositive:\n      if (edge.WindCnt != 1)\n        return false;\n      break;\n    default:\n      if (edge.WindCnt != -1)\n        return false;\n      break;\n    }\n    switch (this.m_ClipType)\n    {\n    case ClipperLib.ClipType.ctIntersection:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 !== 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 > 0);\n      default:\n        return (edge.WindCnt2 < 0);\n      }\n    case ClipperLib.ClipType.ctUnion:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    case ClipperLib.ClipType.ctDifference:\n      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 !== 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 > 0);\n        default:\n          return (edge.WindCnt2 < 0);\n        }\n    case ClipperLib.ClipType.ctXor:\n      if (edge.WindDelta === 0)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        return true;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n  {\n    var e = edge.PrevInAEL;\n    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n      e = e.PrevInAEL;\n    if (e === null)\n    {\n      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      edge.WindCnt2 = 0;\n      e = this.m_ActiveEdges;\n      //ie get ready to calc WindCnt2\n    }\n    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n    {\n      edge.WindCnt = 1;\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else if (this.IsEvenOddFillType(edge))\n    {\n      //EvenOdd filling ...\n      if (edge.WindDelta === 0)\n      {\n        //are we inside a subj polygon ...\n        var Inside = true;\n        var e2 = e.PrevInAEL;\n        while (e2 !== null)\n        {\n          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n            Inside = !Inside;\n          e2 = e2.PrevInAEL;\n        }\n        edge.WindCnt = (Inside ? 0 : 1);\n      }\n      else\n      {\n        edge.WindCnt = edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      if (e.WindCnt * e.WindDelta < 0)\n      {\n        //prev edge is 'decreasing' WindCount (WC) toward zero\n        //so we're outside the previous polygon ...\n        if (Math.abs(e.WindCnt) > 1)\n        {\n          //outside prev poly but still inside another.\n          //when reversing direction of prev poly use the same WC\n          if (e.WindDelta * edge.WindDelta < 0)\n            edge.WindCnt = e.WindCnt;\n          else\n            edge.WindCnt = e.WindCnt + edge.WindDelta;\n        }\n        else\n          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      }\n      else\n      {\n        //prev edge is 'increasing' WindCount (WC) away from zero\n        //so we're inside the previous polygon ...\n        if (edge.WindDelta === 0)\n          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n        else if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    //update WindCnt2 ...\n    if (this.IsEvenOddAltFillType(edge))\n    {\n      //EvenOdd filling ...\n      while (e != edge)\n      {\n        if (e.WindDelta !== 0)\n          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n        e = e.NextInAEL;\n      }\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      while (e != edge)\n      {\n        edge.WindCnt2 += e.WindDelta;\n        e = e.NextInAEL;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n  {\n    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n    //However, we don't need to worry about order with horizontal edge processing.\n    if (this.m_SortedEdges === null)\n    {\n      this.m_SortedEdges = edge;\n      edge.PrevInSEL = null;\n      edge.NextInSEL = null;\n    }\n    else\n    {\n      edge.NextInSEL = this.m_SortedEdges;\n      edge.PrevInSEL = null;\n      this.m_SortedEdges.PrevInSEL = edge;\n      this.m_SortedEdges = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n  {\n    var e = this.m_ActiveEdges;\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n  {\n    //check that one or other edge hasn't already been removed from AEL ...\n    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n      return;\n    if (edge1.NextInAEL == edge2)\n    {\n      var next = edge2.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge1;\n      var prev = edge1.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      edge2.NextInAEL = edge1;\n      edge1.PrevInAEL = edge2;\n      edge1.NextInAEL = next;\n    }\n    else if (edge2.NextInAEL == edge1)\n    {\n      var next = edge1.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge2;\n      var prev = edge2.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge1;\n      edge1.PrevInAEL = prev;\n      edge1.NextInAEL = edge2;\n      edge2.PrevInAEL = edge1;\n      edge2.NextInAEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInAEL;\n      var prev = edge1.PrevInAEL;\n      edge1.NextInAEL = edge2.NextInAEL;\n      if (edge1.NextInAEL !== null)\n        edge1.NextInAEL.PrevInAEL = edge1;\n      edge1.PrevInAEL = edge2.PrevInAEL;\n      if (edge1.PrevInAEL !== null)\n        edge1.PrevInAEL.NextInAEL = edge1;\n      edge2.NextInAEL = next;\n      if (edge2.NextInAEL !== null)\n        edge2.NextInAEL.PrevInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      if (edge2.PrevInAEL !== null)\n        edge2.PrevInAEL.NextInAEL = edge2;\n    }\n    if (edge1.PrevInAEL === null)\n      this.m_ActiveEdges = edge1;\n    else if (edge2.PrevInAEL === null)\n      this.m_ActiveEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n  {\n    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n      return;\n    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n      return;\n    if (edge1.NextInSEL == edge2)\n    {\n      var next = edge2.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge1;\n      var prev = edge1.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      edge2.NextInSEL = edge1;\n      edge1.PrevInSEL = edge2;\n      edge1.NextInSEL = next;\n    }\n    else if (edge2.NextInSEL == edge1)\n    {\n      var next = edge1.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge2;\n      var prev = edge2.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge1;\n      edge1.PrevInSEL = prev;\n      edge1.NextInSEL = edge2;\n      edge2.PrevInSEL = edge1;\n      edge2.NextInSEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInSEL;\n      var prev = edge1.PrevInSEL;\n      edge1.NextInSEL = edge2.NextInSEL;\n      if (edge1.NextInSEL !== null)\n        edge1.NextInSEL.PrevInSEL = edge1;\n      edge1.PrevInSEL = edge2.PrevInSEL;\n      if (edge1.PrevInSEL !== null)\n        edge1.PrevInSEL.NextInSEL = edge1;\n      edge2.NextInSEL = next;\n      if (edge2.NextInSEL !== null)\n        edge2.NextInSEL.PrevInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      if (edge2.PrevInSEL !== null)\n        edge2.PrevInSEL.NextInSEL = edge2;\n    }\n    if (edge1.PrevInSEL === null)\n      this.m_SortedEdges = edge1;\n    else if (edge2.PrevInSEL === null)\n      this.m_SortedEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n  {\n    this.AddOutPt(e1, pt);\n    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n    if (e1.OutIdx == e2.OutIdx)\n    {\n      e1.OutIdx = -1;\n      e2.OutIdx = -1;\n    }\n    else if (e1.OutIdx < e2.OutIdx)\n      this.AppendPolygon(e1, e2);\n    else\n      this.AppendPolygon(e2, e1);\n  };\n  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n  {\n    var result;\n    var e, prevE;\n    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n    {\n      result = this.AddOutPt(e1, pt);\n      e2.OutIdx = e1.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esLeft;\n      e2.Side = ClipperLib.EdgeSide.esRight;\n      e = e1;\n      if (e.PrevInAEL == e2)\n        prevE = e2.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    else\n    {\n      result = this.AddOutPt(e2, pt);\n      e1.OutIdx = e2.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esRight;\n      e2.Side = ClipperLib.EdgeSide.esLeft;\n      e = e2;\n      if (e.PrevInAEL == e1)\n        prevE = e1.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n    {\n      var outPt = this.AddOutPt(prevE, pt);\n      this.AddJoin(result, outPt, e.Top);\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n  {\n    var result = new ClipperLib.OutRec();\n    result.Idx = -1;\n    result.IsHole = false;\n    result.IsOpen = false;\n    result.FirstLeft = null;\n    result.Pts = null;\n    result.BottomPt = null;\n    result.PolyNode = null;\n    this.m_PolyOuts.push(result);\n    result.Idx = this.m_PolyOuts.length - 1;\n    return result;\n  };\n  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n  {\n    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n    if (e.OutIdx < 0)\n    {\n      var outRec = this.CreateOutRec();\n      outRec.IsOpen = (e.WindDelta === 0);\n      var newOp = new ClipperLib.OutPt();\n      outRec.Pts = newOp;\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = newOp;\n      newOp.Prev = newOp;\n      if (!outRec.IsOpen)\n        this.SetHoleState(e, outRec);\n      e.OutIdx = outRec.Idx;\n      //nb: do this after SetZ !\n      return newOp;\n    }\n    else\n    {\n      var outRec = this.m_PolyOuts[e.OutIdx];\n      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n      var op = outRec.Pts;\n      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n        return op;\n      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n        return op.Prev;\n      var newOp = new ClipperLib.OutPt();\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = op;\n      newOp.Prev = op.Prev;\n      newOp.Prev.Next = newOp;\n      op.Prev = newOp;\n      if (ToFront)\n        outRec.Pts = newOp;\n      return newOp;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n  {\n    var tmp = new ClipperLib.IntPoint(pt1.Value);\n    //pt1.Value = pt2.Value;\n    pt1.Value.X = pt2.Value.X;\n    pt1.Value.Y = pt2.Value.Y;\n    //pt2.Value = tmp;\n    pt2.Value.X = tmp.X;\n    pt2.Value.Y = tmp.Y;\n  };\n  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t{\n\t\tvar tmp;\n\t\tif (seg1a > seg1b)\n\t\t{\n\t\t\ttmp = seg1a;\n\t\t\tseg1a = seg1b;\n\t\t\tseg1b = tmp;\n\t\t}\n\t\tif (seg2a > seg2b)\n\t\t{\n\t\t\ttmp = seg2a;\n\t\t\tseg2a = seg2b;\n\t\t\tseg2b = tmp;\n\t\t}\n\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t}\n\n  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n  {\n    var isHole = false;\n    var e2 = e.PrevInAEL;\n    while (e2 !== null)\n    {\n      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n      {\n        isHole = !isHole;\n        if (outRec.FirstLeft === null)\n          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n      }\n      e2 = e2.PrevInAEL;\n    }\n    if (isHole)\n      outRec.IsHole = true;\n  };\n  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n  {\n    if (pt1.Y == pt2.Y)\n      return ClipperLib.ClipperBase.horizontal;\n    else\n      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n  };\n  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n  {\n    var p = btmPt1.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Prev;\n    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt1.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Next;\n    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt2.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Prev;\n    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    p = btmPt2.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Next;\n    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n  };\n  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n  {\n    var dups = null;\n    var p = pp.Next;\n    while (p != pp)\n    {\n      if (p.Pt.Y > pp.Pt.Y)\n      {\n        pp = p;\n        dups = null;\n      }\n      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n      {\n        if (p.Pt.X < pp.Pt.X)\n        {\n          dups = null;\n          pp = p;\n        }\n        else\n        {\n          if (p.Next != pp && p.Prev != pp)\n            dups = p;\n        }\n      }\n      p = p.Next;\n    }\n    if (dups !== null)\n    {\n      //there appears to be at least 2 vertices at bottomPt so ...\n      while (dups != p)\n      {\n        if (!this.FirstIsBottomPt(p, dups))\n          pp = dups;\n        dups = dups.Next;\n        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n          dups = dups.Next;\n      }\n    }\n    return pp;\n  };\n  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n  {\n    //work out which polygon fragment has the correct hole state ...\n    if (outRec1.BottomPt === null)\n      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n    if (outRec2.BottomPt === null)\n      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n    var bPt1 = outRec1.BottomPt;\n    var bPt2 = outRec2.BottomPt;\n    if (bPt1.Pt.Y > bPt2.Pt.Y)\n      return outRec1;\n    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n      return outRec2;\n    else if (bPt1.Pt.X < bPt2.Pt.X)\n      return outRec1;\n    else if (bPt1.Pt.X > bPt2.Pt.X)\n      return outRec2;\n    else if (bPt1.Next == bPt1)\n      return outRec2;\n    else if (bPt2.Next == bPt2)\n      return outRec1;\n    else if (this.FirstIsBottomPt(bPt1, bPt2))\n      return outRec1;\n    else\n      return outRec2;\n  };\n  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n  {\n    do {\n      outRec1 = outRec1.FirstLeft;\n      if (outRec1 == outRec2)\n        return true;\n    }\n    while (outRec1 !== null)\n    return false;\n  };\n  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n  {\n    var outrec = this.m_PolyOuts[idx];\n    while (outrec != this.m_PolyOuts[outrec.Idx])\n      outrec = this.m_PolyOuts[outrec.Idx];\n    return outrec;\n  };\n  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n  {\n    //get the start and ends of both output polygons ...\n    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n    var holeStateRec;\n    if (this.Param1RightOfParam2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.Param1RightOfParam2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n    var p1_lft = outRec1.Pts;\n    var p1_rt = p1_lft.Prev;\n    var p2_lft = outRec2.Pts;\n    var p2_rt = p2_lft.Prev;\n    var side;\n    //join e2 poly onto e1 poly and delete pointers to e2 ...\n    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n      {\n        //z y x a b c\n        this.ReversePolyPtLinks(p2_lft);\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        outRec1.Pts = p2_rt;\n      }\n      else\n      {\n        //x y z a b c\n        p2_rt.Next = p1_lft;\n        p1_lft.Prev = p2_rt;\n        p2_lft.Prev = p1_rt;\n        p1_rt.Next = p2_lft;\n        outRec1.Pts = p2_lft;\n      }\n      side = ClipperLib.EdgeSide.esLeft;\n    }\n    else\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esRight)\n      {\n        //a b c z y x\n        this.ReversePolyPtLinks(p2_lft);\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n      }\n      else\n      {\n        //a b c x y z\n        p1_rt.Next = p2_lft;\n        p2_lft.Prev = p1_rt;\n        p1_lft.Prev = p2_rt;\n        p2_rt.Next = p1_lft;\n      }\n      side = ClipperLib.EdgeSide.esRight;\n    }\n    outRec1.BottomPt = null;\n    if (holeStateRec == outRec2)\n    {\n      if (outRec2.FirstLeft != outRec1)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec1.IsHole = outRec2.IsHole;\n    }\n    outRec2.Pts = null;\n    outRec2.BottomPt = null;\n    outRec2.FirstLeft = outRec1;\n    var OKIdx = e1.OutIdx;\n    var ObsoleteIdx = e2.OutIdx;\n    e1.OutIdx = -1;\n    //nb: safe because we only get here via AddLocalMaxPoly\n    e2.OutIdx = -1;\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (e.OutIdx == ObsoleteIdx)\n      {\n        e.OutIdx = OKIdx;\n        e.Side = side;\n        break;\n      }\n      e = e.NextInAEL;\n    }\n    outRec2.Idx = outRec1.Idx;\n  };\n  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n  {\n    if (pp === null)\n      return;\n    var pp1;\n    var pp2;\n    pp1 = pp;\n    do {\n      pp2 = pp1.Next;\n      pp1.Next = pp1.Prev;\n      pp1.Prev = pp2;\n      pp1 = pp2;\n    }\n    while (pp1 != pp)\n  };\n  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n  {\n    var side = edge1.Side;\n    edge1.Side = edge2.Side;\n    edge2.Side = side;\n  };\n  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n  {\n    var outIdx = edge1.OutIdx;\n    edge1.OutIdx = edge2.OutIdx;\n    edge2.OutIdx = outIdx;\n  };\n  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n  {\n    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n    //e2 in AEL except when e1 is being inserted at the intersection point ...\n    var e1Contributing = (e1.OutIdx >= 0);\n    var e2Contributing = (e2.OutIdx >= 0);\n\n    if (use_xyz)\n    \tthis.SetZ(pt, e1, e2);\n\n    if (use_lines)\n    {\n      //if either edge is on an OPEN path ...\n      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n      {\n        //ignore subject-subject open path intersections UNLESS they\n        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n        //if intersecting a subj line with a subj poly ...\n        else if (e1.PolyTyp == e2.PolyTyp &&\n          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n        {\n          if (e1.WindDelta === 0)\n          {\n            if (e2Contributing)\n            {\n              this.AddOutPt(e1, pt);\n              if (e1Contributing)\n                e1.OutIdx = -1;\n            }\n          }\n          else\n          {\n            if (e1Contributing)\n            {\n              this.AddOutPt(e2, pt);\n              if (e2Contributing)\n                e2.OutIdx = -1;\n            }\n          }\n        }\n        else if (e1.PolyTyp != e2.PolyTyp)\n        {\n          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n          {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing)\n              e1.OutIdx = -1;\n          }\n          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n          {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing)\n              e2.OutIdx = -1;\n          }\n        }\n        return;\n      }\n    }\n    //update winding counts...\n    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n    if (e1.PolyTyp == e2.PolyTyp)\n    {\n      if (this.IsEvenOddFillType(e1))\n      {\n        var oldE1WindCnt = e1.WindCnt;\n        e1.WindCnt = e2.WindCnt;\n        e2.WindCnt = oldE1WindCnt;\n      }\n      else\n      {\n        if (e1.WindCnt + e2.WindDelta === 0)\n          e1.WindCnt = -e1.WindCnt;\n        else\n          e1.WindCnt += e2.WindDelta;\n        if (e2.WindCnt - e1.WindDelta === 0)\n          e2.WindCnt = -e2.WindCnt;\n        else\n          e2.WindCnt -= e1.WindDelta;\n      }\n    }\n    else\n    {\n      if (!this.IsEvenOddFillType(e2))\n        e1.WindCnt2 += e2.WindDelta;\n      else\n        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n      if (!this.IsEvenOddFillType(e1))\n        e2.WindCnt2 -= e1.WindDelta;\n      else\n        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n    }\n    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e1FillType = this.m_SubjFillType;\n      e1FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e1FillType = this.m_ClipFillType;\n      e1FillType2 = this.m_SubjFillType;\n    }\n    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e2FillType = this.m_SubjFillType;\n      e2FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e2FillType = this.m_ClipFillType;\n      e2FillType2 = this.m_SubjFillType;\n    }\n    var e1Wc, e2Wc;\n    switch (e1FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc = e1.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc = -e1.WindCnt;\n      break;\n    default:\n      e1Wc = Math.abs(e1.WindCnt);\n      break;\n    }\n    switch (e2FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc = e2.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc = -e2.WindCnt;\n      break;\n    default:\n      e2Wc = Math.abs(e2.WindCnt);\n      break;\n    }\n    if (e1Contributing && e2Contributing)\n    {\n\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t{\n\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t}\n      else\n      {\n        this.AddOutPt(e1, pt);\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e1Contributing)\n    {\n      if (e2Wc === 0 || e2Wc == 1)\n      {\n        this.AddOutPt(e1, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e2Contributing)\n    {\n      if (e1Wc === 0 || e1Wc == 1)\n      {\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n    {\n      //neither edge is currently contributing ...\n      var e1Wc2, e2Wc2;\n      switch (e1FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e1Wc2 = e1.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e1Wc2 = -e1.WindCnt2;\n        break;\n      default:\n        e1Wc2 = Math.abs(e1.WindCnt2);\n        break;\n      }\n      switch (e2FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e2Wc2 = e2.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e2Wc2 = -e2.WindCnt2;\n        break;\n      default:\n        e2Wc2 = Math.abs(e2.WindCnt2);\n        break;\n      }\n      if (e1.PolyTyp != e2.PolyTyp)\n      {\n        this.AddLocalMinPoly(e1, e2, pt);\n      }\n      else if (e1Wc == 1 && e2Wc == 1)\n        switch (this.m_ClipType)\n        {\n        case ClipperLib.ClipType.ctIntersection:\n          if (e1Wc2 > 0 && e2Wc2 > 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctUnion:\n          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctDifference:\n          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctXor:\n          this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        }\n      else\n        ClipperLib.Clipper.SwapSides(e1, e2);\n    }\n  };\n  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n  {\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n      return;\n    //already deleted\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = AelNext;\n    else\n      this.m_ActiveEdges = AelNext;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = AelPrev;\n    e.NextInAEL = null;\n    e.PrevInAEL = null;\n  };\n  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n  {\n    var SelPrev = e.PrevInSEL;\n    var SelNext = e.NextInSEL;\n    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n      return;\n    //already deleted\n    if (SelPrev !== null)\n      SelPrev.NextInSEL = SelNext;\n    else\n      this.m_SortedEdges = SelNext;\n    if (SelNext !== null)\n      SelNext.PrevInSEL = SelPrev;\n    e.NextInSEL = null;\n    e.PrevInSEL = null;\n  };\n  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n  {\n    if (e.NextInLML === null)\n      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    e.NextInLML.OutIdx = e.OutIdx;\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = e.NextInLML;\n    else\n      this.m_ActiveEdges = e.NextInLML;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = e.NextInLML;\n    e.NextInLML.Side = e.Side;\n    e.NextInLML.WindDelta = e.WindDelta;\n    e.NextInLML.WindCnt = e.WindCnt;\n    e.NextInLML.WindCnt2 = e.WindCnt2;\n    e = e.NextInLML;\n    //    e.Curr = e.Bot;\n    e.Curr.X = e.Bot.X;\n    e.Curr.Y = e.Bot.Y;\n    e.PrevInAEL = AelPrev;\n    e.NextInAEL = AelNext;\n    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n      this.InsertScanbeam(e.Top.Y);\n    return e;\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n  {\n    var horzEdge = this.m_SortedEdges;\n    while (horzEdge !== null)\n    {\n      this.DeleteFromSEL(horzEdge);\n      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n      horzEdge = this.m_SortedEdges;\n    }\n  };\n  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n  {\n    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n    {\n        $var.Left = HorzEdge.Bot.X;\n        $var.Right = HorzEdge.Top.X;\n        $var.Dir = ClipperLib.Direction.dLeftToRight;\n    }\n    else\n    {\n        $var.Left = HorzEdge.Top.X;\n        $var.Right = HorzEdge.Bot.X;\n        $var.Dir = ClipperLib.Direction.dRightToLeft;\n    }\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n  {\n    var $var = {Dir: null, Left: null, Right: null};\n    this.GetHorzDirection(horzEdge, $var);\n    var dir = $var.Dir;\n    var horzLeft = $var.Left;\n    var horzRight = $var.Right;\n\n    var eLastHorz = horzEdge,\n      eMaxPair = null;\n    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n      eLastHorz = eLastHorz.NextInLML;\n    if (eLastHorz.NextInLML === null)\n      eMaxPair = this.GetMaximaPair(eLastHorz);\n    for (;;)\n    {\n      var IsLastHorz = (horzEdge == eLastHorz);\n      var e = this.GetNextInAEL(horzEdge, dir);\n      while (e !== null)\n      {\n        //Break if we've got to the end of an intermediate horizontal edge ...\n        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n          break;\n        var eNext = this.GetNextInAEL(e, dir);\n        //saves eNext for later\n        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n        {\n          //so far we're still in range of the horizontal Edge  but make sure\n          //we're at the last of consec. horizontals when matching with eMaxPair\n          if (e == eMaxPair && IsLastHorz)\n          {\n\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n            return;\n          }\n          else if (dir == ClipperLib.Direction.dLeftToRight)\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(horzEdge, e, Pt);\n          }\n          else\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(e, horzEdge, Pt);\n          }\n          this.SwapPositionsInAEL(horzEdge, e);\n        }\n        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n          break;\n        e = eNext;\n      }\n      //end while\n      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n      {\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.OutIdx >= 0)\n          this.AddOutPt(horzEdge, horzEdge.Bot);\n\n          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n          this.GetHorzDirection(horzEdge, $var);\n          dir = $var.Dir;\n          horzLeft = $var.Left;\n          horzRight = $var.Right;\n      }\n      else\n        break;\n    }\n    //end for (;;)\n    if (horzEdge.NextInLML !== null)\n    {\n      if (horzEdge.OutIdx >= 0)\n      {\n        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.WindDelta === 0)\n          return;\n        //nb: HorzEdge is no longer horizontal here\n        var ePrev = horzEdge.PrevInAEL;\n        var eNext = horzEdge.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n        {\n          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n        {\n          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n      }\n      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    }\n  \telse\n    {\n      if (horzEdge.OutIdx >= 0)\n        this.AddOutPt(horzEdge, horzEdge.Top);\n      this.DeleteFromAEL(horzEdge);\n    }\n  };\n  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n  {\n    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n  };\n  ClipperLib.Clipper.prototype.IsMinima = function (e)\n  {\n    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n  };\n  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n  {\n    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n  };\n  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n  {\n    return (e.Top.Y == Y && e.NextInLML !== null);\n  };\n  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n  {\n    var result = null;\n    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n      result = e.Next;\n    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n      result = e.Prev;\n    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n      return null;\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n  {\n    if (this.m_ActiveEdges == null)\n      return true;\n    try\n    {\n      this.BuildIntersectList(topY);\n      if (this.m_IntersectList.length == 0)\n        return true;\n      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n        this.ProcessIntersectList();\n      else\n        return false;\n    }\n    catch ($$e2)\n    {\n      this.m_SortedEdges = null;\n      this.m_IntersectList.length = 0;\n      ClipperLib.Error(\"ProcessIntersections error\");\n    }\n    this.m_SortedEdges = null;\n    return true;\n  };\n  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n  {\n    if (this.m_ActiveEdges === null)\n      return;\n    //prepare for sorting ...\n    var e = this.m_ActiveEdges;\n    //console.log(JSON.stringify(JSON.decycle( e )));\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n      e = e.NextInAEL;\n    }\n    //bubblesort ...\n    var isModified = true;\n    while (isModified && this.m_SortedEdges !== null)\n    {\n      isModified = false;\n      e = this.m_SortedEdges;\n      while (e.NextInSEL !== null)\n      {\n        var eNext = e.NextInSEL;\n        var pt = new ClipperLib.IntPoint();\n        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n        if (e.Curr.X > eNext.Curr.X)\n        {\n\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n          var newNode = new ClipperLib.IntersectNode();\n          newNode.Edge1 = e;\n          newNode.Edge2 = eNext;\n          //newNode.Pt = pt;\n          newNode.Pt.X = pt.X;\n          newNode.Pt.Y = pt.Y;\n          this.m_IntersectList.push(newNode);\n          this.SwapPositionsInSEL(e, eNext);\n          isModified = true;\n        }\n        else\n          e = eNext;\n      }\n      if (e.PrevInSEL !== null)\n        e.PrevInSEL.NextInSEL = null;\n      else\n        break;\n    }\n    this.m_SortedEdges = null;\n  };\n  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n  {\n    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n  };\n  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n  {\n    //the following typecast is safe because the differences in Pt.Y will\n    //be limited to the height of the scanbeam.\n    return (node2.Pt.Y - node1.Pt.Y);\n  };\n  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n  {\n    //pre-condition: intersections are sorted bottom-most first.\n    //Now it's crucial that intersections are made only between adjacent edges,\n    //so to ensure this the order of intersections may need adjusting ...\n    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n    this.CopyAELToSEL();\n    var cnt = this.m_IntersectList.length;\n    for (var i = 0; i < cnt; i++)\n    {\n      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n      {\n        var j = i + 1;\n        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n          j++;\n        if (j == cnt)\n          return false;\n        var tmp = this.m_IntersectList[i];\n        this.m_IntersectList[i] = this.m_IntersectList[j];\n        this.m_IntersectList[j] = tmp;\n      }\n      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n  {\n    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n    {\n      var iNode = this.m_IntersectList[i];\n      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n    }\n    this.m_IntersectList.length = 0;\n  };\n  /*\n  --------------------------------\n  Round speedtest: http://jsperf.com/fastest-round\n  --------------------------------\n  */\n  var R1 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n  };\n  var R2 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n  };\n  var R3 = function (a)\n  {\n    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n  };\n  var R4 = function (a)\n  {\n    if (a < 0)\n    {\n      a -= 0.5;\n      return a < -2147483648 ? Math.ceil(a) : a | 0;\n    }\n    else\n    {\n      a += 0.5;\n      return a > 2147483647 ? Math.floor(a) : a | 0;\n    }\n  };\n  if (browser.msie) ClipperLib.Clipper.Round = R1;\n  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n  ClipperLib.Clipper.TopX = function (edge, currentY)\n  {\n    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n    if (currentY == edge.Top.Y)\n      return edge.Top.X;\n    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n  };\n  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n  {\n    ip.X = 0;\n    ip.Y = 0;\n    var b1, b2;\n    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n    //return false but for the edge.Dx value be equal due to double precision rounding.\n    if (edge1.Dx == edge2.Dx)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\treturn;\n    }\n    if (edge1.Delta.X === 0)\n    {\n      ip.X = edge1.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n      {\n        ip.Y = edge2.Bot.Y;\n      }\n      else\n      {\n        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n      }\n    }\n    else if (edge2.Delta.X === 0)\n    {\n      ip.X = edge2.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n      {\n        ip.Y = edge1.Bot.Y;\n      }\n      else\n      {\n        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n      }\n    }\n    else\n    {\n      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n      ip.Y = ClipperLib.Clipper.Round(q);\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n      else\n        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n    }\n    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n    {\n      if (edge1.Top.Y > edge2.Top.Y)\n      {\n        ip.Y = edge1.Top.Y;\n        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n        return ip.X < edge1.Top.X;\n      }\n      else\n        ip.Y = edge2.Top.Y;\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n      else\n        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n    }\n\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\tif (ip.Y > edge1.Curr.Y)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t}\n  };\n\n  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n  {\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n      var IsMaximaEdge = this.IsMaxima(e, topY);\n      if (IsMaximaEdge)\n      {\n        var eMaxPair = this.GetMaximaPair(e);\n        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n      }\n      if (IsMaximaEdge)\n      {\n        var ePrev = e.PrevInAEL;\n        this.DoMaxima(e);\n        if (ePrev === null)\n          e = this.m_ActiveEdges;\n        else\n          e = ePrev.NextInAEL;\n      }\n      else\n      {\n        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n        {\n          e = this.UpdateEdgeIntoAEL(e);\n          if (e.OutIdx >= 0)\n            this.AddOutPt(e, e.Bot);\n          this.AddEdgeToSEL(e);\n        }\n        else\n        {\n          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n          e.Curr.Y = topY;\n        }\n        if (this.StrictlySimple)\n        {\n          var ePrev = e.PrevInAEL;\n          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n            (ePrev.WindDelta !== 0))\n          {\n           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\n\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t}\n\n            var op = this.AddOutPt(ePrev, ip);\n            var op2 = this.AddOutPt(e, ip);\n            this.AddJoin(op, op2, ip);\n            //StrictlySimple (type-3) join\n          }\n        }\n        e = e.NextInAEL;\n      }\n    }\n    //3. Process horizontals at the Top of the scanbeam ...\n    this.ProcessHorizontals(true);\n    //4. Promote intermediate vertices ...\n    e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (this.IsIntermediate(e, topY))\n      {\n        var op = null;\n        if (e.OutIdx >= 0)\n          op = this.AddOutPt(e, e.Top);\n        e = this.UpdateEdgeIntoAEL(e);\n        //if output polygons share an edge, they'll need joining later ...\n        var ePrev = e.PrevInAEL;\n        var eNext = e.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(ePrev, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n          eNext.Curr.Y == e.Bot.Y && op !== null &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(eNext, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n      }\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n  {\n    var eMaxPair = this.GetMaximaPair(e);\n    if (eMaxPair === null)\n    {\n      if (e.OutIdx >= 0)\n        this.AddOutPt(e, e.Top);\n      this.DeleteFromAEL(e);\n      return;\n    }\n    var eNext = e.NextInAEL;\n    var use_lines = true;\n    while (eNext !== null && eNext != eMaxPair)\n    {\n      this.IntersectEdges(e, eNext, e.Top);\n      this.SwapPositionsInAEL(e, eNext);\n      eNext = e.NextInAEL;\n    }\n    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n    {\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n    {\n    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (use_lines && e.WindDelta === 0)\n    {\n      if (e.OutIdx >= 0)\n      {\n        this.AddOutPt(e, e.Top);\n        e.OutIdx = -1;\n      }\n      this.DeleteFromAEL(e);\n      if (eMaxPair.OutIdx >= 0)\n      {\n        this.AddOutPt(eMaxPair, e.Top);\n        eMaxPair.OutIdx = -1;\n      }\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else\n      ClipperLib.Error(\"DoMaxima error\");\n  };\n  ClipperLib.Clipper.ReversePaths = function (polys)\n  {\n    for (var i = 0, len = polys.length; i < len; i++)\n      polys[i].reverse();\n  };\n  ClipperLib.Clipper.Orientation = function (poly)\n  {\n    return ClipperLib.Clipper.Area(poly) >= 0;\n  };\n  ClipperLib.Clipper.prototype.PointCount = function (pts)\n  {\n    if (pts === null)\n      return 0;\n    var result = 0;\n    var p = pts;\n    do {\n      result++;\n      p = p.Next;\n    }\n    while (p != pts)\n    return result;\n  };\n  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n  {\n    ClipperLib.Clear(polyg);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null)\n        continue;\n      var p = outRec.Pts.Prev;\n      var cnt = this.PointCount(p);\n      if (cnt < 2)\n        continue;\n      var pg = new Array(cnt);\n      for (var j = 0; j < cnt; j++)\n      {\n        pg[j] = p.Pt;\n        p = p.Prev;\n      }\n      polyg.push(pg);\n    }\n  };\n  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n  {\n    polytree.Clear();\n    //add each output polygon/contour to polytree ...\n    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      var cnt = this.PointCount(outRec.Pts);\n      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n        continue;\n      this.FixHoleLinkage(outRec);\n      var pn = new ClipperLib.PolyNode();\n      polytree.m_AllPolys.push(pn);\n      outRec.PolyNode = pn;\n      pn.m_polygon.length = cnt;\n      var op = outRec.Pts.Prev;\n      for (var j = 0; j < cnt; j++)\n      {\n        pn.m_polygon[j] = op.Pt;\n        op = op.Prev;\n      }\n    }\n    //fixup PolyNode links etc ...\n    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.PolyNode === null)\n        continue;\n      else if (outRec.IsOpen)\n      {\n        outRec.PolyNode.IsOpen = true;\n        polytree.AddChild(outRec.PolyNode);\n      }\n      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n      else\n        polytree.AddChild(outRec.PolyNode);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n  {\n    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n    //parallel edges by removing the middle vertex.\n    var lastOK = null;\n    outRec.BottomPt = null;\n    var pp = outRec.Pts;\n    for (;;)\n    {\n      if (pp.Prev == pp || pp.Prev == pp.Next)\n      {\n        outRec.Pts = null;\n        return;\n      }\n      //test for duplicate points and collinear edges ...\n      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n      {\n        lastOK = null;\n        pp.Prev.Next = pp.Next;\n        pp.Next.Prev = pp.Prev;\n        pp = pp.Prev;\n      }\n      else if (pp == lastOK)\n        break;\n      else\n      {\n        if (lastOK === null)\n          lastOK = pp;\n        pp = pp.Next;\n      }\n    }\n    outRec.Pts = pp;\n  };\n  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n  {\n    var result = new ClipperLib.OutPt();\n    //result.Pt = outPt.Pt;\n    result.Pt.X = outPt.Pt.X;\n    result.Pt.Y = outPt.Pt.Y;\n    result.Idx = outPt.Idx;\n    if (InsertAfter)\n    {\n      result.Next = outPt.Next;\n      result.Prev = outPt;\n      outPt.Next.Prev = result;\n      outPt.Next = result;\n    }\n    else\n    {\n      result.Prev = outPt.Prev;\n      result.Next = outPt;\n      outPt.Prev.Next = result;\n      outPt.Prev = result;\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n  {\n    if (a1 < a2)\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a1, b1);\n        $val.Right = Math.min(a2, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a1, b2);\n        $val.Right = Math.min(a2, b1);\n      }\n    }\n    else\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a2, b1);\n        $val.Right = Math.min(a1, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a2, b2);\n        $val.Right = Math.min(a1, b1);\n      }\n    }\n    return $val.Left < $val.Right;\n  };\n  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n  {\n    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    if (Dir1 == Dir2)\n      return false;\n    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n    //So, to facilitate this while inserting Op1b and Op2b ...\n    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op1.Next.Pt.X <= Pt.X &&\n        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op1.Next.Pt.X >= Pt.X &&\n        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, DiscardLeft);\n      }\n    }\n    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op2.Next.Pt.X <= Pt.X &&\n        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op2.Next.Pt.X >= Pt.X &&\n        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, DiscardLeft);\n      }\n    }\n    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n    {\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n    }\n    else\n    {\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n  {\n    var op1 = j.OutPt1,\n      op1b = new ClipperLib.OutPt();\n    var op2 = j.OutPt2,\n      op2b = new ClipperLib.OutPt();\n    //There are 3 kinds of joins for output polygons ...\n    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n    //3. StrictlySimple joins where edges touch but are not collinear and where\n    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n    {\n      //Strictly Simple join ...\n\t\t\tif (outRec1 != outRec2) return false;\n\n      op1b = j.OutPt1.Next;\n      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n        op1b = op1b.Next;\n      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n      op2b = j.OutPt2.Next;\n      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n        op2b = op2b.Next;\n      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n      if (reverse1 == reverse2)\n        return false;\n      if (reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n    else if (isHorizontal)\n    {\n      //treat horizontal joins differently to non-horizontal joins since with\n      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n      //may be anywhere along the horizontal edge.\n      op1b = op1;\n      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n        op1 = op1.Prev;\n      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n        op1b = op1b.Next;\n      if (op1b.Next == op1 || op1b.Next == op2)\n        return false;\n      //a flat 'polygon'\n      op2b = op2;\n      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n        op2 = op2.Prev;\n      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n        op2b = op2b.Next;\n      if (op2b.Next == op2 || op2b.Next == op1)\n        return false;\n      //a flat 'polygon'\n      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n      var $val = {Left: null, Right: null};\n      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n        return false;\n      var Left = $val.Left;\n      var Right = $val.Right;\n\n      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n      //on the discard Side as either may still be needed for other joins ...\n      var Pt = new ClipperLib.IntPoint();\n      var DiscardLeftSide;\n      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n      {\n        //Pt = op1.Pt;\n        Pt.X = op1.Pt.X;\n        Pt.Y = op1.Pt.Y;\n        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n      }\n      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n      {\n        //Pt = op2.Pt;\n        Pt.X = op2.Pt.X;\n        Pt.Y = op2.Pt.Y;\n        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n      }\n      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n      {\n        //Pt = op1b.Pt;\n        Pt.X = op1b.Pt.X;\n        Pt.Y = op1b.Pt.Y;\n        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n      }\n      else\n      {\n        //Pt = op2b.Pt;\n        Pt.X = op2b.Pt.X;\n        Pt.Y = op2b.Pt.Y;\n        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n      }\n      j.OutPt1 = op1;\n      j.OutPt2 = op2;\n      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n    }\n    else\n    {\n      //nb: For non-horizontal joins ...\n      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n      //make sure the polygons are correctly oriented ...\n      op1b = op1.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n        op1b = op1b.Next;\n      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse1)\n      {\n        op1b = op1.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n          op1b = op1b.Prev;\n        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      op2b = op2.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n        op2b = op2b.Next;\n      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse2)\n      {\n        op2b = op2.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n          op2b = op2b.Prev;\n        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n        return false;\n      if (Reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n  };\n  ClipperLib.Clipper.GetBounds = function (paths)\n  {\n    var i = 0,\n      cnt = paths.length;\n    while (i < cnt && paths[i].length == 0) i++;\n    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n    var result = new ClipperLib.IntRect();\n    result.left = paths[i][0].X;\n    result.right = result.left;\n    result.top = paths[i][0].Y;\n    result.bottom = result.top;\n    for (; i < cnt; i++)\n      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n      {\n        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n      }\n    return result;\n  }\n  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n  {\n    var opStart = ops;\n    var result = new ClipperLib.IntRect();\n    result.left = ops.Pt.X;\n    result.right = ops.Pt.X;\n    result.top = ops.Pt.Y;\n    result.bottom = ops.Pt.Y;\n    ops = ops.Next;\n    while (ops != opStart)\n    {\n      if (ops.Pt.X < result.left)\n        result.left = ops.Pt.X;\n      if (ops.Pt.X > result.right)\n        result.right = ops.Pt.X;\n      if (ops.Pt.Y < result.top)\n        result.top = ops.Pt.Y;\n      if (ops.Pt.Y > result.bottom)\n        result.bottom = ops.Pt.Y;\n      ops = ops.Next;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0,\n      cnt = path.length;\n    if (cnt < 3)\n      return 0;\n    var ip = path[0];\n    for (var i = 1; i <= cnt; ++i)\n    {\n      var ipNext = (i == cnt ? path[0] : path[i]);\n      if (ipNext.Y == pt.Y)\n      {\n        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n          return -1;\n      }\n      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n      {\n        if (ip.X >= pt.X)\n        {\n          if (ipNext.X > pt.X)\n            result = 1 - result;\n          else\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (ipNext.X > pt.X)\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n      }\n      ip = ipNext;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0;\n    var startOp = op;\n\t\tvar ptx = pt.X, pty = pt.Y;\n    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n    do\n    {\n\t\t\top = op.Next;\n\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n      if (poly1y == pty)\n      {\n        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n          return -1;\n      }\n      if ((poly0y < pty) != (poly1y < pty))\n      {\n        if (poly0x >= ptx)\n        {\n          if (poly1x > ptx)\n            result = 1 - result;\n          else\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (poly1x > ptx)\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n      }\n      poly0x = poly1x;\n      poly0y = poly1y;\n    } while (startOp != op);\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n  {\n    var op = outPt1;\n    do\n    {\n\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n      var res = this.PointInPolygon(op.Pt, outPt2);\n      if (res >= 0)\n        return res > 0;\n      op = op.Next;\n    }\n    while (op != outPt1)\n    return true;\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\tcontinue;\n\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (firstLeft == OldOutRec)\n\t\t\t{\n        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n          outRec.FirstLeft = NewOutRec;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n  {\n    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n      if (outRec.FirstLeft == OldOutRec)\n        outRec.FirstLeft = NewOutRec;\n  };\n  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n  {\n    while (FirstLeft != null && FirstLeft.Pts == null)\n      FirstLeft = FirstLeft.FirstLeft;\n    return FirstLeft;\n  };\n  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n  {\n    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n    {\n      var join = this.m_Joins[i];\n      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n      if (outRec1.Pts == null || outRec2.Pts == null)\n        continue;\n      //get the polygon fragment with the correct hole state (FirstLeft)\n      //before calling JoinPoints() ...\n      var holeStateRec;\n      if (outRec1 == outRec2)\n        holeStateRec = outRec1;\n      else if (this.Param1RightOfParam2(outRec1, outRec2))\n        holeStateRec = outRec2;\n      else if (this.Param1RightOfParam2(outRec2, outRec1))\n        holeStateRec = outRec1;\n      else\n        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n      if (outRec1 == outRec2)\n      {\n        //instead of joining two polygons, we've just created a new one by\n        //splitting one polygon into two.\n        outRec1.Pts = join.OutPt1;\n        outRec1.BottomPt = null;\n        outRec2 = this.CreateOutRec();\n        outRec2.Pts = join.OutPt2;\n        //update all OutRec2.Pts Idx's ...\n        this.UpdateOutPtIdxs(outRec2);\n        //We now need to check every OutRec.FirstLeft pointer. If it points\n        //to OutRec1 it may need to point to OutRec2 instead ...\n        if (this.m_UsingPolyTree)\n          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n          {\n            var oRec = this.m_PolyOuts[j];\n            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n              continue;\n            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n              oRec.FirstLeft = outRec2;\n          }\n        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n        {\n          //outRec2 is contained by outRec1 ...\n          outRec2.IsHole = !outRec1.IsHole;\n          outRec2.FirstLeft = outRec1;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec2, outRec1);\n          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n            this.ReversePolyPtLinks(outRec2.Pts);\n        }\n        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n        {\n          //outRec1 is contained by outRec2 ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec1.IsHole = !outRec2.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          outRec1.FirstLeft = outRec2;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec1, outRec2);\n          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n            this.ReversePolyPtLinks(outRec1.Pts);\n        }\n        else\n        {\n          //the 2 polygons are completely separate ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          //fixup FirstLeft pointers that may need reassigning to OutRec2\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts1(outRec1, outRec2);\n        }\n      }\n      else\n      {\n        //joined 2 polygons together ...\n        outRec2.Pts = null;\n        outRec2.BottomPt = null;\n        outRec2.Idx = outRec1.Idx;\n        outRec1.IsHole = holeStateRec.IsHole;\n        if (holeStateRec == outRec2)\n          outRec1.FirstLeft = outRec2.FirstLeft;\n        outRec2.FirstLeft = outRec1;\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n  {\n    var op = outrec.Pts;\n    do {\n      op.Idx = outrec.Idx;\n      op = op.Prev;\n    }\n    while (op != outrec.Pts)\n  };\n  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n  {\n    var i = 0;\n    while (i < this.m_PolyOuts.length)\n    {\n      var outrec = this.m_PolyOuts[i++];\n      var op = outrec.Pts;\n\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\tcontinue;\n      do //for each Pt in Polygon until duplicate found do ...\n      {\n        var op2 = op.Next;\n        while (op2 != outrec.Pts)\n        {\n          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n          {\n            //split the polygon into two ...\n            var op3 = op.Prev;\n            var op4 = op2.Prev;\n            op.Prev = op4;\n            op4.Next = op;\n            op2.Prev = op3;\n            op3.Next = op2;\n            outrec.Pts = op;\n            var outrec2 = this.CreateOutRec();\n            outrec2.Pts = op2;\n            this.UpdateOutPtIdxs(outrec2);\n            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n            {\n              //OutRec2 is contained by OutRec1 ...\n              outrec2.IsHole = !outrec.IsHole;\n              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n            }\n            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n            {\n              //OutRec1 is contained by OutRec2 ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec.IsHole = !outrec2.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n              outrec.FirstLeft = outrec2;\n              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n            }\n            else\n            {\n              //the 2 polygons are separate ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n            }\n            op2 = op;\n            //ie get ready for the next iteration\n          }\n          op2 = op2.Next;\n        }\n        op = op.Next;\n      }\n      while (op != outrec.Pts)\n    }\n  };\n  ClipperLib.Clipper.Area = function (poly)\n  {\n    var cnt = poly.length;\n    if (cnt < 3)\n      return 0;\n    var a = 0;\n    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n    {\n      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n      j = i;\n    }\n    return -a * 0.5;\n  };\n  ClipperLib.Clipper.prototype.Area = function (outRec)\n  {\n    var op = outRec.Pts;\n    if (op == null)\n      return 0;\n    var a = 0;\n    do {\n      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n      op = op.Next;\n    }\n    while (op != outRec.Pts)\n    return a * 0.5;\n  };\n  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n  {\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n  {\n    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n  {\n    var dx = (pt1.X - pt2.X);\n    var dy = (pt1.Y - pt2.Y);\n    return (dx * dx + dy * dy);\n  };\n  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n  {\n    //The equation of a line in general form (Ax + By + C = 0)\n    //given 2 points (x¹,y¹) & (x²,y²) is ...\n    //(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0\n    //A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹\n    //perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)\n    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n    var A = ln1.Y - ln2.Y;\n    var B = ln2.X - ln1.X;\n    var C = A * ln1.X + B * ln1.Y;\n    C = A * pt.X + B * pt.Y - C;\n    return (C * C) / (A * A + B * B);\n  };\n\n\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t{\n\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t//between the other 2 points is the one that's tested for distance.\n\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t{\n\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t\telse\n\t\t{\n\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t}\n\n  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n  {\n    var dx = pt1.X - pt2.X;\n    var dy = pt1.Y - pt2.Y;\n    return ((dx * dx) + (dy * dy) <= distSqrd);\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.Clipper.ExcludeOp = function (op)\n  {\n    var result = op.Prev;\n    result.Next = op.Next;\n    op.Next.Prev = result;\n    result.Idx = 0;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n  {\n    if (typeof (distance) == \"undefined\") distance = 1.415;\n    //distance = proximity in units/pixels below which vertices will be stripped.\n    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n    //both x & y coords within 1 unit, then the second vertex will be stripped.\n    var cnt = path.length;\n    if (cnt == 0)\n      return new Array();\n    var outPts = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n      outPts[i] = new ClipperLib.OutPt();\n    for (var i = 0; i < cnt; ++i)\n    {\n      outPts[i].Pt = path[i];\n      outPts[i].Next = outPts[(i + 1) % cnt];\n      outPts[i].Next.Prev = outPts[i];\n      outPts[i].Idx = 0;\n    }\n    var distSqrd = distance * distance;\n    var op = outPts[0];\n    while (op.Idx == 0 && op.Next != op.Prev)\n    {\n      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n      {\n        ClipperLib.Clipper.ExcludeOp(op.Next);\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt -= 2;\n      }\n      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else\n      {\n        op.Idx = 1;\n        op = op.Next;\n      }\n    }\n    if (cnt < 3)\n      cnt = 0;\n    var result = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n    {\n      result[i] = new ClipperLib.IntPoint(op.Pt);\n      op = op.Next;\n    }\n    outPts = null;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n  {\n    var result = new Array(polys.length);\n    for (var i = 0, ilen = polys.length; i < ilen; i++)\n      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n    return result;\n  };\n  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n  {\n    var delta = (IsClosed ? 1 : 0);\n    var polyCnt = pattern.length;\n    var pathCnt = path.length;\n    var result = new Array();\n    if (IsSum)\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n        result.push(p);\n      }\n    else\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n        result.push(p);\n      }\n    var quads = new Array();\n    for (var i = 0; i < pathCnt - 1 + delta; i++)\n      for (var j = 0; j < polyCnt; j++)\n      {\n        var quad = new Array();\n        quad.push(result[i % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n        if (!ClipperLib.Clipper.Orientation(quad))\n          quad.reverse();\n        quads.push(quad);\n      }\n\t\t\treturn quads;\n  };\n\n\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t{\n\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t{\n\t\t\tvar path = path_or_paths;\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\telse\n\t\t{\n \t\t\tvar paths = path_or_paths;\n\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t{\n\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (pathIsClosed)\n\t\t\t\t{\n\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn solution;\n\t\t}\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t{\n\t\tvar outPath = new ClipperLib.Path();\n\t\tfor (var i = 0; i < path.length; i++)\n\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\treturn outPath;\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t{\n\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\tvar c = new ClipperLib.Clipper();\n\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\treturn paths;\n\t}\n\n  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n  {\n    var result = new Array();\n    //result.set_Capacity(polytree.get_Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n    return result;\n  };\n  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n  {\n    var match = true;\n    switch (nt)\n    {\n    case ClipperLib.Clipper.NodeType.ntOpen:\n      return;\n    case ClipperLib.Clipper.NodeType.ntClosed:\n      match = !polynode.IsOpen;\n      break;\n    default:\n      break;\n    }\n    if (polynode.m_polygon.length > 0 && match)\n      paths.push(polynode.m_polygon);\n    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n  };\n  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.ChildCount());\n    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n      if (polytree.Childs()[i].IsOpen)\n        result.push(polytree.Childs()[i].m_polygon);\n    return result;\n  };\n  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n    return result;\n  };\n  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n  ClipperLib.Clipper.NodeType = {\n    ntAny: 0,\n    ntOpen: 1,\n    ntClosed: 2\n  };\n  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n  {\n    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n    this.m_destPolys = new ClipperLib.Paths();\n    this.m_srcPoly = new ClipperLib.Path();\n    this.m_destPoly = new ClipperLib.Path();\n    this.m_normals = new Array();\n    this.m_delta = 0;\n    this.m_sinA = 0;\n    this.m_sin = 0;\n    this.m_cos = 0;\n    this.m_miterLim = 0;\n    this.m_StepsPerRad = 0;\n    this.m_lowest = new ClipperLib.IntPoint();\n    this.m_polyNodes = new ClipperLib.PolyNode();\n    this.MiterLimit = miterLimit;\n    this.ArcTolerance = arcTolerance;\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n  ClipperLib.ClipperOffset.prototype.Clear = function ()\n  {\n    ClipperLib.Clear(this.m_polyNodes.Childs());\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n  {\n    var highI = path.length - 1;\n    if (highI < 0)\n      return;\n    var newNode = new ClipperLib.PolyNode();\n    newNode.m_jointype = joinType;\n    newNode.m_endtype = endType;\n    //strip duplicate points from path and also get index to the lowest point ...\n    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n        highI--;\n    //newNode.m_polygon.set_Capacity(highI + 1);\n    newNode.m_polygon.push(path[0]);\n    var j = 0,\n      k = 0;\n    for (var i = 1; i <= highI; i++)\n      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n      {\n        j++;\n        newNode.m_polygon.push(path[i]);\n        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n          k = j;\n      }\n    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n    this.m_polyNodes.AddChild(newNode);\n    //if this path's lowest pt is lower than all the others then update m_lowest\n    if (endType != ClipperLib.EndType.etClosedPolygon)\n      return;\n    if (this.m_lowest.X < 0)\n      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    else\n    {\n      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n  {\n    for (var i = 0, ilen = paths.length; i < ilen; i++)\n      this.AddPath(paths[i], joinType, endType);\n  };\n  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n  {\n    //fixup orientations of all closed paths if the orientation of the\n    //closed path with the lowermost vertex is wrong ...\n    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n          node.m_polygon.reverse();\n      }\n    }\n    else\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n          node.m_polygon.reverse();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n  {\n    var dx = (pt2.X - pt1.X);\n    var dy = (pt2.Y - pt1.Y);\n    if ((dx == 0) && (dy == 0))\n      return new ClipperLib.DoublePoint(0, 0);\n    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n    dx *= f;\n    dy *= f;\n    return new ClipperLib.DoublePoint(dy, -dx);\n  };\n  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n  {\n    this.m_destPolys = new Array();\n    this.m_delta = delta;\n    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n    if (ClipperLib.ClipperBase.near_zero(delta))\n    {\n      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n          this.m_destPolys.push(node.m_polygon);\n      }\n      return;\n    }\n    //see offset_triginometry3.svg in the documentation folder ...\n    if (this.MiterLimit > 2)\n      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n    else\n      this.m_miterLim = 0.5;\n    var y;\n    if (this.ArcTolerance <= 0)\n      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n    else\n      y = this.ArcTolerance;\n    //see offset_triginometry2.svg in the documentation folder ...\n    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n    if (delta < 0)\n      this.m_sin = -this.m_sin;\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      this.m_srcPoly = node.m_polygon;\n      var len = this.m_srcPoly.length;\n      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n        continue;\n      this.m_destPoly = new Array();\n      if (len == 1)\n      {\n        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n        {\n          var X = 1,\n            Y = 0;\n          for (var j = 1; j <= steps; j++)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            var X2 = X;\n            X = X * this.m_cos - this.m_sin * Y;\n            Y = X2 * this.m_sin + Y * this.m_cos;\n          }\n        }\n        else\n        {\n          var X = -1,\n            Y = -1;\n          for (var j = 0; j < 4; ++j)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            if (X < 0)\n              X = 1;\n            else if (Y < 0)\n              Y = 1;\n            else\n              X = -1;\n          }\n        }\n        this.m_destPolys.push(this.m_destPoly);\n        continue;\n      }\n      //build m_normals ...\n      this.m_normals.length = 0;\n      //this.m_normals.set_Capacity(len);\n      for (var j = 0; j < len - 1; j++)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n      else\n        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n        this.m_destPoly = new Array();\n        //re-build m_normals ...\n        var n = this.m_normals[len - 1];\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n        k = 0;\n        for (var j = len - 1; j >= 0; j--)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else\n      {\n        var k = 0;\n        for (var j = 1; j < len - 1; ++j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        var pt1;\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          var j = len - 1;\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          var j = len - 1;\n          k = len - 2;\n          this.m_sinA = 0;\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(j, k);\n          else\n            this.DoRound(j, k);\n        }\n        //re-build m_normals ...\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n        k = len - 1;\n        for (var j = k - 1; j > 0; --j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          k = 1;\n          this.m_sinA = 0;\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(0, 1);\n          else\n            this.DoRound(0, 1);\n        }\n        this.m_destPolys.push(this.m_destPoly);\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.Execute = function ()\n  {\n    var a = arguments,\n      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n    if (!ispolytree) // function (solution, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      ClipperLib.Clear(solution);\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        if (solution.length > 0)\n          solution.splice(0, 1);\n      }\n      //console.log(JSON.stringify(solution));\n    }\n    else // function (polytree, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      solution.Clear();\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        //remove the outer PolyNode rectangle ...\n        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n        {\n          var outerNode = solution.Childs()[0];\n          //solution.Childs.set_Capacity(outerNode.ChildCount);\n          solution.Childs()[0] = outerNode.Childs()[0];\n          solution.Childs()[0].m_Parent = solution;\n          for (var i = 1; i < outerNode.ChildCount(); i++)\n            solution.AddChild(outerNode.Childs()[i]);\n        }\n        else\n          solution.Clear();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n  {\n\t\t//cross product ...\n\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\n\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t{\n\t\t\t//dot product ...\n\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t{\n\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\t//else angle ==> 180 degrees\n\t\t}\n    else if (this.m_sinA > 1)\n      this.m_sinA = 1.0;\n    else if (this.m_sinA < -1)\n      this.m_sinA = -1.0;\n    if (this.m_sinA * this.m_delta < 0)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n    }\n    else\n      switch (jointype)\n      {\n      case ClipperLib.JoinType.jtMiter:\n        {\n          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n          if (r >= this.m_miterLim)\n            this.DoMiter(j, k, r);\n          else\n            this.DoSquare(j, k);\n          break;\n        }\n      case ClipperLib.JoinType.jtSquare:\n        this.DoSquare(j, k);\n        break;\n      case ClipperLib.JoinType.jtRound:\n        this.DoRound(j, k);\n        break;\n      }\n    k = j;\n    return k;\n  };\n  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n  {\n    var dx = Math.tan(Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n  };\n  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n  {\n    var q = this.m_delta / r;\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n  };\n  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n  {\n    var a = Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\n    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\n    var X = this.m_normals[k].X,\n      Y = this.m_normals[k].Y,\n      X2;\n    for (var i = 0; i < steps; ++i)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n      X2 = X;\n      X = X * this.m_cos - this.m_sin * Y;\n      Y = X2 * this.m_sin + Y * this.m_cos;\n    }\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n  };\n  ClipperLib.Error = function (message)\n  {\n    try\n    {\n      throw new Error(message);\n    }\n    catch (err)\n    {\n      alert(err.message);\n    }\n  };\n  // ---------------------------------\n  // JS extension by Timo 2013\n  ClipperLib.JS = {};\n  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n  };\n  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    var area = 0;\n    for (var i = 0; i < poly.length; i++)\n    {\n      area += ClipperLib.Clipper.Area(poly[i]);\n    }\n    return area / (scale * scale);\n  };\n  ClipperLib.JS.BoundsOfPath = function (path, scale)\n  {\n    return ClipperLib.JS.BoundsOfPaths([path], scale);\n  };\n  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n  {\n    if (!scale) scale = 1;\n    var bounds = ClipperLib.Clipper.GetBounds(paths);\n    bounds.left /= scale;\n    bounds.bottom /= scale;\n    bounds.right /= scale;\n    bounds.top /= scale;\n    return bounds;\n  };\n  // Clean() joins vertices that are too near each other\n  // and causes distortion to offsetted polygons without cleaning\n  ClipperLib.JS.Clean = function (polygon, delta)\n  {\n    if (!(polygon instanceof Array)) return [];\n    var isPolygons = polygon[0] instanceof Array;\n    var polygon = ClipperLib.JS.Clone(polygon);\n    if (typeof delta != \"number\" || delta === null)\n    {\n      ClipperLib.Error(\"Delta is not a number in Clean().\");\n      return polygon;\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n    if (!isPolygons) polygon = [polygon];\n    var k_length = polygon.length;\n    var len, poly, result, d, p, j, i;\n    var results = [];\n    for (var k = 0; k < k_length; k++)\n    {\n      poly = polygon[k];\n      len = poly.length;\n      if (len === 0) continue;\n      else if (len < 3)\n      {\n        result = poly;\n        results.push(result);\n        continue;\n      }\n      result = poly;\n      d = delta * delta;\n      //d = Math.floor(c_delta * c_delta);\n      p = poly[0];\n      j = 1;\n      for (i = 1; i < len; i++)\n      {\n        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n          continue;\n        result[j] = poly[i];\n        p = poly[i];\n        j++;\n      }\n      p = poly[j - 1];\n      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n        j--;\n      if (j < len)\n        result.splice(j, len - j);\n      if (result.length) results.push(result);\n    }\n    if (!isPolygons && results.length) results = results[0];\n    else if (!isPolygons && results.length === 0) results = [];\n    else if (isPolygons && results.length === 0) results = [\n      []\n    ];\n    return results;\n  }\n  // Make deep copy of Polygons or Polygon\n  // so that also IntPoint objects are cloned and not only referenced\n  // This should be the fastest way\n  ClipperLib.JS.Clone = function (polygon)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (polygon.length === 0) return [];\n    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n    var isPolygons = polygon[0] instanceof Array;\n    if (!isPolygons) polygon = [polygon];\n    var len = polygon.length,\n      plen, i, j, result;\n    var results = new Array(len);\n    for (i = 0; i < len; i++)\n    {\n      plen = polygon[i].length;\n      result = new Array(plen);\n      for (j = 0; j < plen; j++)\n      {\n        result[j] = {\n          X: polygon[i][j].X,\n          Y: polygon[i][j].Y\n        };\n      }\n      results[i] = result;\n    }\n    if (!isPolygons) results = results[0];\n    return results;\n  };\n  // Removes points that doesn't affect much to the visual appearance.\n  // If middle point is at or under certain distance (tolerance) of the line segment between\n  // start and end point, the middle point is removed.\n  ClipperLib.JS.Lighten = function (polygon, tolerance)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (typeof tolerance != \"number\" || tolerance === null)\n    {\n      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n    {\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n    var bxax, byay, l, ax, ay;\n    var len = polygon.length;\n    var toleranceSq = tolerance * tolerance;\n    var results = [];\n    for (i = 0; i < len; i++)\n    {\n      poly = polygon[i];\n      plen = poly.length;\n      if (plen == 0) continue;\n      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n      {\n        poly2 = [];\n        plen = poly.length;\n        // the first have to added to the end, if first and last are not the same\n        // this way we ensure that also the actual last point can be removed if needed\n        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n        {\n          addlast = 1;\n          poly.push(\n          {\n            X: poly[0].X,\n            Y: poly[0].Y\n          });\n          plen = poly.length;\n        }\n        else addlast = 0;\n        rem = []; // Indexes of removed points\n        for (j = 0; j < plen - 2; j++)\n        {\n          A = poly[j]; // Start point of line segment\n          P = poly[j + 1]; // Middle point. This is the one to be removed.\n          B = poly[j + 2]; // End point of line segment\n          ax = A.X;\n          ay = A.Y;\n          bxax = B.X - ax;\n          byay = B.Y - ay;\n          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n          {\n            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n            if (l > 1)\n            {\n              ax = B.X;\n              ay = B.Y;\n            }\n            else if (l > 0)\n            {\n              ax += bxax * l;\n              ay += byay * l;\n            }\n          }\n          bxax = P.X - ax;\n          byay = P.Y - ay;\n          d = bxax * bxax + byay * byay;\n          if (d <= toleranceSq)\n          {\n            rem[j + 1] = 1;\n            j++; // when removed, transfer the pointer to the next one\n          }\n        }\n        // add all unremoved points to poly2\n        poly2.push(\n        {\n          X: poly[0].X,\n          Y: poly[0].Y\n        });\n        for (j = 1; j < plen - 1; j++)\n          if (!rem[j]) poly2.push(\n          {\n            X: poly[j].X,\n            Y: poly[j].Y\n          });\n        poly2.push(\n        {\n          X: poly[plen - 1].X,\n          Y: poly[plen - 1].Y\n        });\n        // if the first point was added to the end, remove it\n        if (addlast) poly.pop();\n        // break, if there was not anymore removed points\n        if (!rem.length) break;\n        // else continue looping using poly2, to check if there are points to remove\n        else poly = poly2;\n      }\n      plen = poly2.length;\n      // remove duplicate from end, if needed\n      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n      {\n        poly2.pop();\n      }\n      if (poly2.length > 2) // to avoid two-point-polygons\n        results.push(poly2);\n    }\n    if (!(polygon[0] instanceof Array)) results = results[0];\n    if (typeof (results) == \"undefined\") results = [\n      []\n    ];\n    return results;\n  }\n  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n  {\n    if (typeof (path) == \"undefined\") return 0;\n    var sqrt = Math.sqrt;\n    var perimeter = 0.0;\n    var p1, p2, p1x = 0.0,\n      p1y = 0.0,\n      p2x = 0.0,\n      p2y = 0.0;\n    var j = path.length;\n    if (j < 2) return 0;\n    if (closed)\n    {\n      path[j] = path[0];\n      j++;\n    }\n    while (--j)\n    {\n      p1 = path[j];\n      p1x = p1.X;\n      p1y = p1.Y;\n      p2 = path[j - 1];\n      p2x = p2.X;\n      p2y = p2.Y;\n      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n    }\n    if (closed) path.pop();\n    return perimeter / scale;\n  };\n  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n  {\n    if (!scale) scale = 1;\n    var perimeter = 0;\n    for (var i = 0; i < paths.length; i++)\n    {\n      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n    }\n    return perimeter;\n  };\n  ClipperLib.JS.ScaleDownPath = function (path, scale)\n  {\n    var i, p;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = p.X / scale;\n      p.Y = p.Y / scale;\n    }\n  };\n  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n  {\n    var i, j, p;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = p.X / scale;\n        p.Y = p.Y / scale;\n      }\n    }\n  };\n  ClipperLib.JS.ScaleUpPath = function (path, scale)\n  {\n    var i, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = round(p.X * scale);\n      p.Y = round(p.Y * scale);\n    }\n  };\n  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n  {\n    var i, j, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = round(p.X * scale);\n        p.Y = round(p.Y * scale);\n      }\n    }\n  };\n  ClipperLib.ExPolygons = function ()\n  {\n    return [];\n  }\n  ClipperLib.ExPolygon = function ()\n  {\n    this.outer = null;\n    this.holes = null;\n  };\n  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n  {\n    var ep = new ClipperLib.ExPolygon();\n    ep.outer = polynode.Contour();\n    var childs = polynode.Childs();\n    var ilen = childs.length;\n    ep.holes = new Array(ilen);\n    var node, n, i, j, childs2, jlen;\n    for (i = 0; i < ilen; i++)\n    {\n      node = childs[i];\n      ep.holes[i] = node.Contour();\n      //Add outer polygons contained by (nested within) holes ...\n      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n      {\n        n = childs2[j];\n        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n      }\n    }\n    expolygons.push(ep);\n  };\n  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n  {\n    var a, i, alen, ilen;\n    var paths = new ClipperLib.Paths();\n    for (a = 0, alen = expolygons.length; a < alen; a++)\n    {\n      paths.push(expolygons[a].outer);\n      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n      {\n        paths.push(expolygons[a].holes[i]);\n      }\n    }\n    return paths;\n  }\n  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n  {\n    var expolygons = new ClipperLib.ExPolygons();\n    var node, i, childs, ilen;\n    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n    {\n      node = childs[i];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n    }\n    return expolygons;\n  };\n})();\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}