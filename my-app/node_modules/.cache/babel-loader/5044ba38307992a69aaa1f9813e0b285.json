{"ast":null,"code":"import { DivIcon, Marker, DomEvent } from 'leaflet';\nimport { polygons, modesKey, notifyDeferredKey } from '../FreeDraw';\nimport { updateFor } from './Layer';\nimport { CREATE, EDIT } from './Flags';\nimport mergePolygons, { fillPolygon } from './Merge';\n/**\n * @method createEdges\n * @param {Object} map\n * @param {L.Polygon} polygon\n * @param {Object} options\n * @return {Array}\n */\n\nexport default function createEdges(map, polygon, options) {\n  /**\n   * @method fetchLayerPoints\n   * @param polygon {Object}\n   * @return {Array}\n   */\n  const fetchLayerPoints = polygon => {\n    return polygon.getLatLngs()[0].map(latLng => {\n      return map.latLngToLayerPoint(latLng);\n    });\n  };\n\n  const markers = fetchLayerPoints(polygon).map(point => {\n    const mode = map[modesKey];\n    const icon = new DivIcon({\n      className: `leaflet-edge ${mode & EDIT ? '' : 'disabled'}`.trim()\n    });\n    const latLng = map.layerPointToLatLng(point);\n    const marker = new Marker(latLng, {\n      icon\n    }).addTo(map); // Disable the propagation when you click on the marker.\n\n    DomEvent.disableClickPropagation(marker);\n    marker.on('mousedown', function mouseDown() {\n      if (!(map[modesKey] & EDIT)) {\n        // Polygons can only be created when the mode includes edit.\n        map.off('mousedown', mouseDown);\n        return;\n      } // Disable the map dragging as otherwise it's difficult to reposition the edge.\n\n\n      map.dragging.disable();\n      /**\n       * @method mouseMove\n       * @param {Object} event\n       * @return {void}\n       */\n\n      const mouseMove = event => {\n        // Determine where to move the marker to from the mouse move event.\n        const containerPoint = map.latLngToContainerPoint(event.latlng);\n        const latLng = map.containerPointToLatLng(containerPoint); // Update the marker with the new lat/lng.\n\n        marker.setLatLng(latLng); // ...And finally update the polygon to match the current markers.\n\n        const latLngs = markers.map(marker => marker.getLatLng());\n        polygon.setLatLngs(latLngs);\n        polygon.redraw();\n      }; // Listen for the mouse move events to determine where to move the marker to.\n\n\n      map.on('mousemove', mouseMove);\n      /**\n       * @method mouseUp\n       * @return {void}\n       */\n\n      function mouseUp() {\n        if (!(map[modesKey] & CREATE)) {\n          // Re-enable the dragging of the map only if created mode is not enabled.\n          map.dragging.enable();\n        } // Stop listening to the events.\n\n\n        map.off('mouseup', mouseUp);\n        map.off('mousedown', mouseDown);\n        map.off('mousemove', mouseMove); // Attempt to simplify the polygon to prevent voids in the polygon.\n\n        fillPolygon(map, polygon, options); // Merge the polygons if the options allow using a two-pass approach as this yields the better results.\n\n        const merge = () => mergePolygons(map, Array.from(polygons.get(map)), options);\n\n        options.mergePolygons && merge() && merge(); // Trigger the event for having modified the edges of a polygon, unless the `notifyAfterEditExit`\n        // option is equal to `true`, in which case we'll defer the notification.\n\n        options.notifyAfterEditExit ? (() => {\n          // Deferred function that will be invoked by `modeFor` when the `EDIT` mode is exited.\n          map[notifyDeferredKey] = () => updateFor(map, 'edit');\n        })() : updateFor(map, 'edit');\n      } // Cleanup the mouse events when the user releases the mouse button.\n      // We need to listen on both map and marker, because if the user moves the edge too quickly then\n      // the mouse up will occur on the map layer.\n\n\n      map.on('mouseup', mouseUp);\n      marker.on('mouseup', mouseUp);\n    });\n    return marker;\n  });\n  return markers;\n}","map":{"version":3,"names":["DivIcon","Marker","DomEvent","polygons","modesKey","notifyDeferredKey","updateFor","CREATE","EDIT","mergePolygons","fillPolygon","createEdges","map","polygon","options","fetchLayerPoints","getLatLngs","latLng","latLngToLayerPoint","markers","point","mode","icon","className","trim","layerPointToLatLng","marker","addTo","disableClickPropagation","on","mouseDown","off","dragging","disable","mouseMove","event","containerPoint","latLngToContainerPoint","latlng","containerPointToLatLng","setLatLng","latLngs","getLatLng","setLatLngs","redraw","mouseUp","enable","merge","Array","from","get","notifyAfterEditExit"],"sources":["/Users/romanradionov/PycharmProjects/reactleafletgeodjango/my-app/node_modules/leaflet-freedraw/src/helpers/Edges.js"],"sourcesContent":["import { DivIcon, Marker, DomEvent } from 'leaflet';\nimport { polygons, modesKey, notifyDeferredKey } from '../FreeDraw';\nimport { updateFor } from './Layer';\nimport { CREATE, EDIT } from './Flags';\nimport mergePolygons, { fillPolygon } from './Merge';\n\n/**\n * @method createEdges\n * @param {Object} map\n * @param {L.Polygon} polygon\n * @param {Object} options\n * @return {Array}\n */\nexport default function createEdges(map, polygon, options) {\n\n    /**\n     * @method fetchLayerPoints\n     * @param polygon {Object}\n     * @return {Array}\n     */\n    const fetchLayerPoints = polygon => {\n\n        return polygon.getLatLngs()[0].map(latLng => {\n            return map.latLngToLayerPoint(latLng);\n        });\n\n    };\n\n    const markers = fetchLayerPoints(polygon).map(point => {\n\n        const mode = map[modesKey];\n        const icon = new DivIcon({ className: `leaflet-edge ${mode & EDIT ? '' : 'disabled'}`.trim() });\n        const latLng = map.layerPointToLatLng(point);\n        const marker = new Marker(latLng, { icon }).addTo(map);\n\n        // Disable the propagation when you click on the marker.\n        DomEvent.disableClickPropagation(marker);\n\n        marker.on('mousedown', function mouseDown() {\n\n            if (!(map[modesKey] & EDIT)) {\n\n                // Polygons can only be created when the mode includes edit.\n                map.off('mousedown', mouseDown);\n                return;\n\n            }\n\n            // Disable the map dragging as otherwise it's difficult to reposition the edge.\n            map.dragging.disable();\n\n            /**\n             * @method mouseMove\n             * @param {Object} event\n             * @return {void}\n             */\n            const mouseMove = event => {\n\n                // Determine where to move the marker to from the mouse move event.\n                const containerPoint = map.latLngToContainerPoint(event.latlng);\n                const latLng = map.containerPointToLatLng(containerPoint);\n\n                // Update the marker with the new lat/lng.\n                marker.setLatLng(latLng);\n\n                // ...And finally update the polygon to match the current markers.\n                const latLngs = markers.map(marker => marker.getLatLng());\n                polygon.setLatLngs(latLngs);\n                polygon.redraw();\n\n            };\n\n            // Listen for the mouse move events to determine where to move the marker to.\n            map.on('mousemove', mouseMove);\n\n            /**\n             * @method mouseUp\n             * @return {void}\n             */\n            function mouseUp() {\n\n                if (!(map[modesKey] & CREATE)) {\n\n                    // Re-enable the dragging of the map only if created mode is not enabled.\n                    map.dragging.enable();\n\n                }\n\n                // Stop listening to the events.\n                map.off('mouseup', mouseUp);\n                map.off('mousedown', mouseDown);\n                map.off('mousemove', mouseMove);\n\n                // Attempt to simplify the polygon to prevent voids in the polygon.\n                fillPolygon(map, polygon, options);\n\n                // Merge the polygons if the options allow using a two-pass approach as this yields the better results.\n                const merge = () => mergePolygons(map, Array.from(polygons.get(map)), options);\n                options.mergePolygons && merge() && merge();\n\n                // Trigger the event for having modified the edges of a polygon, unless the `notifyAfterEditExit`\n                // option is equal to `true`, in which case we'll defer the notification.\n                options.notifyAfterEditExit ? (() => {\n\n                    // Deferred function that will be invoked by `modeFor` when the `EDIT` mode is exited.\n                    map[notifyDeferredKey] = () => updateFor(map, 'edit');\n\n                })() : updateFor(map, 'edit');\n\n            }\n\n            // Cleanup the mouse events when the user releases the mouse button.\n            // We need to listen on both map and marker, because if the user moves the edge too quickly then\n            // the mouse up will occur on the map layer.\n            map.on('mouseup', mouseUp);\n            marker.on('mouseup', mouseUp);\n\n        });\n\n        return marker;\n\n    });\n\n    return markers;\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}