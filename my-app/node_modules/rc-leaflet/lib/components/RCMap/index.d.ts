import 'leaflet/dist/leaflet.css';
import './index.css';
import React, { PureComponent } from 'react';
import PropTypes from 'prop-types';
import { ClassValue } from 'classnames/types';
import L from 'leaflet';
import { ContextType as ThemeContextType } from '../Theme';
import { ContextType as State } from './Context';
interface PartialProps {
    className: ClassValue;
    flyToBounds: boolean;
    bounds: L.LatLngBoundsExpression;
    boundsOptions: L.FitBoundsOptions;
    children: React.ReactNode;
    onZoom: L.LeafletEventHandlerFn;
    onZoomStart: L.LeafletEventHandlerFn;
    onZoomEnd: L.LeafletEventHandlerFn;
    onInit(map: L.Map): void;
}
declare type Props = Readonly<L.MapOptions & Partial<PartialProps>>;
export default class RCMap extends PureComponent<Props, State> {
    static propTypes: {
        className: PropTypes.Requireable<string | number | boolean | object>;
        preferCanvas: PropTypes.Requireable<boolean>;
        attributionControl: PropTypes.Requireable<boolean>;
        zoomControl: PropTypes.Requireable<boolean>;
        closePopupOnClick: PropTypes.Requireable<boolean>;
        zoomSnap: PropTypes.Requireable<number>;
        zoomDelta: PropTypes.Requireable<number>;
        trackResize: PropTypes.Requireable<boolean>;
        boxZoom: PropTypes.Requireable<boolean>;
        doubleClickZoom: PropTypes.Requireable<L.Zoom>;
        dragging: PropTypes.Requireable<boolean>;
        crs: PropTypes.Requireable<PropTypes.InferProps<{
            latLngToPoint: PropTypes.Validator<(...args: any[]) => any>;
            pointToLatLng: PropTypes.Validator<(...args: any[]) => any>;
            project: PropTypes.Validator<(...args: any[]) => any>;
            unproject: PropTypes.Validator<(...args: any[]) => any>;
            scale: PropTypes.Validator<(...args: any[]) => any>;
            zoom: PropTypes.Validator<(...args: any[]) => any>;
            getProjectedBounds: PropTypes.Validator<(...args: any[]) => any>;
            distance: PropTypes.Validator<(...args: any[]) => any>;
            wrapLatLng: PropTypes.Validator<(...args: any[]) => any>;
            code: PropTypes.Requireable<string>;
            wrapLng: PropTypes.Requireable<number[]>;
            wrapLat: PropTypes.Requireable<number[]>;
            infinite: PropTypes.Validator<boolean>;
        }>>;
        center: PropTypes.Requireable<number[] | L.LatLng | PropTypes.InferProps<{
            lat: PropTypes.Validator<number>;
            lng: PropTypes.Validator<number>;
        }>>;
        zoom: PropTypes.Requireable<number>;
        minZoom: PropTypes.Requireable<number>;
        maxZoom: PropTypes.Requireable<number>;
        layers: PropTypes.Requireable<L.Layer[]>;
        maxBounds: PropTypes.Requireable<number[][] | L.LatLngBounds>;
        renderer: PropTypes.Requireable<L.Renderer>;
        zoomAnimation: PropTypes.Requireable<boolean>;
        zoomAnimationThreshold: PropTypes.Requireable<number>;
        fadeAnimation: PropTypes.Requireable<boolean>;
        markerZoomAnimation: PropTypes.Requireable<boolean>;
        transform3DLimit: PropTypes.Requireable<number>;
        inertia: PropTypes.Requireable<boolean>;
        inertiaDeceleration: PropTypes.Requireable<number>;
        inertiaMaxSpeed: PropTypes.Requireable<number>;
        easeLinearity: PropTypes.Requireable<number>;
        worldCopyJump: PropTypes.Requireable<boolean>;
        maxBoundsViscosity: PropTypes.Requireable<number>;
        keyboard: PropTypes.Requireable<boolean>;
        keyboardPanDelta: PropTypes.Requireable<number>;
        scrollWheelZoom: PropTypes.Requireable<L.Zoom>;
        wheelDebounceTime: PropTypes.Requireable<number>;
        wheelPxPerZoomLevel: PropTypes.Requireable<number>;
        tap: PropTypes.Requireable<boolean>;
        tapTolerance: PropTypes.Requireable<number>;
        touchZoom: PropTypes.Requireable<L.Zoom>;
        bounceAtZoomLimits: PropTypes.Requireable<boolean>;
        flyToBounds: PropTypes.Requireable<boolean>;
        bounds: PropTypes.Requireable<number[][] | L.LatLngBounds>;
        boundsOptions: PropTypes.Requireable<PropTypes.InferProps<{
            animate: PropTypes.Requireable<boolean>;
            duration: PropTypes.Requireable<number>;
            easeLinearity: PropTypes.Requireable<number>;
            noMoveStart: PropTypes.Requireable<boolean>;
            paddingTopLeft: PropTypes.Requireable<number[] | [number, number] | L.Point>;
            paddingBottomRight: PropTypes.Requireable<number[] | [number, number] | L.Point>;
            padding: PropTypes.Requireable<number[] | [number, number] | L.Point>;
            maxZoom: PropTypes.Requireable<number>;
        }>>;
        children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        onZoom: PropTypes.Requireable<(...args: any[]) => any>;
        onZoomStart: PropTypes.Requireable<(...args: any[]) => any>;
        onZoomEnd: PropTypes.Requireable<(...args: any[]) => any>;
        onInit: PropTypes.Requireable<(...args: any[]) => any>;
    };
    static defaultProps: Props;
    static contextType: React.Context<ThemeContextType>;
    context: ThemeContextType;
    readonly state: State;
    private ref;
    componentDidMount(): void;
    componentDidUpdate(prevProps: Props): void;
    componentWillUnmount(): void;
    private onZoom;
    private onZoomStart;
    private onZoomEnd;
    render(): React.ReactNode;
}
export {};
