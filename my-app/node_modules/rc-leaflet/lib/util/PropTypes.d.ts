import PropTypes from 'prop-types';
import L from 'leaflet';
declare const ClassValue: PropTypes.Requireable<string | number | boolean | object>;
declare const Zoom: PropTypes.Requireable<L.Zoom>;
declare const CRS: PropTypes.Requireable<PropTypes.InferProps<{
    latLngToPoint: PropTypes.Validator<(...args: any[]) => any>;
    pointToLatLng: PropTypes.Validator<(...args: any[]) => any>;
    project: PropTypes.Validator<(...args: any[]) => any>;
    unproject: PropTypes.Validator<(...args: any[]) => any>;
    scale: PropTypes.Validator<(...args: any[]) => any>;
    zoom: PropTypes.Validator<(...args: any[]) => any>;
    getProjectedBounds: PropTypes.Validator<(...args: any[]) => any>;
    distance: PropTypes.Validator<(...args: any[]) => any>;
    wrapLatLng: PropTypes.Validator<(...args: any[]) => any>;
    code: PropTypes.Requireable<string>;
    wrapLng: PropTypes.Requireable<number[]>;
    wrapLat: PropTypes.Requireable<number[]>;
    infinite: PropTypes.Validator<boolean>;
}>>;
declare const Point: PropTypes.Requireable<number[] | L.LatLng | PropTypes.InferProps<{
    lat: PropTypes.Validator<number>;
    lng: PropTypes.Validator<number>;
}>>;
declare type PointBoundsType = PropTypes.Requireable<number[][] | L.LatLngBounds>;
declare const PointBounds: PointBoundsType;
declare type PixelType = PropTypes.Requireable<number[] | L.PointExpression>;
declare const Pixel: PixelType;
declare const Icon: PropTypes.Requireable<L.Icon<L.IconOptions> | L.DivIcon>;
declare type BoundsType = PropTypes.Requireable<number[][] | L.LatLngBounds>;
declare const Bounds: BoundsType;
declare const BoundsOptions: PropTypes.Requireable<PropTypes.InferProps<{
    animate: PropTypes.Requireable<boolean>;
    duration: PropTypes.Requireable<number>;
    easeLinearity: PropTypes.Requireable<number>;
    noMoveStart: PropTypes.Requireable<boolean>;
    paddingTopLeft: PropTypes.Requireable<number[] | [number, number] | L.Point>;
    paddingBottomRight: PropTypes.Requireable<number[] | [number, number] | L.Point>;
    padding: PropTypes.Requireable<number[] | [number, number] | L.Point>;
    maxZoom: PropTypes.Requireable<number>;
}>>;
declare const TileLayerOptionsShape: {
    tileSize: PropTypes.Requireable<number | L.Point>;
    opacity: PropTypes.Requireable<number>;
    updateWhenIdle: PropTypes.Requireable<boolean>;
    updateWhenZooming: PropTypes.Requireable<boolean>;
    updateInterval: PropTypes.Requireable<number>;
    attribution: PropTypes.Requireable<string>;
    zIndex: PropTypes.Requireable<number>;
    bounds: PropTypes.Requireable<number[][] | L.LatLngBounds>;
    minZoom: PropTypes.Requireable<number>;
    maxZoom: PropTypes.Requireable<number>;
    noWrap: PropTypes.Requireable<boolean>;
    pane: PropTypes.Requireable<string>;
    className: PropTypes.Requireable<string>;
    keepBuffer: PropTypes.Requireable<number>;
    maxNativeZoom: PropTypes.Requireable<number>;
    minNativeZoom: PropTypes.Requireable<number>;
    subdomains: PropTypes.Requireable<string | string[]>;
    errorTileUrl: PropTypes.Requireable<string>;
    zoomOffset: PropTypes.Requireable<number>;
    tms: PropTypes.Requireable<boolean>;
    zoomReverse: PropTypes.Requireable<boolean>;
    detectRetina: PropTypes.Requireable<boolean>;
    crossOrigin: PropTypes.Requireable<string | boolean>;
};
export { ClassValue, Zoom, CRS, Point, PointBounds, Pixel, Icon, Bounds, BoundsOptions, TileLayerOptionsShape };
